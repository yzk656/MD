##  黑马头条

![image-20231018214343077](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182143233.png)

![image-20231018214354268](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182143331.png)

![image-20231018214428008](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182144045.png)

![image-20231018215324065](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182153145.png)

## 项目介绍

![image-20231018215543479](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182155547.png)

![image-20231018220741420](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182207485.png)

![image-20231018220817072](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182208156.png)

![image-20231018220914706](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182209780.png)

![image-20231018221137006](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182211055.png)

![image-20231018221205989](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182212046.png)

### nacos

![image-20231018232618328](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182326383.png)

![image-20231018233146703](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182331790.png)

### 工程结构介绍

![image-20231018234022824](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182340943.png)

![image-20231018234924080](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182349134.png)

### 登录

![image-20231018235033478](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182350530.png)

![image-20231018235502150](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182355192.png)

![image-20231018235613662](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182356721.png)

![image-20231019001049196](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190010248.png)

![image-20231019001504805](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190015842.png)

不加盐会导致密码相同的用户，md5生成的密码也是一样的。加了盐(随机的，每个人不同)就可以保证两个人的密码相同，但是md5生成的密码不同

EnableDiscoveryClient注解

`@EnableDiscoveryClient`是Spring Boot应用程序中的一个注解，用于启用与服务发现平台（如Netflix Eureka、Apache ZooKeeper、Consul或其他类似系统）的服务发现和注册。服务发现是构建基于微服务的应用程序的重要组成部分。

以下是如何在Spring Boot应用程序中使用`@EnableDiscoveryClient`注解的方法：

1. **添加依赖项**：您需要在项目中包含适当的依赖项，以便与计划使用的服务发现平台一起工作。例如，如果您使用Netflix Eureka，应在`pom.xml`（如果使用Maven）或`build.gradle`（如果使用Gradle）中包含`spring-cloud-starter-netflix-eureka-client`依赖项。

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

2. **为应用程序添加注解**：在Spring Boot应用程序的主类上添加`@EnableDiscoveryClient`注解，以启用服务发现功能。以下是一个示例：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class YourApplication {
    public static void main(String[] args) {
        SpringApplication.run(YourApplication.class, args);
    }
}
```

通过在应用程序的主类上添加`@EnableDiscoveryClient`注解，您告诉Spring Boot应用程序使用服务发现功能，并注册自己以便其他服务可以发现和与之通信。这对于构建具有多个微服务的应用程序非常有用。

![image-20231019003546514](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190035678.png)

![image-20231019003629915](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190036976.png)

### 接口定义

![image-20231019003741875](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190037947.png)

StringUtils中isEmpty与isBlank的区别

在Apache Commons Lang库的StringUtils类中，有两个常用的方法，分别是isEmpty和isBlank，它们用于判断字符串是否为空或者是否为空白。这两个方法的区别如下：

1. isEmpty:
   - `StringUtils.isEmpty` 方法用于检查字符串是否为`null`或者长度为0的空字符串。
   - 如果字符串为`null`，或者长度为0，那么这个方法返回`true`。
   - 但是，如果字符串中只包含空格字符（whitespace），那么该方法仍然会返回`false`，即它不会把只包含空格字符的字符串视为非空。

示例：

```java
String str1 = null;
String str2 = "";
String str3 = " ";
String str4 = "Hello, World";

StringUtils.isEmpty(str1);  // true
StringUtils.isEmpty(str2);  // true
StringUtils.isEmpty(str3);  // false
StringUtils.isEmpty(str4);  // false
```

2. isBlank:
   - `StringUtils.isBlank` 方法用于检查字符串是否为空，或者是否只包含空格字符（whitespace）。
   - 如果字符串为`null`、长度为0，或者只包含空格字符，那么该方法返回`true`。
   - 这个方法在判断字符串是否为空白时更严格，因为它会把只包含空格字符的字符串也视为为空白。

示例：

```java
String str1 = null;
String str2 = "";
String str3 = " ";
String str4 = "Hello, World";

StringUtils.isBlank(str1);  // true
StringUtils.isBlank(str2);  // true
StringUtils.isBlank(str3);  // true
StringUtils.isBlank(str4);  // false
```

总结：isEmpty 主要用于判断字符串是否为空，而 isBlank 用于判断字符串是否为空白。您可以根据具体的需求选择使用哪个方法。如果需要严格判断是否为空白，可以使用 isBlank 方法。



ApUser dbUser = getOne(Wrappers.<ApUser>lambdaQuery().eq(ApUser::getPhone, dto.getPhone())); 这是什么写法，与lambdaquerwraper的区别

这行代码使用了MyBatis-Plus中的`getOne`方法来查询数据库表中的记录，并结合了LambdaQuery和Lambda表达式的特性。让我解释它的各个部分：

1. `ApUser dbUser`：这是声明一个变量，用于存储查询结果。`ApUser` 是变量的类型，通常是一个实体类，用于表示数据库表中的记录。`dbUser` 是变量名。

2. `getOne`：这是MyBatis-Plus中的一个查询方法，用于查询数据库表中的记录。`getOne` 方法会返回一个符合条件的记录，如果没有符合条件的记录，它会返回`null`。

3. `Wrappers.<ApUser>lambdaQuery()`：这部分创建了一个LambdaQuery对象，用于构建查询条件。`lambdaQuery()` 是MyBatis-Plus中的方法，它返回一个LambdaQueryWrapper对象，可以用来构建查询条件。

4. `eq(ApUser::getPhone, dto.getPhone())`：这是Lambda表达式的一部分，用于指定查询条件。`eq` 表示等于，它会将表字段 `ApUser` 的 `phone` 字段与 `dto` 对象的 `getPhone()` 方法的返回值进行比较。这个部分用于指定查询条件，即查找 `ApUser` 表中 `phone` 字段等于 `dto` 对象的 `phone` 属性的记录。

这种写法使用了MyBatis-Plus的LambdaQueryWrapper，它具有以下特点：

- 更具可读性：使用Lambda表达式构建查询条件可以使代码更加清晰和可读。
- 防止拼接SQL注入：LambdaQueryWrapper可以防止SQL注入攻击，因为它会根据Lambda表达式构建安全的SQL查询语句。

LambdaQueryWrapper 是 MyBatis-Plus 的一个特性，用于简化 SQL 查询条件的构建，提高代码的可维护性。相比传统的写法，它可以更清晰地表示查询条件，减少了手动编写SQL的需要。



![image-20231024004345276](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310240043459.png)

在微服务启动时会自定启动这个文件下的配置





![image-20231024005328077](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310240053218.png)

### app端网关

![image-20231024010250301](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310240102445.png)

![image-20231024010330270](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310240103319.png)

### 网关过滤器校验JWT

![image-20231026223853357](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310262238413.png)

过滤器在前，会拦截所有资源；拦截器在后，指挥拦截spring环境中的资源



return response.setComplete(); 这段代码什么意思

这段代码看起来是Java Spring Framework中使用的代码片段，通常用于处理Web请求的响应。具体解释如下：

1. `response`：通常是一个表示HTTP响应的对象，可能是`ServerHttpResponse`或类似的对象。

2. `setComplete()`：这是一个方法调用，通常表示将响应标记为已完成。在处理Web请求时，通常需要在处理完请求后，使用这个方法来标记响应的完成状态。

3. `return`：这是一个Java方法中的返回语句，用于将方法的执行结果返回给调用者。

因此，这段代码的含义是将HTTP响应标记为已完成，并将控制权返回给调用者。这通常用于告诉框架已经完成了对请求的处理，并且响应已经准备好发送给客户端。



```
request.getURI().getPath().contains("/login")
```

那getPath是获取哪一段

`getPath()` 方法用于获取 URI（Uniform Resource Identifier）的路径部分。在 URL 中，路径部分通常是主机名之后的部分，包括斜杠 ("/") 分隔的各个段。例如，在以下 URL 中：

```
https://www.example.com/products/electronics/laptops
```

路径部分是 `/products/electronics/laptops`。`getPath()` 方法将返回这个路径字符串。

### app前端项目集成

![image-20231026233907811](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310262339945.png)

![image-20231026233931216](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310262339268.png)、

![image-20231027001039321](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310270010426.png)

```java
upstream  heima-app-gateway{
    server localhost:51601;
}
```

这个中upstream是什么意思
这段配置代码是一个Nginx配置文件的一部分，它定义了一个名为 "heima-app-gateway" 的上游服务器（upstream）。在这个上下文中，"upstream" 的作用是定义一组后端服务器或服务，Nginx 可以将来自客户端的请求代理到这组后端服务器上。在你的配置中，上游服务器 "heima-app-gateway" 定义如下：

```nginx
upstream heima-app-gateway {
    server localhost:51601;
}
```

这表示 "heima-app-gateway" 是一个包含一个后端服务器的上游组，后端服务器的地址是 `localhost:51601`。这通常用于负载均衡，其中多个后端服务器可以共同处理请求，以提高可用性和性能。

当客户端发送请求到Nginx服务器时，Nginx可以使用这个上游定义来将请求代理到后端服务器，实际的代理过程在配置文件中的 `location ~/app/(.*)` 部分有定义。在这里，任何匹配 `/app/` 路径的请求都会被代理到 "heima-app-gateway" 上游服务器组，其中的 `/app/` 部分会传递给后端服务器作为路径的一部分。这种配置允许你将请求转发到后端服务器，以便执行相应的操作，例如处理特定的应用程序请求。





```java
upstream  heima-app-gateway{
    server localhost:51601;
}

server {
	listen 8801;
	location / {
		root D:/workspace/app-web/;
		index index.html;
	}
	
	location ~/app/(.*) {
		proxy_pass http://heima-app-gateway/$1;
		proxy_set_header HOST $host;  # 不改变源请求头的值
		proxy_pass_request_body on;  #开启获取请求体
		proxy_pass_request_headers on;  #开启获取请求头
		proxy_set_header X-Real-IP $remote_addr;   # 记录真实发出请求的客户端IP
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  #记录代理信息
	}
}
```

$1是什么意思

在 Nginx 配置文件中，`$1` 表示正则表达式捕获组的引用。正则表达式捕获组用于从请求 URI 中提取特定部分并在后续配置中使用。在你的配置中，`location ~/app/(.*)` 匹配以 "/app/" 开头的请求 URI，同时 `(.*)` 是一个正则表达式捕获组，用于捕获路径中 "/app/" 后的任何字符序列。

当请求与这个 `location` 匹配时，捕获组中的内容（也就是匹配的路径部分）可以在 `proxy_pass` 指令中使用。具体来说，`proxy_pass http://heima-app-gateway/$1;` 这行中的 `$1` 引用了捕获组中的内容，将捕获到的路径部分作为变量传递给代理目标，从而将请求代理到正确的后端服务器。这是一种将请求路径传递给后端服务器的方法，以便后端服务器能够正确处理请求。



这是一个典型的 Nginx 配置，它包含两个 `location` 指令，用于处理不同的请求路径或 URL 路由。以下是它们之间的关系：

1. `location /`：
   - 这个 `location` 指令匹配根路径 ("/") 或任何没有被其他 `location` 块匹配的请求。
   - `root D:/workspace/app-web/;` 指定了根目录，用于查找静态文件。如果请求路径匹配根 ("/")，则 Nginx 将在 `D:/workspace/app-web/` 目录中查找相应的文件。
   - `index index.html;` 指定了默认的索引文件，如果请求的路径是一个目录，Nginx 尝试查找 `index.html` 文件并返回给客户端。

2. `location ~/app/(.*)`：
   - 这个 `location` 指令使用正则表达式匹配任何以 "/app/" 开头的请求路径，并捕获路径后的所有字符。
   - `proxy_pass http://heima-app-gateway/$1;` 将请求代理到名为 "heima-app-gateway" 的上游服务器组，并附加捕获组中的内容作为路径的一部分。
   - `proxy_set_header` 指令用于设置代理请求的头信息，以便在代理请求时传递一些额外的信息，例如客户端的真实 IP 地址。

这两个 `location` 块共同构成了请求路由的一部分。如果请求的路径匹配根路径 ("/")，Nginx会处理静态文件。如果请求路径以 "/app/" 开头，Nginx会将请求代理到 "heima-app-gateway" 上游服务器组，并传递请求的路径作为参数。这使得 Nginx 可以同时处理静态资源和代理动态请求，根据路径的不同进行不同的处理。



访问该接口会跳转到哪里

根据你提供的 Nginx 配置，当你访问这个接口（端口 `8801`）时，会根据请求路径的不同进行不同的处理：

1. 如果你访问的路径是根路径 `/`，Nginx会在 `D:/workspace/app-web/` 目录中查找默认的索引文件 `index.html` 并返回它。这意味着你将会看到 `D:/workspace/app-web/` 目录中的 `index.html` 页面。

2. 如果你访问的路径以 `/app/` 开头，Nginx会代理请求到名为 "heima-app-gateway" 的上游服务器组，并附加捕获组中的内容作为路径的一部分。具体的目标路径取决于上游服务器的配置。这通常用于将请求转发到后端应用程序或服务，以便后端应用程序可以处理它。

所以，具体跳转到哪里取决于你的请求路径和 Nginx 配置中的不同 `location` 块。如果你访问根路径，将返回静态文件。如果你访问 `/app/` 开头的路径，请求将被代理到后端服务器组。

## 第二天

### app端文章列表

![image-20231027171737292](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271717441.png)

 IdType.ID_WORKER注解

"IdType.ID_WORKER" 通常与 Java 编程语言相关，常常与 MyBatis 框架，尤其是 MyBatis-Plus 库有关。这个库通常用于简化数据库访问并提高生产效率的 Java 应用程序中。

在 MyBatis-Plus 中，"IdType" 是一个枚举，表示用于生成数据库记录的主键值的不同策略。"ID_WORKER" 是该枚举中的一个选项。它表示使用基于工作节点的算法来生成主键，通常使用当前时间戳、机器 ID 和序列号的组合。

这是一个用于生成数据库主键的策略，确保每个主键值都是唯一的。这对于数据库表中的记录标识非常重要。

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271732974.png)

![image-20231027173336960](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271733047.png)

![image-20231027174759830](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271747982.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271750625.png)

![image-20231027175147442](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271751503.png)

报503的是端口冲突，用cmd打开输入netstat -ano|findstr "51802"然后在任务管理器里面找到对应的PID结束任务再重启服务就可以了

![image-20231028141744004](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310281417277.png)

### 文章详情

![image-20231028142245149](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310281422222.png)

![image-20231028142420799](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310281424854.png)

![image-20231028142907101](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310281429163.png)

### freemarker概述

![image-20231028215617966](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282156120.png)

![image-20231028215849390](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282158465.png)

### 环境搭建&快速入门

![image-20231028215957893](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282159009.png)

spring-boot-starter-test与junit的关系？

`spring-boot-starter-test` 是 Spring Boot 框架提供的一个模块，它用于支持在 Spring Boot 应用程序中进行单元测试和集成测试。其中，`spring-boot-starter-test` 包含了许多用于测试 Spring Boot 应用程序的依赖项，其中包括 JUnit。

JUnit 是一个广泛用于 Java 应用程序的单元测试框架，它用于编写和执行单元测试用例。Spring Boot 通过 `spring-boot-starter-test` 模块将 JUnit 以及其他一些常用的测试框架和库集成到 Spring Boot 项目中。这意味着，当你创建一个 Spring Boot 项目并包含 `spring-boot-starter-test` 作为依赖项时，你可以方便地编写和运行基于 JUnit 的单元测试和集成测试。

通过使用 `spring-boot-starter-test`，你可以利用 Spring Boot 提供的自动配置和测试支持，使测试变得更容易。此模块还提供了许多实用的功能，例如内存数据库的自动配置、Spring MVC 测试支持、Mock 对象的创建等，这些都有助于更轻松地编写有效的测试用例。

总之，`spring-boot-starter-test` 是 Spring Boot 用于支持测试的一个重要模块，而 JUnit 则是其中一个核心的测试框架，它们共同使得在 Spring Boot 应用程序中进行测试变得更加方便和高效。



导入spring-boot-starter-test依赖以后是不是就不需要junit依赖了？

导入`spring-boot-starter-test`依赖后，你通常不需要显式添加JUnit依赖，因为`spring-boot-starter-test`已经包含了JUnit作为其中的一部分。Spring Boot将JUnit的依赖引入到项目中，以确保你可以在Spring Boot应用程序中编写并运行测试用例。

如果你查看`spring-boot-starter-test`的依赖，你会发现JUnit作为其中的一项传递性依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <!-- Other dependencies -->
</dependency>
```

因此，通常情况下，只需导入`spring-boot-starter-test`作为依赖项，就足以开始编写和运行基于JUnit的测试用例，而无需单独添加JUnit依赖。这是Spring Boot为了方便测试而提供的便捷功能之一。但是，如果你需要使用特定版本的JUnit或其他自定义配置，仍然可以显式添加JUnit依赖，但这通常是不必要的。

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282206506.png)

![image-20231028221134507](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282211579.png)

![image-20231028221358906](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282213985.png)

总结：为什么SpringBoot能够识别前端文件？

因为这是SpringBoot的自动配置，

![image-20231028232524348](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282325410.png)

![image-20231028232450725](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282324862.png)

![image-20231028232608095](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282326153.png)

### Freemarker指令语法

![image-20231028235921582](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282359675.png)

![image-20231029000055154](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290000231.png)

![image-20231029001128439](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290011564.png)

ctrl+f9：进行重新编译

![image-20231029002431399](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290024490.png)

![image-20231029002453197](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290024259.png)

![image-20231029002746140](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290027221.png)

![image-20231029002838515](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290028590.png)

![image-20231029002849504](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290028565.png)

![image-20231029005407125](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290054175.png)

![image-20231029005808631](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290058703.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290102455.png)

![image-20231029011047570](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290110703.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290114594.png)

![image-20231029011539481](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290115545.png)

![image-20231029011751715](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290117755.png)

![image-20231029011814164](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290118236.png)

### MinIO

![image-20231029113607541](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291136793.png)

![image-20231029113836255](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291138336.png)

![image-20231029113845957](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291138016.png)

#### 开箱使用

![image-20231029114027900](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291140980.png)

![image-20231029120225858](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291202947.png)

```java
docker run -d \-p 9000:9000 \-p 9001:9001 \--name minio1 \-v /home/minio/data:/data \-e "MINIO_ROOT_USER=minio" \-e "MINIO_ROOT_PASSWORD=minio123" \minio/minio server /data --console-address ":9001"
```

![image-20231029120513314](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291205374.png)

#### 快速入门

![image-20231029120532186](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291205276.png)

![image-20231029161506314](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291615465.png)

#### 封装MinIO为starter

![image-20231029165649888](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291656964.png)

![image-20231029165659687](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291656747.png)

ConfigurationProperties注解

![image-20231029194057529](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291940822.png)

![image-20231029194115108](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291941158.png)

![image-20231029194132264](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291941307.png)

@EnableConfigurationProperties注解

![image-20231029194338926](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291943975.png)

@ConditionalOnClass注解

![image-20231029194556295](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291945369.png)

### 静态页面生成上传到minio

![image-20231029195139429](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291951567.png)

![image-20231029195255517](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291952609.png)

![image-20231029214451752](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310292144944.png)

就是一个大文本的解决方案，相当于带格式入库了，用freemarker还原下格式，再通过minio输出出来，剩下的交给前端

### 第三天

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311010925699.png)

#### 自媒体-前后端项目搭建

![image-20231101092724243](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311010927336.png)

nacos配置可快速在服务中生效，做到在线及时灵活控制服务参数的作用，如：将数据库连接源中需要频繁调整的配置放在nacos中配置，我们可以修改相关配置项来灵活调配大数据量交互时数据源的瓶颈问题。

![image-20231101100957907](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011009030.png)

#### 素材管理

![image-20231101103048244](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011030396.png)
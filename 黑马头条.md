## 黑马头条

![image-20231018214343077](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182143233.png)

![image-20231018214354268](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182143331.png)

![image-20231018214428008](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182144045.png)

![image-20231018215324065](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182153145.png)

## 项目介绍

![image-20231018215543479](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182155547.png)

![image-20231018220741420](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182207485.png)

![image-20231018220817072](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182208156.png)

![image-20231018220914706](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182209780.png)

![image-20231018221137006](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182211055.png)

![image-20231018221205989](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182212046.png)

### nacos

![image-20231018232618328](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182326383.png)

![image-20231018233146703](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182331790.png)

### 工程结构介绍

![image-20231018234022824](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182340943.png)

![image-20231018234924080](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182349134.png)

### 登录

![image-20231018235033478](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182350530.png)

![image-20231018235502150](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182355192.png)

![image-20231018235613662](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310182356721.png)

![image-20231019001049196](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190010248.png)

![image-20231019001504805](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190015842.png)

不加盐会导致密码相同的用户，md5生成的密码也是一样的。加了盐(随机的，每个人不同)就可以保证两个人的密码相同，但是md5生成的密码不同

EnableDiscoveryClient注解

`@EnableDiscoveryClient`是Spring Boot应用程序中的一个注解，用于启用与服务发现平台（如Netflix Eureka、Apache ZooKeeper、Consul或其他类似系统）的服务发现和注册。服务发现是构建基于微服务的应用程序的重要组成部分。

以下是如何在Spring Boot应用程序中使用`@EnableDiscoveryClient`注解的方法：

1. **添加依赖项**：您需要在项目中包含适当的依赖项，以便与计划使用的服务发现平台一起工作。例如，如果您使用Netflix Eureka，应在`pom.xml`（如果使用Maven）或`build.gradle`（如果使用Gradle）中包含`spring-cloud-starter-netflix-eureka-client`依赖项。

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

2. **为应用程序添加注解**：在Spring Boot应用程序的主类上添加`@EnableDiscoveryClient`注解，以启用服务发现功能。以下是一个示例：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class YourApplication {
    public static void main(String[] args) {
        SpringApplication.run(YourApplication.class, args);
    }
}
```

通过在应用程序的主类上添加`@EnableDiscoveryClient`注解，您告诉Spring Boot应用程序使用服务发现功能，并注册自己以便其他服务可以发现和与之通信。这对于构建具有多个微服务的应用程序非常有用。

![image-20231019003546514](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190035678.png)

![image-20231019003629915](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190036976.png)

### 接口定义

![image-20231019003741875](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310190037947.png)

StringUtils中isEmpty与isBlank的区别

在Apache Commons Lang库的StringUtils类中，有两个常用的方法，分别是isEmpty和isBlank，它们用于判断字符串是否为空或者是否为空白。这两个方法的区别如下：

1. isEmpty:
   - `StringUtils.isEmpty` 方法用于检查字符串是否为`null`或者长度为0的空字符串。
   - 如果字符串为`null`，或者长度为0，那么这个方法返回`true`。
   - 但是，如果字符串中只包含空格字符（whitespace），那么该方法仍然会返回`false`，即它不会把只包含空格字符的字符串视为非空。

示例：

```java
String str1 = null;
String str2 = "";
String str3 = " ";
String str4 = "Hello, World";

StringUtils.isEmpty(str1);  // true
StringUtils.isEmpty(str2);  // true
StringUtils.isEmpty(str3);  // false
StringUtils.isEmpty(str4);  // false
```

2. isBlank:
   - `StringUtils.isBlank` 方法用于检查字符串是否为空，或者是否只包含空格字符（whitespace）。
   - 如果字符串为`null`、长度为0，或者只包含空格字符，那么该方法返回`true`。
   - 这个方法在判断字符串是否为空白时更严格，因为它会把只包含空格字符的字符串也视为为空白。

示例：

```java
String str1 = null;
String str2 = "";
String str3 = " ";
String str4 = "Hello, World";

StringUtils.isBlank(str1);  // true
StringUtils.isBlank(str2);  // true
StringUtils.isBlank(str3);  // true
StringUtils.isBlank(str4);  // false
```

总结：isEmpty 主要用于判断字符串是否为空，而 isBlank 用于判断字符串是否为空白。您可以根据具体的需求选择使用哪个方法。如果需要严格判断是否为空白，可以使用 isBlank 方法。



ApUser dbUser = getOne(Wrappers.<ApUser>lambdaQuery().eq(ApUser::getPhone, dto.getPhone())); 这是什么写法，与lambdaquerwraper的区别

这行代码使用了MyBatis-Plus中的`getOne`方法来查询数据库表中的记录，并结合了LambdaQuery和Lambda表达式的特性。让我解释它的各个部分：

1. `ApUser dbUser`：这是声明一个变量，用于存储查询结果。`ApUser` 是变量的类型，通常是一个实体类，用于表示数据库表中的记录。`dbUser` 是变量名。

2. `getOne`：这是MyBatis-Plus中的一个查询方法，用于查询数据库表中的记录。`getOne` 方法会返回一个符合条件的记录，如果没有符合条件的记录，它会返回`null`。

3. `Wrappers.<ApUser>lambdaQuery()`：这部分创建了一个LambdaQuery对象，用于构建查询条件。`lambdaQuery()` 是MyBatis-Plus中的方法，它返回一个LambdaQueryWrapper对象，可以用来构建查询条件。

4. `eq(ApUser::getPhone, dto.getPhone())`：这是Lambda表达式的一部分，用于指定查询条件。`eq` 表示等于，它会将表字段 `ApUser` 的 `phone` 字段与 `dto` 对象的 `getPhone()` 方法的返回值进行比较。这个部分用于指定查询条件，即查找 `ApUser` 表中 `phone` 字段等于 `dto` 对象的 `phone` 属性的记录。

这种写法使用了MyBatis-Plus的LambdaQueryWrapper，它具有以下特点：

- 更具可读性：使用Lambda表达式构建查询条件可以使代码更加清晰和可读。
- 防止拼接SQL注入：LambdaQueryWrapper可以防止SQL注入攻击，因为它会根据Lambda表达式构建安全的SQL查询语句。

LambdaQueryWrapper 是 MyBatis-Plus 的一个特性，用于简化 SQL 查询条件的构建，提高代码的可维护性。相比传统的写法，它可以更清晰地表示查询条件，减少了手动编写SQL的需要。



![image-20231024004345276](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310240043459.png)

在微服务启动时会自定启动这个文件下的配置





![image-20231024005328077](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310240053218.png)

### app端网关

![image-20231024010250301](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310240102445.png)

![image-20231024010330270](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310240103319.png)

### 网关过滤器校验JWT

![image-20231026223853357](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310262238413.png)

过滤器在前，会拦截所有资源；拦截器在后，指挥拦截spring环境中的资源



return response.setComplete(); 这段代码什么意思

这段代码看起来是Java Spring Framework中使用的代码片段，通常用于处理Web请求的响应。具体解释如下：

1. `response`：通常是一个表示HTTP响应的对象，可能是`ServerHttpResponse`或类似的对象。

2. `setComplete()`：这是一个方法调用，通常表示将响应标记为已完成。在处理Web请求时，通常需要在处理完请求后，使用这个方法来标记响应的完成状态。

3. `return`：这是一个Java方法中的返回语句，用于将方法的执行结果返回给调用者。

因此，这段代码的含义是将HTTP响应标记为已完成，并将控制权返回给调用者。这通常用于告诉框架已经完成了对请求的处理，并且响应已经准备好发送给客户端。



```
request.getURI().getPath().contains("/login")
```

那getPath是获取哪一段

`getPath()` 方法用于获取 URI（Uniform Resource Identifier）的路径部分。在 URL 中，路径部分通常是主机名之后的部分，包括斜杠 ("/") 分隔的各个段。例如，在以下 URL 中：

```
https://www.example.com/products/electronics/laptops
```

路径部分是 `/products/electronics/laptops`。`getPath()` 方法将返回这个路径字符串。

### app前端项目集成

![image-20231026233907811](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310262339945.png)

![image-20231026233931216](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310262339268.png)、

![image-20231027001039321](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310270010426.png)

```java
upstream  heima-app-gateway{
    server localhost:51601;
}
```

这个中upstream是什么意思
这段配置代码是一个Nginx配置文件的一部分，它定义了一个名为 "heima-app-gateway" 的上游服务器（upstream）。在这个上下文中，"upstream" 的作用是定义一组后端服务器或服务，Nginx 可以将来自客户端的请求代理到这组后端服务器上。在你的配置中，上游服务器 "heima-app-gateway" 定义如下：

```nginx
upstream heima-app-gateway {
    server localhost:51601;
}
```

这表示 "heima-app-gateway" 是一个包含一个后端服务器的上游组，后端服务器的地址是 `localhost:51601`。这通常用于负载均衡，其中多个后端服务器可以共同处理请求，以提高可用性和性能。

当客户端发送请求到Nginx服务器时，Nginx可以使用这个上游定义来将请求代理到后端服务器，实际的代理过程在配置文件中的 `location ~/app/(.*)` 部分有定义。在这里，任何匹配 `/app/` 路径的请求都会被代理到 "heima-app-gateway" 上游服务器组，其中的 `/app/` 部分会传递给后端服务器作为路径的一部分。这种配置允许你将请求转发到后端服务器，以便执行相应的操作，例如处理特定的应用程序请求。





```java
upstream  heima-app-gateway{
    server localhost:51601;
}

server {
	listen 8801;
	location / {
		root D:/workspace/app-web/;
		index index.html;
	}
	
	location ~/app/(.*) {
		proxy_pass http://heima-app-gateway/$1;
		proxy_set_header HOST $host;  # 不改变源请求头的值
		proxy_pass_request_body on;  #开启获取请求体
		proxy_pass_request_headers on;  #开启获取请求头
		proxy_set_header X-Real-IP $remote_addr;   # 记录真实发出请求的客户端IP
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  #记录代理信息
	}
}
```

$1是什么意思

在 Nginx 配置文件中，`$1` 表示正则表达式捕获组的引用。正则表达式捕获组用于从请求 URI 中提取特定部分并在后续配置中使用。在你的配置中，`location ~/app/(.*)` 匹配以 "/app/" 开头的请求 URI，同时 `(.*)` 是一个正则表达式捕获组，用于捕获路径中 "/app/" 后的任何字符序列。

当请求与这个 `location` 匹配时，捕获组中的内容（也就是匹配的路径部分）可以在 `proxy_pass` 指令中使用。具体来说，`proxy_pass http://heima-app-gateway/$1;` 这行中的 `$1` 引用了捕获组中的内容，将捕获到的路径部分作为变量传递给代理目标，从而将请求代理到正确的后端服务器。这是一种将请求路径传递给后端服务器的方法，以便后端服务器能够正确处理请求。



这是一个典型的 Nginx 配置，它包含两个 `location` 指令，用于处理不同的请求路径或 URL 路由。以下是它们之间的关系：

1. `location /`：
   - 这个 `location` 指令匹配根路径 ("/") 或任何没有被其他 `location` 块匹配的请求。
   - `root D:/workspace/app-web/;` 指定了根目录，用于查找静态文件。如果请求路径匹配根 ("/")，则 Nginx 将在 `D:/workspace/app-web/` 目录中查找相应的文件。
   - `index index.html;` 指定了默认的索引文件，如果请求的路径是一个目录，Nginx 尝试查找 `index.html` 文件并返回给客户端。

2. `location ~/app/(.*)`：
   - 这个 `location` 指令使用正则表达式匹配任何以 "/app/" 开头的请求路径，并捕获路径后的所有字符。
   - `proxy_pass http://heima-app-gateway/$1;` 将请求代理到名为 "heima-app-gateway" 的上游服务器组，并附加捕获组中的内容作为路径的一部分。
   - `proxy_set_header` 指令用于设置代理请求的头信息，以便在代理请求时传递一些额外的信息，例如客户端的真实 IP 地址。

这两个 `location` 块共同构成了请求路由的一部分。如果请求的路径匹配根路径 ("/")，Nginx会处理静态文件。如果请求路径以 "/app/" 开头，Nginx会将请求代理到 "heima-app-gateway" 上游服务器组，并传递请求的路径作为参数。这使得 Nginx 可以同时处理静态资源和代理动态请求，根据路径的不同进行不同的处理。



访问该接口会跳转到哪里

根据你提供的 Nginx 配置，当你访问这个接口（端口 `8801`）时，会根据请求路径的不同进行不同的处理：

1. 如果你访问的路径是根路径 `/`，Nginx会在 `D:/workspace/app-web/` 目录中查找默认的索引文件 `index.html` 并返回它。这意味着你将会看到 `D:/workspace/app-web/` 目录中的 `index.html` 页面。

2. 如果你访问的路径以 `/app/` 开头，Nginx会代理请求到名为 "heima-app-gateway" 的上游服务器组，并附加捕获组中的内容作为路径的一部分。具体的目标路径取决于上游服务器的配置。这通常用于将请求转发到后端应用程序或服务，以便后端应用程序可以处理它。

所以，具体跳转到哪里取决于你的请求路径和 Nginx 配置中的不同 `location` 块。如果你访问根路径，将返回静态文件。如果你访问 `/app/` 开头的路径，请求将被代理到后端服务器组。

## 第二天

### app端文章列表

![image-20231027171737292](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271717441.png)

 IdType.ID_WORKER注解

"IdType.ID_WORKER" 通常与 Java 编程语言相关，常常与 MyBatis 框架，尤其是 MyBatis-Plus 库有关。这个库通常用于简化数据库访问并提高生产效率的 Java 应用程序中。

在 MyBatis-Plus 中，"IdType" 是一个枚举，表示用于生成数据库记录的主键值的不同策略。"ID_WORKER" 是该枚举中的一个选项。它表示使用基于工作节点的算法来生成主键，通常使用当前时间戳、机器 ID 和序列号的组合。

这是一个用于生成数据库主键的策略，确保每个主键值都是唯一的。这对于数据库表中的记录标识非常重要。

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271732974.png)

![image-20231027173336960](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271733047.png)

![image-20231027174759830](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271747982.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271750625.png)

![image-20231027175147442](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310271751503.png)

报503的是端口冲突，用cmd打开输入netstat -ano|findstr "51802"然后在任务管理器里面找到对应的PID结束任务再重启服务就可以了

![image-20231028141744004](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310281417277.png)

### 文章详情

![image-20231028142245149](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310281422222.png)

![image-20231028142420799](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310281424854.png)

![image-20231028142907101](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310281429163.png)

### freemarker概述

![image-20231028215617966](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282156120.png)

![image-20231028215849390](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282158465.png)

### 环境搭建&快速入门

![image-20231028215957893](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282159009.png)

spring-boot-starter-test与junit的关系？

`spring-boot-starter-test` 是 Spring Boot 框架提供的一个模块，它用于支持在 Spring Boot 应用程序中进行单元测试和集成测试。其中，`spring-boot-starter-test` 包含了许多用于测试 Spring Boot 应用程序的依赖项，其中包括 JUnit。

JUnit 是一个广泛用于 Java 应用程序的单元测试框架，它用于编写和执行单元测试用例。Spring Boot 通过 `spring-boot-starter-test` 模块将 JUnit 以及其他一些常用的测试框架和库集成到 Spring Boot 项目中。这意味着，当你创建一个 Spring Boot 项目并包含 `spring-boot-starter-test` 作为依赖项时，你可以方便地编写和运行基于 JUnit 的单元测试和集成测试。

通过使用 `spring-boot-starter-test`，你可以利用 Spring Boot 提供的自动配置和测试支持，使测试变得更容易。此模块还提供了许多实用的功能，例如内存数据库的自动配置、Spring MVC 测试支持、Mock 对象的创建等，这些都有助于更轻松地编写有效的测试用例。

总之，`spring-boot-starter-test` 是 Spring Boot 用于支持测试的一个重要模块，而 JUnit 则是其中一个核心的测试框架，它们共同使得在 Spring Boot 应用程序中进行测试变得更加方便和高效。



导入spring-boot-starter-test依赖以后是不是就不需要junit依赖了？

导入`spring-boot-starter-test`依赖后，你通常不需要显式添加JUnit依赖，因为`spring-boot-starter-test`已经包含了JUnit作为其中的一部分。Spring Boot将JUnit的依赖引入到项目中，以确保你可以在Spring Boot应用程序中编写并运行测试用例。

如果你查看`spring-boot-starter-test`的依赖，你会发现JUnit作为其中的一项传递性依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <!-- Other dependencies -->
</dependency>
```

因此，通常情况下，只需导入`spring-boot-starter-test`作为依赖项，就足以开始编写和运行基于JUnit的测试用例，而无需单独添加JUnit依赖。这是Spring Boot为了方便测试而提供的便捷功能之一。但是，如果你需要使用特定版本的JUnit或其他自定义配置，仍然可以显式添加JUnit依赖，但这通常是不必要的。

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282206506.png)

![image-20231028221134507](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282211579.png)

![image-20231028221358906](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282213985.png)

总结：为什么SpringBoot能够识别前端文件？

因为这是SpringBoot的自动配置，

![image-20231028232524348](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282325410.png)

![image-20231028232450725](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282324862.png)

![image-20231028232608095](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282326153.png)

### Freemarker指令语法

![image-20231028235921582](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310282359675.png)

![image-20231029000055154](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290000231.png)

![image-20231029001128439](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290011564.png)

ctrl+f9：进行重新编译

![image-20231029002431399](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290024490.png)

![image-20231029002453197](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290024259.png)

![image-20231029002746140](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290027221.png)

![image-20231029002838515](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290028590.png)

![image-20231029002849504](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290028565.png)

![image-20231029005407125](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290054175.png)

![image-20231029005808631](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290058703.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290102455.png)

![image-20231029011047570](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290110703.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290114594.png)

![image-20231029011539481](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290115545.png)

![image-20231029011751715](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290117755.png)

![image-20231029011814164](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310290118236.png)

### MinIO

![image-20231029113607541](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291136793.png)

![image-20231029113836255](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291138336.png)

![image-20231029113845957](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291138016.png)

#### 开箱使用

![image-20231029114027900](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291140980.png)

![image-20231029120225858](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291202947.png)

```java
docker run -d \-p 9000:9000 \-p 9001:9001 \--name minio1 \-v /home/minio/data:/data \-e "MINIO_ROOT_USER=minio" \-e "MINIO_ROOT_PASSWORD=minio123" \minio/minio server /data --console-address ":9001"
```

![image-20231029120513314](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291205374.png)

#### 快速入门

![image-20231029120532186](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291205276.png)

![image-20231029161506314](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291615465.png)

#### 封装MinIO为starter

![image-20231029165649888](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291656964.png)

![image-20231029165659687](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291656747.png)

ConfigurationProperties注解

![image-20231029194057529](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291940822.png)

![image-20231029194115108](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291941158.png)

![image-20231029194132264](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291941307.png)

@EnableConfigurationProperties注解

![image-20231029194338926](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291943975.png)

@ConditionalOnClass注解

![image-20231029194556295](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291945369.png)

### 静态页面生成上传到minio

![image-20231029195139429](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291951567.png)

![image-20231029195255517](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310291952609.png)

![image-20231029214451752](https://cdn.jsdelivr.net/gh/yzk656/image/img/202310292144944.png)

就是一个大文本的解决方案，相当于带格式入库了，用freemarker还原下格式，再通过minio输出出来，剩下的交给前端

## 第三天

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311010925699.png)

### 自媒体-前后端项目搭建 

![image-20231101092724243](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311010927336.png)

nacos配置可快速在服务中生效，做到在线及时灵活控制服务参数的作用，如：将数据库连接源中需要频繁调整的配置放在nacos中配置，我们可以修改相关配置项来灵活调配大数据量交互时数据源的瓶颈问题。

![image-20231101100957907](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011009030.png)

### 素材管理

![image-20231101103048244](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011030396.png)

![image-20231101112604756](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011126916.png)

![image-20231101123532925](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011235071.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011239415.png)

![image-20231101130135627](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011301779.png)

### 素材列表查询

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011500397.png)

![image-20231101151640881](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011516947.png)

### 自媒体文章查询

![image-20231101172659636](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011726800.png)

![image-20231101180151180](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311011801349.png)

![image-20231101224727450](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311012247607.png)

![image-20231101224759450](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311012247503.png)

### 自媒体文章发布、修改、保存草稿

![image-20231102010619631](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311020106755.png)

![image-20231102020853765](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311020208916.png)

![image-20231102020924269](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311020209320.png)

![image-20231102021125391](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311020211494.png)

mybatisplus并不能实现批量保存，因此要使用到xml文件

多张表一起查询要用mapper，mybatisplus只支持单表的操作

我觉得应该是多个表一起查询，mybatisplus还没多表查询的方法，就是说难的方法还是需要自己写sql



在使用mybatisplus时，在使用mapper的delete和使用service中的delete的区别？

在使用MyBatis-Plus（简称MP）时，你可以通过Mapper接口或者Service接口来执行删除操作。这两种方式都可以用来删除数据库中的记录，但在使用上有一些区别。

1. **使用Mapper的delete方法：**
   MyBatis-Plus的Mapper接口提供了一系列的CRUD方法，包括delete、update、insert等。使用Mapper的delete方法，你可以直接在DAO层中定义方法，并传入相应的参数，如实体对象或者条件构造器，来执行删除操作。这种方式通常用于在DAO层进行简单的数据操作。

   示例代码：
   ```java
   // 在Mapper接口中定义删除方法
   int deleteById(Long id);
   ```

2. **使用Service中的delete方法：**
   在Service层，你可以定义更加复杂的业务逻辑，包括多个数据操作的组合，事务管理等。Service层通常用来处理业务逻辑，而不是简单的数据操作。当你在Service中定义delete方法时，通常会包含一些业务规则的判断和数据处理逻辑，然后再调用Mapper的delete方法来执行实际的删除操作。这种方式可以保持Service层的业务逻辑清晰，同时也可以方便进行事务管理。

   示例代码：
   ```java
   @Service
   public class UserService {
       @Autowired
       private UserMapper userMapper;
   
       @Transactional
       public void deleteUserById(Long id) {
           // 根据业务规则进行判断，比如权限校验等
           // ...
   
           // 执行删除操作
           userMapper.deleteById(id);
       }
   }
   ```

总的来说，使用Mapper的delete方法适合简单的数据删除操作，而在Service中定义delete方法可以更好地将业务逻辑和数据操作分离，提高代码的可维护性和可测试性。在Service中可以组合多个数据操作，处理复杂的业务需求，同时使用事务管理来保证数据操作的一致性。





![image-20231102163633165](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311021636322.png)

这里wmNews可能是新增文章，所以说，saveMaterialInfoContent(materals,wmNews.getId());中的 wmNews.getId()可能为空吧？为什么可以这样写？是因为在WmNews wmNews = new WmNews();就会自动填充id吗？

在上面的代码中，`wmNews` 对象的 `id` 字段在 `WmNews wmNews = new WmNews();` 创建之后，没有手动设置 `id` 的值，因为通常情况下，数据库中的主键（比如自增主键）会在插入记录时由数据库自动生成。这是常见的数据库设计模式。

在 MyBatis-Plus 中，如果你使用 `save` 方法来插入新记录，它会在插入后返回生成的主键值，并将这个值设置到实体对象的 `id` 字段上。这是因为 MyBatis-Plus 会自动处理数据库自增主键的生成，然后将生成的主键值返回给你。

因此，在 `saveOrUpdateWmNews` 方法中，当 `wmNews` 是一个新的文章（没有指定 `id` 值），在调用 `save` 方法后，`wmNews` 对象的 `id` 字段会被自动设置为数据库生成的主键值。这个值会被用于后续的操作，包括删除与素材的关系等。所以，在 `saveMaterialInfoContent` 方法中可以使用 `wmNews.getId()` 获取到正确的 `id` 值。

这种方式适用于自增主键的数据库表，但如果数据库表的主键生成策略不是自增，那么在插入记录后，你可能需要手动设置 `id` 值，或者根据数据库返回的主键值来进行后续操作。



## 第四天

![image-20231103150958657](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031509811.png)

![image-20231103151032711](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031510782.png)

### 自媒体文章自动审核流程

![image-20231103151149284](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031511328.png)

![image-20231103151552594](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031515666.png)

### 内容安全第三方接口

![image-20231103151657643](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031516718.png)

![image-20231103151838103](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031518191.png)

![image-20231103152037575](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031520638.png)

![image-20231103152049998](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031520072.png)

![image-20231103152335027](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031523092.png)

![image-20231103152620309](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311031526365.png)

如果一个模块只有spring.factories文件，但是没有Application入口类，那么这个模块又该如何启动呢？

如果一个模块只包含 `spring.factories` 文件而没有明确的 `Application` 入口类，它通常不会作为独立的应用程序启动。`spring.factories` 文件通常用于自动配置和扩展 Spring 应用程序，但它本身不会触发整个应用程序的启动。

通常情况下，你需要将这样的模块作为依赖添加到另一个拥有 `Application` 入口类的模块中。这个包含 `Application` 类的模块会充当整个应用程序的启动点，而它会自动加载 `spring.factories` 中定义的自动配置。

所以，要让一个只包含 `spring.factories` 文件的模块生效，你需要在另一个模块的 `Application` 类中引入它作为依赖。通常，这可以通过 Maven 或 Gradle 之类的构建工具来完成，将模块添加为依赖，并确保它在类路径中。

在 Maven 中，你可以在 `pom.xml` 中添加依赖，如下所示：

```xml
<dependency>
    <groupId>your-group-id</groupId>
    <artifactId>your-module-name</artifactId>
    <version>your-module-version</version>
</dependency>
```

在 Gradle 中，你可以在 `build.gradle` 文件中添加依赖，如下所示：

```groovy
dependencies {
    implementation 'your-group-id:your-module-name:your-module-version'
}
```

一旦你将这个模块添加为依赖，它的 `spring.factories` 中定义的自动配置将被包含在应用程序中并生效，即使没有明确的 `Application` 入口类。这种模块化的设计允许你构建更具扩展性和可重用性的应用程序。





那为什么还要在spring.factories指明要加载的类呢？在到另一个拥有 Application 入口类的模块启动时不能自动加载配置类吗？

`spring.factories` 文件的目的是允许模块在 Spring Boot 应用程序启动时自动加载它们的配置类，而不需要明确引入或配置这些类。它提供了自动配置的机制，使得模块可以通过依赖关系被自动集成到应用程序中。这种自动加载的方式可以大大减少配置的复杂性和提高代码的可维护性。

在 Spring Boot 应用程序启动时，Spring Boot 会扫描类路径中的 `spring.factories` 文件，并根据其中定义的配置，自动加载与应用程序相关的配置类。这种自动加载的方式有助于模块化开发和将功能模块分割成可重用的部分。

如果你希望一个拥有 `Application` 入口类的模块能够自动加载其他模块中的配置类，通常需要明确指定要加载哪些配置类，以确保它们被正确集成到应用程序中。这是因为 Spring Boot 不会自动扫描所有依赖模块中的配置类，因为这可能导致意外的行为和性能问题。

所以，`spring.factories` 的目的是提供一种明确的方式来定义要加载的配置类，以确保应用程序的行为是可控的和可预测的。如果你不想明确指定，Spring Boot 不会自动加载依赖模块中的所有配置类，而是要求开发者明确指定要加载的内容，以确保应用程序的稳定性。这是 Spring Boot 框架的一种设计决策，以提供更多的控制权和可维护性。



### 雪花算法

![image-20231105211528668](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311052115884.png)

![image-20231105211644107](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311052116196.png)

### 文章保存

![image-20231106100937691](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311061009820.png)

![image-20231106101136205](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311061011282.png)

![image-20231106211908009](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311062119304.png)

### Feign调用服务降级实现

![image-20231107121351670](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311071213008.png)

![image-20231107122135459](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311071221734.png)

### 自管理敏感词过滤

![image-20231108155848917](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311081558958.png)

![image-20231108155843155](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311081558304.png)

![image-20231108162902459](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311081629671.png)

![image-20231108172725430](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311081727685.png)

### 图片文字识别

![image-20231108182955367](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311081829506.png)

![image-20231108183837835](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311081838984.png)

![image-20231108183905943](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311081839989.png)

![image-20231108223125348](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311082231569.png)

![image-20231108230403835](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311082304017.png)

### 静态文件生成

![image-20231109021725088](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311090217257.png)

### 作业

![image-20231109030323060](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311090303182.png)

![image-20231109030343082](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311090303133.png)

## 第五天

![image-20231115033918014](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311150339117.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311150402776.png)

![image-20231115040228489](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311150402602.png)

![image-20231115183213069](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311151832227.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311151834712.png)

![image-20231115183518177](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311151835231.png)

### Redis实现延迟任务

![image-20231115183959526](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311151839638.png)

redis是单线程且Zset不可重复，谁能在同一毫秒点击发送请求，还要考虑网络阻塞和传输时间。

![image-20231115184126650](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311151841699.png)

![image-20231115184300957](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311151843039.png)

![image-20231115184321824](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311151843880.png)

### 延迟任务模块创建及数据库准备

![image-20231115221058412](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311152210509.png)

![image-20231115221112371](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311152211464.png)

![image-20231116002203326](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311160022506.png)

![image-20231116002319743](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311160023787.png)

### 乐观锁集成

![image-20231116002806452](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311160028706.png)

![image-20231116002945097](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311160029188.png)

![image-20231116003005544](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311160030607.png)

### redis的集成与测试

![image-20231116003226605](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311160032736.png)

![image-20231116003435392](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311160034482.png)

![image-20231116010429139](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311160104289.png)

![image-20231116074715965](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311160747127.png)

超过五分钟就在数据库中，不保存在redis中

```js
   public long addTask(Task task) {

        //添加任务到数据库中
        boolean flag = addTaskToDb(task);

        //添加任务到redis中
        if (flag) {
            addTaskToCache(task);
        }


        return task.getTaskId();
    }
    private boolean addTaskToDb(Task task) {

        Boolean flag = true;

        try {
            //保存任务表
            Taskinfo taskinfo = new Taskinfo();
            BeanUtils.copyProperties(task, taskinfo);
            taskinfo.setExecuteTime(new Date(task.getExecuteTime()));
            taskinfoMapper.insert(taskinfo);

            //设置taskID
            task.setTaskId(taskinfo.getTaskId());

            //保存任务日志数据
            TaskinfoLogs taskinfoLogs = new TaskinfoLogs();
            BeanUtils.copyProperties(taskinfo, taskinfoLogs);
            taskinfoLogs.setVersion(ScheduleConstants.SCHEDULED);
            taskinfoLogsMapper.insert(taskinfoLogs);
        } catch (Exception e) {
            e.printStackTrace();
            flag = false;
        }

        return flag;
    }
这两个方法，参数是task，为什么addTaskToDb中修改参数的值同样也会修改addTask中task的值
```

在Java中，当你将一个对象作为参数传递给一个方法时，实际上是传递了对该对象的引用。因此，在方法内部对对象进行的更改会影响到方法外部的原始对象。这是因为对对象的引用在调用方法和被调用方法之间是共享的。

在你的情况下：

1. `addTask` 方法接收一个 `Task` 对象作为参数。
2. 在 `addTask` 方法内部，使用相同的 `Task` 对象作为参数调用了 `addTaskToDb` 方法。
3. 在 `addTaskToDb` 方法内部，你修改了 `Task` 对象：

```java
task.setTaskId(taskinfo.getTaskId());
```

这个修改会影响到传递给 `addTask` 方法的原始 `Task` 对象，因为这两个方法都使用了相同的 `Task` 对象引用。

如果你想避免修改原始的 `Task` 对象，可以在进行更改之前创建对象的副本。例如，你可以使用 `clone` 方法或手动创建一个新的 `Task` 对象，并手动复制属性。这样，在方法内部进行的更改就不会影响到原始对象。

以下是使用手动复制的示例：

```java
private boolean addTaskToDb(Task originalTask) {
    Boolean flag = true;

    try {
        // 创建一个新的 Task 对象，并从 originalTask 复制属性
        Task task = new Task();
        BeanUtils.copyProperties(originalTask, task);

        // 保存到数据库
        Taskinfo taskinfo = new Taskinfo();
        BeanUtils.copyProperties(task, taskinfo);
        taskinfo.setExecuteTime(new Date(task.getExecuteTime()));
        taskinfoMapper.insert(taskinfo);

        // 在新的 Task 对象中设置 taskID
        task.setTaskId(taskinfo.getTaskId());

        // 保存任务日志数据
        TaskinfoLogs taskinfoLogs = new TaskinfoLogs();
        BeanUtils.copyProperties(taskinfo, taskinfoLogs);
        taskinfoLogs.setVersion(ScheduleConstants.SCHEDULED);
        taskinfoLogsMapper.insert(taskinfoLogs);
    } catch (Exception e) {
        e.printStackTrace();
        flag = false;
    }

    return flag;
}
```

这样，方法内部进行的修改只会影响到方法内的局部 `Task` 对象，不会影响到 `addTask` 方法中的原始 `Task` 对象。

总结：热知识：对象最为参数传递，传递是对象的引用，因此在方法内部对对象的修改会影响方法外部的原始对象

### 取消任务

![image-20231117220128455](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311172201523.png)

### 消费任务

![image-20231118094846826](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311180948977.png)

![image-20231118125917752](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311181259886.png)

### 未来数据定时刷新

![image-20231119150950297](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311191509391.png)

![image-20231119151039233](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311191510316.png)

![image-20231119152254202](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311191522297.png)



![image-20231119152347179](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311191523251.png)

![image-20231119152353846](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311191523911.png)

### 分布式锁解决集群下的方法抢占执行

![image-20231119201417064](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311192014226.png)

![image-20231119201425676](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311192014744.png)

![image-20231119202135832](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311192021911.png)

![image-20231119213326518](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311192133702.png)

添加的是未执行状态数据，添加到redis之后，执行的数据状态改变，下一次删除redis中的数据继续从数据库查询

> 定时任务@Scheduled用法及其参数讲解
>
> ### 1. 基本用法
>
> @[Scheduled](https://so.csdn.net/so/search?q=Scheduled&spm=1001.2101.3001.7020) 由Spring定义，用于将方法设置为调度任务。如：方法每隔十秒钟被执行、方法在固定时间点被执行等
>
> 1. @Scheduled(fixedDelay = 1000)
>    上一个任务结束到下一个任务开始的时间间隔为固定的1秒，任务的执行总是要先等到上一个任务的执行结束
> 2. @Scheduled(fixedRate = 1000)
>    每间隔1秒钟就会执行任务（如果任务执行的时间超过1秒，则下一个任务在上一个任务结束之后立即执行）
> 3. @Scheduled(fixedDelay = 1000, initialDelay = 2000)
>    第一次执行的任务将会延迟2秒钟后才会启动
> 4. @Scheduled(cron = “0 15 10 15 * ?”)
>    [Cron表达式](https://so.csdn.net/so/search?q=Cron表达式&spm=1001.2101.3001.7020)，每个月的15号上午10点15分开始执行任务
> 5. 在配置文件中配置任务调度的参数
>
> ```java
> @Scheduled(fixedDelayString = "fixedDelay.in.milliseconds")
>  
> @Scheduled(fixedRateString="fixedDelay.in.milliseconds")
>  
> @Scheduled(fixedRateString="{fixedRate.in.milliseconds}")
>  
> @Scheduled(cron = "${cron.expression}")
> 1234567
> ```
>
> ### 2. Cron表达式
>
> Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：
>
> （1） Seconds Minutes Hours DayofMonth Month DayofWeek Year
> （2）Seconds Minutes Hours DayofMonth Month DayofWeek
>
> ![属性值讲解](https://img-blog.csdnimg.cn/c63803ffa32e43a5b767b149e8bbdcc7.png)
>
> （1）*：表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。
>
> （2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。
>
> （3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次
>
> （4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次.
>
> （5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。
>
> （6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。
>
> （7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。
>
> （8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。
>
> （9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。
>
> Cron表达式范例：
> 每隔5秒执行一次：*/5 * * * * ?
> 每隔1分钟执行一次：0 */1 * * * ?
> 每天23点执行一次：0 0 23 * * ?
> 每天凌晨1点执行一次：0 0 1 * * ?
> 每月1号凌晨1点执行一次：0 0 1 1 * ?
> 每月最后一天23点执行一次：0 0 23 L * ?
> 每周星期天凌晨1点实行一次：0 0 1 ? * L
>
> ### 3. 线程
>
> spring scheduled默认是所有定时任务都在一个线程中执行。也就是说定时任务1一直在执行，定时任务2一直在等待定时任务1执行完成。为了避免相互等待的情况，可以为定时任务配置线程池
>
> ```java
> @Configuration
> public class ScheduleConfig implements SchedulingConfigurer {
>     @Override
>     public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
>         taskRegistrar.setScheduler(Executors.newScheduledThreadPool(50));
>     }
> }
> 1234567
> ```
>
> 在程序启动后，会逐步启动50个线程，放在线程池中。每个定时任务会占用1个线程。但是相同的定时任务，执行的时候，还是在同一个线程中。
>
> 也可配置异步执行，相同的任务也不会相互影响。
>
> 添加配置：
>
> ```java
> @Configuration
> @EnableAsync
> public class ScheduleConfig {
>  
>     @Bean
>     public TaskScheduler taskScheduler() {
>         ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
>         taskScheduler.setPoolSize(50);
>         return taskScheduler;
>     }
> }
> 1234567891011
> ```
>
> 在方法上添加注解@Async
>
> ```java
> public class TaskFileScheduleService {
>  
>  
>     @Async
>     @Scheduled(cron="0 */1 * * * ?")
>     public void task1(){
>   
>     }
>     
>     @Async
>     @Scheduled(cron="0 */1 * * * ?")
>     public void task2(){
>     
>     }
> }
> 123456789101112131415
> ```
>
> 这种方法，每次定时任务启动的时候，都会创建一个单独的线程来处理。也就是说同一个定时任务也会启动多个线程处理。
>
> 本文章用于个人学习积累，作者原文链接：https://blog.csdn.net/xgw1010/article/details/107379405

@PostConstruct注解

@PostConstruct注解好多人以为是Spring提供的。其实是Java自己的注解。

Java中该注解的说明：@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。

通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：

Constructor(构造方法) -> @Autowired(依赖注入) -> @PostConstruct(注释的方法)

实战：在静态方法中调用依赖注入的Bean中的方法。

**如果想在生成对象时完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么久无法在构造函数中实现。为此，可以使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。**

**@PostConstruct注解的方法将会在依赖注入完成后被自动调用。**

- **因为当调用构造函数时，bean还没有初始化-即没有注入依赖项。在`@PostConstruct`方法完全初始化bean，您可以使用依赖项。**
- **因为这是保证在bean生命周期中只调用一次此方法的契约。一个bean可能会在其内部工作过程中被容器多次实例化(虽然不太可能)，但它保证`@PostConstruct`只会被调用一次。**



FUTURE_TASK_SYNC_lock可能是一个用于同步的锁键，用来确保异步任务只有一个线程或进程在执行，并防止其他线程或进程同时执行相同的异步任务。这样可以保证任务的顺序执行和数据的一致性。

![image-20231120140629472](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311201406661.png)

![image-20231120142422635](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311201424694.png)

![image-20231120143542548](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311201435603.png)

![image-20231120144217323](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311201442382.png)

确实是 每分钟刚开始的时候同步到list中，然后消费任务，并不会严格按照指定的秒数审核发布

## 第六天

![image-20231121114840158](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211148399.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211150103.png)

![image-20231121115039834](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211150967.png)

![image-20231121115047234](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211150347.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211229444.png)

![image-20231121124512569](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211245642.png)
对于云主机就不好使用了，必须使用-p而不是--net了

### kafka入门案例

![image-20231121135057950](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211350074.png)

![image-20231121135259705](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211352800.png)

kafka中的topic是什么

在Apache Kafka中，一个"topic"是消息的逻辑容器或类别，用于组织和分类消息。Kafka是一个分布式流处理平台，它允许应用程序发布和订阅流式数据，而这些数据以消息的形式被发送到topics。每个topic都可以被分为一个或多个分区（partitions）。

以下是一些关键概念：

1. **Producer（生产者）：** 生产者负责将消息发布到一个或多个topic。消息被追加到topic的一个或多个分区中。

2. **Consumer（消费者）：** 消费者订阅一个或多个topic，并从中读取消息。每个消费者属于一个消费者组（consumer group），这样消费者组中的消费者可以共同消费topic中的消息。

3. **Broker：** Kafka集群由多个broker组成，每个broker是一个独立的Kafka服务器。它们协同工作以存储和传输消息。每个broker都可以管理多个topic的分区。

4. **Partition（分区）：** 一个topic可以被分为多个分区，每个分区是一个有序的队列，其中包含了消息。分区可以分布在不同的broker上，这有助于提高并行性和伸缩性。

5. **Offset（偏移量）：** 每个消息在分区中都有一个唯一的标识，称为偏移量。消费者使用偏移量来跟踪已经消费的消息的位置。

通过将消息分成不同的topic和分区，Kafka允许构建高度可伸缩、耐用和分布式的流处理系统。它的设计使得能够有效地处理大量的实时数据。

![image-20231121154951291](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211549446.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211601651.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211922661.png)

![image-20231121192302511](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211923579.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211938930.png)

### 分区机制

![image-20231121193406725](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211934806.png)

kafka中的分区是什么意思，与topic的关系是什么？

在Apache Kafka中，分区（Partition）是一个topic内的消息序列的一个子集。每个分区都是一个有序的、不可变的消息队列，并且每条消息都会被追加到特定的分区。分区的引入带来了一些关键的好处，包括：

1. **并行处理：** 分区允许消息在多个消费者之间并行处理。不同的分区可以分配给不同的消费者，从而提高整个系统的吞吐量。

2. **水平伸缩：** 通过将分区分布在多个broker上，Kafka可以水平扩展，以适应更大的负载。每个broker可以负责处理其中一部分分区的数据。

3. **顺序保证：** 分区中的消息是有序的。这意味着在同一分区内，消息的处理顺序是被保留的。但在不同分区之间，并没有强制的顺序保证。

4. **容错性：** 每个分区都有一份或多份副本（replica）在集群中的其他broker上。这样，如果一个broker故障，其他broker上的副本仍然可用，确保消息的持久性和可靠性。

关于分区与topic的关系：

- **一个topic可以有多个分区：** 当创建一个topic时，你可以指定这个topic有多少个分区。这个数量决定了这个topic的并行处理能力和负载均衡性。

- **一个分区属于一个topic：** 每个分区都属于一个特定的topic。当你向Kafka中的topic发布消息时，消息将会被追加到特定的分区中。

- **分区与消费者组关联：** 消费者组内的每个消费者负责消费一个或多个分区的消息。这确保了每条消息在消费者组内只被一个消费者处理，同时允许并行处理来自不同分区的消息。

总体来说，分区是Kafka中一个重要的概念，它为构建可扩展、高性能的消息处理系统提供了基础。

![image-20231121194408502](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211944563.png)

![image-20231121194456629](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311211944681.png)

### kafka高可用设计

![image-20231121225235817](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212252956.png)

![image-20231121225257029](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212252102.png)

![image-20231121225358195](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212253278.png)



![image-20231121225512018](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212255102.png)

### kafka生产者详解

![image-20231121230818009](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212308062.png)

![image-20231121230808923](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212308994.png)

![image-20231121231256728](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212312817.png)

![image-20231121231636914](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212316996.png)

![image-20231121232322331](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212323400.png)

### 消费者组详解

![image-20231121232701056](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212327143.png)

![image-20231121232850800](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212328843.png)

![image-20231121233000241](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212330316.png)

### 提交和偏移量

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212332381.png)

![image-20231121233302935](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212333002.png)

![image-20231121233357631](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212333693.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212334987.png)

![image-20231121233503247](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212335305.png)

![image-20231121233738727](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212337794.png)

![image-20231121233807583](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311212338643.png)

### SpringBoot集成Kafka

![image-20231122111041121](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221110242.png)

![image-20231122111109857](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221111926.png)

![image-20231122111227827](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221112897.png)

kafka中的key有必要添加吗？

在Apache Kafka中，消息通常由键（key）和值（value）组成。键是消息的标识符，而值是实际的数据。在某些情况下，为消息指定键是有意义的，而在其他情况下可能不是必要的。

以下是一些关于在Kafka中使用键的考虑因素：

1. **分区策略：** Kafka使用分区来组织和分发消息。消息的键决定了它将被分配到哪个分区。如果你希望具有相同键的消息被发送到相同的分区，以确保它们按顺序处理，那么使用键是有意义的。

2. **消息去重：** 如果你希望确保具有相同键的消息不会被重复处理，那么可以使用键来实现消息去重。在这种情况下，确保你的键具有一致的生成方式，以便相同的消息生成相同的键。

3. **连接操作：** 在一些情况下，使用键可以方便地将相关消息连接在一起。例如，你可以使用相同的键将特定实体的更新消息组合在一起，以便更轻松地在消费者端进行处理。

4. **日志压缩：** 如果你使用的是Kafka的日志压缩功能，那么具有相同键的消息在日志中更有可能被压缩在一起，这可能有助于提高性能。

总的来说，是否需要在Kafka中使用键取决于你的具体使用情境。如果你关心消息的顺序、去重或者希望根据键来执行一些特定的处理，那么使用键可能是有益的。否则，在一些简单的场景中，你可能可以不使用键。

```js
spring:
  application:
    name: kafka-demo
这段配置的作用
```

这段配置是使用YAML格式配置Spring Boot应用程序的一部分，它指定了应用程序的名称。让我解释一下这个配置的各个部分：

1. `spring:` - 这是Spring Boot配置的顶级标识。所有Spring Boot的配置属性都应该放在这个标识下。

2. `application:` - 这是Spring Boot应用程序配置的一部分。Spring Boot会根据`application.yml`或`application.properties`文件中的这个前缀来加载应用程序的配置属性。

3. `name: kafka-demo` - 这指定了应用程序的名称。在Spring Boot应用程序中，应用程序的名称可以用于标识应用程序，提供一些与应用程序相关的默认配置，以及在一些场景中用于服务发现等。

总的来说，这段配置告诉Spring Boot应用程序，它的名称是"kafka-demo"。这对于日志、监控、服务注册等方面都可能有一些作用。在微服务体系结构中，应用程序的名称通常用于在服务注册中心注册服务，以便其他服务能够发现和调用它。



它可以用于nacos的服务注册与发现吗？

是的，Spring Boot应用程序的名称通常可以与服务注册与发现框架（例如Nacos、Eureka等）集成，以便在这些框架中注册服务并进行服务发现。在你提供的配置中，虽然只有应用程序的名称被设置为"kafka-demo"，但你还需要配置其他与服务注册和发现相关的属性。

如果你想要使用Nacos作为服务注册与发现的解决方案，你需要添加相应的Nacos依赖，并在`application.yml`或`application.properties`中配置Nacos的连接信息。以下是一个简单的示例：

```yaml
spring:
  application:
    name: kafka-demo

nacos:
  discovery:
    server-addr: localhost:8848 # Nacos服务器地址
    namespace: your-namespace # 可选，命名空间，如果使用多个Nacos服务器
```

上述配置中，`nacos.discovery.server-addr`指定了Nacos服务器的地址，`nacos.discovery.namespace`是一个可选的配置，用于指定Nacos的命名空间。通过这样的配置，你的Spring Boot应用程序就可以使用Nacos进行服务注册和发现了。

### 传递消息为对象

![image-20231122124108006](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221241138.png)

### 自媒体文章上下架

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221248323.png)

![image-20231122124841651](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221248736.png)

![image-20231122125107167](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221251259.png)

![image-20231122125305670](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221253757.png)

一般高流量的操作用MQ

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221258779.png)

RequestBody注解的作用？

让我更详细地解释 `@RequestBody` 注解的作用。

当你发送HTTP请求时，请求通常包含两个部分：请求头和请求体。请求头包含一些关于请求的元信息，而请求体包含实际的数据。对于GET请求，通常数据是作为查询参数（例如在URL中）传递的，但对于POST请求等，数据通常被包含在请求体中。

`@RequestBody` 注解告诉Spring框架，你希望将HTTP请求体的内容读取到方法的参数中。这在处理POST请求时非常有用，因为POST请求的数据通常包含在请求体中，而不是像GET请求那样在URL中。

举个例子，假设有一个前端页面通过POST请求向服务器提交用户的注册信息。在这个POST请求的请求体中，可能包含了用户的用户名、密码等信息。使用 `@RequestBody` 注解，你可以将这个请求体的数据映射到一个Java对象中，然后在你的后端代码中使用这些数据执行相应的逻辑（比如创建用户账户）。

下面是一个简单的示例：

```java
@RestController
@RequestMapping("/api")
public class UserController {

    @PostMapping("/register")
    public ResponseEntity<String> registerUser(@RequestBody UserRegistrationData userData) {
        // userData对象现在包含了从请求体中解析出的用户注册信息
        // 执行创建用户账户的逻辑

        return ResponseEntity.ok("User registered successfully");
    }
}
```

在这个例子中，`UserRegistrationData` 是一个Java类，它有字段对应于用户注册时所需的信息（例如用户名、密码等）。使用 `@RequestBody` 注解，Spring框架会自动将POST请求的请求体中的数据映射到 `UserRegistrationData` 对象中，这样你就能够轻松地在方法中使用这些数据。

### 消息通知Article进行数据同步

![image-20231122145547344](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221455527.png)

![image-20231122145617133](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221456208.png)

![image-20231122145905478](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311221459551.png)

## 第七天

![image-20231122213558953](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311222135172.png)

![image-20231122213616233](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311222136299.png)

### es环境搭建

linux如何查找某个文件夹地址

在Linux系统中，你可以使用 `find` 命令来查找某个文件夹的地址。以下是一些 `find` 命令的使用示例：

1. **按文件夹名字查找：**
   
   ```bash
   find / -type d -name "your_folder_name"
   ```

   这会在整个文件系统中查找名为 "your_folder_name" 的文件夹，`-type d` 表示查找文件夹。

2. **按绝对路径查找：**

   ```bash
   find / -type d -path "/your/absolute/path"
   ```

   这会在整个文件系统中查找绝对路径为 "/your/absolute/path" 的文件夹。

3. **按部分路径查找：**

   ```bash
   find / -type d -path "*/your/partial/path*"
   ```

   这会在整个文件系统中查找路径包含 "your/partial/path" 的文件夹。

4. **限制深度查找：**

   ```bash
   find / -maxdepth 3 -type d -name "your_folder_name"
   ```

   这会在整个文件系统中查找深度不超过3层的文件夹，你可以根据需要调整 `-maxdepth` 参数。

请替换上述命令中的 "your_folder_name"、"/your/absolute/path" 和 "*/your/partial/path*" 为实际的文件夹名称或路径。请注意，使用 `find` 命令可能需要 root 权限才能搜索整个文件系统。

另外，你还可以使用 `locate` 命令来进行文件查找，但需要注意的是 `locate` 命令是基于系统索引的，所以它的结果可能不是实时的。

![image-20231122231423026](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311222314193.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311222316697.png)

![image-20231122231653026](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311222316104.png)

![image-20231122232102524](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311222321595.png)

![image-20231122232129299](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311222321368.png)

PUT 请求在创建索引时需要指定索引的名称，而 POST 请求则允许 Elasticsearch 自动生成一个随机的索引名称。

### 初始化索引库数据

![image-20231122232747825](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311222327932.png)

![image-20231122232753953](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311222327021.png)

mybatisplus的缺陷是只能操作一个表吗？

MyBatis-Plus 是在 MyBatis 的基础上进行的封装，它提供了更便捷的 CRUD 操作和一些其他增强功能，但并不限制只能操作一个表。事实上，MyBatis-Plus同样支持多表的操作。

MyBatis-Plus 主要通过代码生成器、Wrapper 查询条件构造器以及 Lambda 表达式等特性来简化操作。这些特性并不限制于单表操作，你仍然可以执行涉及多个表的复杂查询、联表查询等操作。

下面是一些 MyBatis-Plus 支持的多表操作的例子：

1. **Wrapper 查询条件构造器：** 你可以使用 Wrapper 进行复杂的条件查询，包括多表查询。例如，你可以通过 `Join` 方法关联其他表：

   ```java
   // 示例：联表查询
   QueryWrapper<User> wrapper = new QueryWrapper<>();
   wrapper.select("user.id", "user.name", "order.order_no")
          .from("user")
          .inSql("user.id", "select user_id from order");
   List<Map<String, Object>> list = userMapper.selectMaps(wrapper);
   ```

2. **Lambda 表达式：** MyBatis-Plus 的 Lambda Query Wrapper 提供了更加类型安全和直观的方式来构建查询条件，同样支持多表操作。例如：

   ```java
   // 示例：使用 Lambda 进行联表查询
   LambdaQueryWrapper<User> userWrapper = Wrappers.lambdaQuery();
   LambdaQueryWrapper<Order> orderWrapper = Wrappers.lambdaQuery();

   userWrapper.eq(User::getId, 1);
   orderWrapper.eq(Order::getUserId, 1);

   List<Map<String, Object>> list = userMapper.selectMaps(userWrapper
      .inSql("id", "select user_id from order where user_id = 1"));
   ```

3. **XML 配置文件：** 如果涉及到的操作比较复杂，你仍然可以使用 MyBatis-Plus 的 XML 配置文件来编写 SQL 映射，实现更为复杂的多表操作。

总的来说，MyBatis-Plus并不限制于单表操作，它提供了多种灵活的方式来处理多表查询、更新和删除等操作。

### 搜索微服务创建

![image-20231123125040479](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311231250688.png)

![image-20231123125103587](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311231251644.png)

![image-20231123125730609](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311231257730.png)

![image-20231123130101069](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311231301152.png)

mysql中的schema是什么？

让我用更简单的方式解释一下 MySQL 中的 "schema"。

在 MySQL 中，一个 "schema" 可以看作是一个数据库内的子集，它用于组织和管理数据库中的表、视图、存储过程等对象。一个数据库可以包含多个 "schema"，每个 "schema" 代表数据库中的一个逻辑部分。

举个例子，假设你有一个名为 `my_database` 的数据库，你可以在这个数据库中创建多个 "schema"，比如 `users` 和 `products`。每个 "schema" 中可以包含属于这个模块或功能的表和其他数据库对象。

```sql
-- 在 my_database 数据库中创建两个 schema
CREATE SCHEMA users;
CREATE SCHEMA products;

-- 在 users schema 中创建一个表
CREATE TABLE users.user_data (
    id INT,
    username VARCHAR(50)
);

-- 在 products schema 中创建一个表
CREATE TABLE products.product_data (
    id INT,
    product_name VARCHAR(50)
);
```

在这个例子中，`my_database` 是数据库的名字，而 `users` 和 `products` 是两个 "schema"。每个 "schema" 下都有自己的表（`user_data` 和 `product_data`），它们分别存储了与用户和产品相关的数据。

"Schema" 提供了一种在一个数据库内组织和隔离数据的方式，有助于将数据库中的对象进行逻辑上的分组。这使得在大型应用程序中更容易管理和维护数据库结构。



无法理解elasticsearch中的mapping？

让我尝试以更简单的方式解释 Elasticsearch 中的映射。

在 Elasticsearch 中，"mapping"（映射）是一种告诉 Elasticsearch 如何处理文档的方式。当你往 Elasticsearch 中索引（存储）数据时，你可以定义每个字段的类型、如何搜索这些字段，以及如何处理它们的内容。

**为什么映射很重要？**

1. **数据类型：** 映射定义了每个字段的类型。比如，一个字段可以是文本、数字、日期等。这有助于 Elasticsearch 理解如何正确地处理这些字段的数据。

2. **搜索和过滤：** 映射可以指定哪些字段是可以被搜索的，哪些字段是可以被用于过滤的。这有助于提高查询的效率。

3. **全文搜索：** 如果有文本字段，映射可以定义使用什么分析器来处理文本。分析器决定了如何将文本拆分成单词，以便进行全文搜索。

4. **聚合：** 映射可以定义哪些字段可以被用于聚合操作。聚合是一种对数据进行统计和分析的方式。

**映射的例子：**

假设你有一个文档表示博客文章：

```json
{
  "title": "Elasticsearch Mapping Explained",
  "author": "John Doe",
  "publish_date": "2023-01-01",
  "content": "A detailed explanation of Elasticsearch mapping."
}
```

你可以定义一个映射告诉 Elasticsearch 如何处理这个文档：

```json
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "standard"
      },
      "author": {
        "type": "keyword"
      },
      "publish_date": {
        "type": "date"
      },
      "content": {
        "type": "text",
        "analyzer": "english"
      }
    }
  }
}
```

在这个映射中：

- `title` 是一个文本字段，使用标准分析器。
- `author` 是一个关键字字段，适合用于精确匹配和聚合。
- `publish_date` 是一个日期字段。
- `content` 是一个文本字段，使用英语分析器。

这个映射告诉 Elasticsearch 如何正确地处理博客文章的每个字段，从而使得你能够有效地进行搜索和分析。希望这样的例子更容易理解映射的作用。

![image-20231123140631709](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311231406828.png)

es中的DSL的布尔查询?

在 Elasticsearch 中，你可以使用 DSL（领域特定语言）来构建各种类型的查询，包括布尔查询。DSL 提供了一种灵活的方式来描述 Elasticsearch 查询的结构。

布尔查询是一种组合多个子查询的查询类型，它使用逻辑运算符（AND、OR、NOT）将这些子查询组合起来，以获得更复杂的查询逻辑。以下是 DSL 中用于构建布尔查询的一些主要元素：

1. **`bool` 查询：** `bool` 查询是 Elasticsearch 中的布尔查询，可以包含 `must`、`should`、`must_not` 等子句。

    ```json
    {
      "query": {
        "bool": {
          "must": [
            { "match": { "field1": "value1" } },
            { "range": { "field2": { "gte": 10, "lte": 20 } } }
          ],
          "should": [
            { "term": { "field3": "value3" } }
          ],
          "must_not": [
            { "exists": { "field": "field4" } }
          ]
        }
      }
    }
    ```

2. **`must` 子句：** 表示所有的条件都必须匹配。

3. **`should` 子句：** 表示至少一个条件必须匹配，可以用于构建 OR 关系。

4. **`must_not` 子句：** 表示条件不能匹配，可以用于构建 NOT 关系。

5. **`filter` 子句：** 类似于 `must` 子句，但它不计算分数，主要用于过滤不需要计算相关性的条件。

以下是一个简单的例子，说明如何使用 `bool` 查询构建一个布尔查询：

```json
{
  "query": {
    "bool": {
      "must": [
        { "match": { "title": "elasticsearch" } }
      ],
      "filter": [
        { "range": { "publish_date": { "gte": "2022-01-01" } } }
      ],
      "should": [
        { "match": { "category": "technology" } },
        { "match": { "category": "data" } }
      ],
      "must_not": [
        { "match": { "status": "inactive" } }
      ]
    }
  }
}
```

在这个例子中，查询包含了多个条件，包括必须匹配的 `must` 条件、用于过滤的 `filter` 条件、至少一个应该匹配的 `should` 条件，以及不能匹配的 `must_not` 条件。

这种灵活的布尔查询语法允许你构建复杂的查询逻辑，以满足不同的搜索需求。



```js
        #搜索微服务
        - id: leadnews-search
          uri: lb://leadnews-search
          predicates:
            - Path=/search/**
          filters:
            - StripPrefix= 1
这段配置是什么意思
```

这是一个 Spring Cloud Gateway 的路由配置，用于将请求路由到微服务。让我解释一下每个部分的含义：

1. **id: leadnews-search：** 定义了路由的唯一标识符。在这个例子中，路由的 ID 被设置为 "leadnews-search"。

2. **uri: lb://leadnews-search：** 定义了目标微服务的 URI。这里使用的是 `lb://` 前缀，表示这是一个负载均衡的请求。`leadnews-search` 是微服务的名称。

3. **predicates：** 定义了路由的匹配规则。在这个例子中，该路由匹配的条件是请求的路径必须以 "/search/" 开头，即 `Path=/search/**`。

4. **filters：** 定义了路由的过滤器。在这个例子中，`StripPrefix=1` 表示在将请求发送到目标微服务之前，将请求路径中的前缀 "/search/" 去除掉。这样，例如，如果原始请求是 "/search/query"，经过路由后，目标微服务实际上收到的请求路径会是 "/query"。

综合起来，这个配置的含义是：

- 当有请求路径以 "/search/" 开头时，将该请求路由到名为 "leadnews-search" 的微服务。
- 在路由之前，将请求路径中的 "/search/" 前缀去除。

这是 Spring Cloud Gateway 路由配置的一个简单示例，用于实现请求的转发和路径处理。



### 新增文章创建索引

![image-20231123214334946](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311232143134.png)

![image-20231123214408546](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311232144605.png)

![image-20231123214433594](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311232144660.png)

### mongodb环境搭建

![image-20231123225916172](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311232259346.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311232300744.png)

### SpringBoot集成Mongodb

![image-20231124202719386](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311242027535.png)

![image-20231124202803067](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311242028132.png)

![image-20231124202841472](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311242028548.png)

```java
User
package com.itheima.mongo.pojo;

import lombok.Data;
import org.springframework.data.mongodb.core.mapping.Document;

import java.io.Serializable;
import java.util.Date;

/**
 * <p>
 * 联想词表
 * </p>
 *
 * @author itheima
 */
@Data
@Document("ap_associate_words")
public class ApAssociateWords implements Serializable {

    private static final long serialVersionUID = 1L;

    private String id;

    /**
     * 联想词
     */
    private String associateWords;

    /**
     * 创建时间
     */
    private Date createdTime;

}
这里面为什么要实现序列化，以及为什么要有这个private static final long serialVersionUID = 1L;
```

在 Java 中，实现 `Serializable` 接口的类表明该类的实例可以被序列化，即可以将对象的状态保存到字节流中，以便在需要时进行传输或持久化。在这里，为什么要实现序列化和为什么需要 `serialVersionUID`，我将分别解释：

### 为什么要实现序列化？

1. **数据传输：** 在分布式系统或者网络通信中，对象需要在不同的系统或节点之间传输。通过实现 `Serializable` 接口，你可以将对象转换成字节流，然后在不同的系统之间传递这些字节流，从而在系统之间传输对象的状态。

2. **持久化：** 在一些场景下，需要将对象的状态保存到磁盘或数据库，以便在程序重新启动时能够还原对象的状态。实现序列化可以方便地将对象序列化为字节流，然后进行持久化存储。

### 为什么需要 `serialVersionUID`？

`serialVersionUID` 是一个版本号，用于在反序列化时验证发送方和接收方的对象是否版本匹配。它的作用主要有两个：

1. **版本控制：** 在类的结构发生变化时，特别是新增或删除字段等修改，`serialVersionUID` 可以用来确保反序列化时类的版本一致，防止出现版本不一致导致的反序列化失败。

2. **避免冲突：** 如果你不显式地定义 `serialVersionUID`，Java 序列化机制会根据类的结构自动生成一个。但是，自动生成的 `serialVersionUID` 对于类的结构的细微变化非常敏感，可能会导致反序列化失败。因此，显式地定义 `serialVersionUID` 可以避免自动生成的 `serialVersionUID` 变化导致的问题。

在你的代码中，`private static final long serialVersionUID = 1L;` 表示这个类的序列化版本号是 1L。如果你稍后对类的结构进行更改，建议及时更新 `serialVersionUID`，以确保版本一致性。

### 保存搜索记录

![image-20231124211720766](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311242117855.png)

![image-20231124211804188](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311242118256.png)

![image-20231124212106157](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311242121239.png)

![image-20231124212131404](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311242121475.png)

![image-20231124212200214](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311242122292.png)

![image-20231124212320960](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311242123024.png)

### 加载搜索记录

![image-20231125161042603](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311251610784.png)

### 删除搜索记录

![image-20231125162651899](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311251626987.png)

### 关键字联想

![image-20231125193639089](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311251936246.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311252029986.png)

![image-20231125203005851](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311252030908.png)

![image-20231125203010987](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311252030058.png)

## 第九天

### 用户行为

![image-20231127201331116](https://cdn.jsdelivr.net/gh/yzk656/image/img/202311272013297.png)

![image-20231202125126496](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021251658.png)

![image-20231202125156219](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021251308.png)

![image-20231202125208783](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021252861.png)

![image-20231202125225325](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021252408.png)

![image-20231202125254164](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021252228.png)

## 第十天

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021414947.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021417813.png)

![image-20231202141822635](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021418707.png)

![image-20231202142120190](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021421253.png)

![image-20231202142128221](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021421278.png)

### 分布式任务调度

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021424566.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021553369.png)

![image-20231202155350587](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021553664.png)

![image-20231202160637385](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021606555.png)

![image-20231202160650903](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021606983.png)

![image-20231202160746911](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021607983.png)

![image-20231202161055458](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021610554.png)

![image-20231202162745466](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021627547.png)

![image-20231202162755237](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021627316.png)

![image-20231202162905856](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312021629916.png)

![image-20231203155723154](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312031557327.png)

![image-20231203160325366](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312031603426.png)

### GLUE模式（JAVA）

![image-20231203171513208](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312031715414.png)

### 执行器集群

![image-20231203172737420](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312031727496.png)

![image-20231203211237403](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312032112591.png)

### 分片

![image-20231203221618449](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312032216596.png)

### Kafka stream

![image-20231204232222807](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312042322997.png)

![image-20231204232309795](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312042323905.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312042355772.png)

![image-20231205204110199](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312052041357.png)

![image-20231205204117405](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312052041490.png)

![image-20231205204214365](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312052042470.png)

能给我讲解一下匿名内部类，我不太理解？

当你在Java中创建一个类的实例时，通常会先定义一个类，然后使用`new`关键字实例化这个类。而匿名内部类允许你在实例化的同时定义一个类，而无需显式地编写一个完整的类定义。

下面是一个简单的例子，假设有一个接口`MyInterface`：

```java
interface MyInterface {
    void myMethod();
}
```

你可以使用匿名内部类来实现这个接口并创建一个接口实例：

```java
public class Main {
    public static void main(String[] args) {
        // 使用匿名内部类实现MyInterface接口
        MyInterface myInterface = new MyInterface() {
            @Override
            public void myMethod() {
                System.out.println("Implementation of myMethod");
            }
        };

        // 调用接口方法
        myInterface.myMethod();
    }
}
```

在这个例子中，我们创建了一个实现`MyInterface`接口的匿名内部类，并在实例化的同时提供了`myMethod`方法的具体实现。然后我们通过`myInterface.myMethod()`调用这个方法。

要注意的是，这个匿名内部类实际上是一个实现了`MyInterface`接口的新类的实例，只是我们没有显式地给它一个名字。这种方式适用于一次性的、简单的类定义，特别是当你只需要在某个特定的地方创建一个实例时。

随着Java 8引入Lambda表达式，你也可以使用Lambda表达式来更简洁地实现接口的匿名内部类：

```java
MyInterface myInterface = () -> System.out.println("Implementation of myMethod");
```

这里的Lambda表达式与匿名内部类的效果相似，但语法更为简洁。



MyInterface是接口为什么能创建实例呀？

在Java中，接口是一种抽象类型，它不能直接被实例化。然而，通过匿名内部类或Lambda表达式，你可以创建一个实现接口的匿名类的实例。

当你使用匿名内部类实现一个接口时，实际上是在创建一个继承该接口的匿名类的实例。这个匿名类实现了接口中定义的方法。在上一个例子中：

```java
MyInterface myInterface = new MyInterface() {
    @Override
    public void myMethod() {
        System.out.println("Implementation of myMethod");
    }
};
```

这段代码创建了一个实现了`MyInterface`接口的匿名类的实例，并将其赋给了`myInterface`变量。这个匿名类实现了`MyInterface`接口的`myMethod`方法。

Lambda表达式是Java 8引入的另一种方式，可以更简洁地表示匿名类的实例。上面的例子可以用Lambda表达式改写为：

```java
MyInterface myInterface = () -> System.out.println("Implementation of myMethod");
```

这里的`() -> System.out.println("Implementation of myMethod")`就是一个Lambda表达式，实际上也是一个匿名类的实例，它实现了`MyInterface`接口的`myMethod`方法。

总的来说，虽然接口本身不能被实例化，但通过匿名内部类或Lambda表达式，你可以创建实现接口的匿名类的实例，并在实例中提供接口方法的具体实现。



## 持续集成

![image-20231206091918560](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312060919702.png)

![image-20231206092754689](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312060927759.png)

### 软件开发模式

![image-20231206093405701](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312060934798.png)

### Jekins安装配置

![image-20231206095129763](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312060951855.png)

![image-20231206095234260](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312060952342.png)

![image-20231206102348006](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312061023157.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091403000.png)

![image-20231209145131136](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091451381.png)

![image-20231209145229720](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091452769.png)

![image-20231209160320187](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091603412.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091604833.png)

![image-20231209160834691](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091608875.png)

![image-20231209160927754](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091609864.png)

![image-20231209161008137](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091610211.png)

![image-20231209191903610](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091919781.png)

![image-20231209191928830](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312091919906.png)

### 远程构建微服务

![image-20231209225248349](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092252510.png)

![image-20231209225253940](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092252012.png)

![image-20231209231057209](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092310406.png)

![image-20231209231104754](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092311828.png)

![image-20231209231135692](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092311764.png)

![image-20231209231201414](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092312491.png)

![image-20231209232525076](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092325192.png)

![image-20231209232531446](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092325504.png)

![](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092328173.png)

![image-20231209234109858](https://cdn.jsdelivr.net/gh/yzk656/image/img/202312092341975.png)

# 第一周

## 2058. 笨拙的手指

> 奶牛贝茜正在学习如何在不同进制之间转换数字。但是她总是犯错误，因为她无法轻易的用两个前蹄握住笔。每当贝茜将数字转换为一个新的进制并写下结果时，她总是将其中的某一位数字写错。例如，如果她将数字 14 转换为二进制数，那么正确的结果应为 1110，但她可能会写下 0110 或 1111。贝茜不会额外添加或删除数字，但是可能会由于写错数字的原因，写下包含前导 0的数字。给定贝茜将数字 *N* 转换为二进制数字以及三进制数字的结果，请确定 *N*的正确初始值（十进制表示）。
>
> #### 输入格式
>
> 第一行包含 *N*的二进制表示，其中一位是错误的。
>
> 第二行包含 *N*的三进制表示，其中一位是错误的。
>
> #### 输出格式
>
> 输出正确的 *N*的值。
>
> #### 数据范围
>
> 0≤*N*≤109，且存在唯一解。
>
> #### 输入样例：
>
> ```
> 1010
> 212
> ```
>
> #### 输出样例：
>
> ```
> 14
> ```
>
> #### 样例解释
>
> 14
>
>  在二进制下的正确表示为 1110，在三进制下的正确表示为 112。

```java
package 习题;

import java.util.*;
public class finger {
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        char[] a=sc.next().toCharArray();//将输入的字符串转换成字符数组，便于修改字符
        char[] b=sc.next().toCharArray();
        Set<Integer> s=new HashSet<Integer>();//Set集合用于存储转换后的数值，看是否存在交集
        for(int i=0;i<a.length;i++){
            a[i]=(char)((int)a[i]^1);//将该位的0转成1，1转换成0
            s.add(Integer.parseInt(new String(a),2));//使用Integer类的进制转换方法，将某进制转换成10进制【对于数组，可以使用String的构造器将其转换成字符串】
            a[i]=(char)((int)a[i]^1);//复位
        }
        for(int i=0;i<b.length;i++){
            char t=b[i];//由于三进制有三个数，就不能使用异或了，因此采用遍历的方式寻找
            for(int j=0;j<3;j++){
                if(j+'0'!=t){//如果该字符与当前字符不同，就可以试一下该字符
                    b[i]=(char)(j+'0');//将该字符进行更改
                    int x=Integer.parseInt(new String(b),3);//将其转换成10进制
                    if(s.contains(x)){//寻找集合里面是否有该十进制说，如果有就说明该三进制字符串转换一个字符与二进制字符串转换1个字符的十进制相等，输出该数
                        System.out.println(x);
                        return;
                    }
                }
            }
            b[i]=t;//如果该数发生了转换【一定会发生转换的】，但是并没有与二进制转换的十进制相匹配，则进行复位【防止以后转换成10进制时，数值不准确】
        }
    }
}

```

## 2041. 干草堆【差分法】    

### *差分数组

![image-20220125143945605](https://cdn.jsdelivr.net/gh/yzk656/image/202201301011164.png)

> 对于数值相同的

- 只需要修改想要修改的区间的起始位、末位的后一位【`前同后反`】
- 完事之后求前缀和就可以得到正确的数组

![image-20220125144912700](https://cdn.jsdelivr.net/gh/yzk656/image/202201301011170.png)

> 对于数值不同的

- 与“数值相同的”所不同的是需要先求出差分数组【差分数组是前缀和的逆运算】

> 为什么差分数组要进行`前同后否`

![image-20220125145332127](https://cdn.jsdelivr.net/gh/yzk656/image/202201301011865.png)

#### 练习1

![image-20220125163802351](https://gitee.com/demon_night/images/raw/master/imgs/202201301012056.png)

```java
package 习题1;

import java.util.Arrays;
import java.util.Scanner;

public class acw2041_test1 {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n= sc.nextInt();
        int k= sc.nextInt();
        int[] array=new int[n];
        int[] diff=new int[n];
        for(int i=0;i<n;i++) array[i]= sc.nextInt();
        for(int i=1;i<n;i++) diff[i]=array[i]-array[i-1];
        diff[0]=array[0];
        for(int i=0;i<k;i++){
            int a= sc.nextInt();
            int b= sc.nextInt();
            int c=sc.nextInt();
            diff[a-1]+=c;
            diff[b]-=c;
        }
        array[0]=diff[0];
        for(int i=1;i<n;i++){
            array[i]=diff[i]+array[i-1];
        }
        System.out.println(Arrays.toString(array));
    }
}
```



## 题目

> 贝茜对她最近在农场周围造成的一切恶作剧感到抱歉，她同意帮助农夫约翰把一批新到的干草捆堆起来。
>
> 开始时，共有 *N* 个空干草堆，编号 1∼*N*。约翰给贝茜下达了 *K* 个指令，每条指令的格式为 `A B`，这意味着贝茜要在 *A*..*B* 范围内的每个干草堆的顶部添加一个新的干草捆。
>
> 例如，如果贝茜收到指令 `10 13`，则她应在干草堆 10,11,12,13 中各添加一个干草捆。
>
> 在贝茜完成了所有指令后，约翰想知道 *N* 个干草堆的中值高度——也就是说，如果干草堆按照高度从小到大排列，位于中间的干草堆的高度。方便起见，*N*一定是奇数，所以中间堆是唯一的。
>
> 请帮助贝茜确定约翰问题的答案。
>
> #### 输入格式
>
> 第一行包含 *N* 和 *K*。
>
> 接下来 *K*行，每行包含两个整数 *A*,*B*，用来描述一个指令。
>
> #### 输出格式
>
> 输出完成所有指令后，*N*
>
>  个干草堆的中值高度。
>
> #### 数据范围
>
> ![image-20220125150354169](https://gitee.com/demon_night/images/raw/master/imgs/202201301011287.png)
>
> 
>
> #### 输入样例：
>
> ```
> 7 4
> 5 5
> 2 4
> 4 6
> 3 5
> ```
>
> #### 输出样例：
>
> ```
> 1
> ```
>
> #### 样例解释
>
> 贝茜完成所有指令后，各堆高度为 0,1,2,3,3,1,0
>
> 将各高度从小到大排序后，得到 0,0,1,1,2,3,3，位于中间的是 1。

```java
package 习题1;

import java.util.Arrays;
import java.util.Scanner;

public class acw2041_test {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n= sc.nextInt();
        int k= sc.nextInt();
        int[] array=new int[n];
        for(int i=0;i<k;i++){
            int a= sc.nextInt();
            int b= sc.nextInt();
            array[a-1]++;
            if(b<n) array[b]--;
        }
        array[0]=array[0];
        for(int i=1;i<n;i++){
            array[i]=array[i]+array[i-1];
        }
        Arrays.sort(array);
        System.out.println(array[n/2]);
    }
}
```



## 2060. 奶牛选美 

> 听说最近两斑点的奶牛最受欢迎，约翰立即购进了一批两斑点牛。不幸的是，时尚潮流往往变化很快，当前最受欢迎的牛变成了一斑点牛。约翰希望通过给每头奶牛涂色，使得它们身上的两个斑点能够合为一个斑点，让它们能够更加时尚。牛皮可用一个 *N*×*M* 的字符矩阵来表示，如下所示：
>
> ```
> ................
> ..XXXX....XXX...
> ...XXXX....XX...
> .XXXX......XXX..
> ........XXXXX...
> .........XXX....
> ```
>
> 其中，*X* 表示斑点部分。如果两个 *X* 在垂直或水平方向上相邻（对角相邻不算在内），则它们属于同一个斑点，由此看出上图中恰好有两个斑点。约翰牛群里**所有的牛都有两个斑点**。约翰希望通过使用油漆给奶牛尽可能少的区域内涂色，将两个斑点合为一个。在上面的例子中，他只需要给三个 .区域内涂色即可（新涂色区域用 ∗ 表示）：
>
> ```
> ................
> ..XXXX....XXX...
> ...XXXX*...XX...
> .XXXX..**..XXX..
> ........XXXXX...
> .........XXX....
> ```
>
> 请帮助约翰确定，为了使两个斑点合为一个，他需要涂色区域的最少数量。
>
> #### 输入格式
>
> 第一行包含两个整数 *N* 和 *M*。
>
> 接下来 *N*行，每行包含一个长度为 *M* 的由 *X* 和 .构成的字符串，用来表示描述牛皮图案的字符矩阵。
>
> #### 输出格式
>
> 输出需要涂色区域的最少数量。
>
> #### 数据范围
>
> 1≤*N*,*M*≤50
>
> 
>
> #### 输入样例：
>
> ```
> 6 16
> ................
> ..XXXX....XXX...
> ...XXXX....XX...
> .XXXX......XXX..
> ........XXXXX...
> .........XXX....
> ```
>
> #### 输出样例：
>
> ```
> 3
> ```

> Flood fill可以用于DFS、BFS【可以用于求最小值】

![image-20220125201208996](https://cdn.jsdelivr.net/gh/yzk656/image/202201301011329.png)

```java
package 习题1;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class acw2060_test {
    static char[][] g=new char[55][55];//存储数据：*、X
    static ArrayList[] l=new ArrayList[2];//存储两个集合
    static int[] dx=new int[]{-1,0,1,0};//用于flood fill算法的走向，行数的变换：上-》右-》下-》左
    static int[] dy=new int[]{0,1,0,-1};//列数的变换
    static int m,n;
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        n= sc.nextInt();//输入行数
        m= sc.nextInt();//输入列数
        for(int i=0;i<n;i++)
            g[i]=sc.next().toCharArray();//由于每行没有空格，因此需要将字符串转换成字符数组
        l[0]=new ArrayList();//将集合实例化。第一个集合
        l[1]=new ArrayList();//将集合实例化。第二个集合
        for(int i=0,k=0;i<n;i++)//洪水覆盖算法，如果从DFS中出来了，说明第一个联通集合已经找到
            for(int j=0;j<m;j++)
                if(g[i][j]=='X')
                    dfs(i,j,l[k++]);
        int ans=Integer.MAX_VALUE;//定义结果，寻找最小值
        for(Object i:l[0]){//用Object类进行接收
            for(Object j:l[1]){
                int[] a=(int[]) i;//将其强转成数组类型
                int[] b=(int[]) j;
                ans=Math.min(ans,Math.abs(a[0]-b[0])+Math.abs(a[1]-b[1])-1);//通过“曼哈顿方法”
            }
        }
        System.out.println(ans);
    }
    private static void dfs(int i,int j,ArrayList l){
        l.add(new int[]{i,j});//将该点坐标加到数组中，把数组存储在集合里
        g[i][j]='*';//防止“转圈圈”，将该节点置为“*”
        for(int t=0;t<4;t++){//进行四方向扩散，满足题意的进行下次下次扩散
            int a=i+dx[t],b=j+dy[t];
            if(a>=0&&a<n&&b>=0&&b<m&&g[a][b]=='X'){
                dfs(a,b,l);
            }
        }
    }
}
```



# 第三周

## 1934. 贝茜放慢脚步

> 奶牛贝茜正在参加冬季哞林匹克运动会的越野滑雪比赛。
>
> 她以每秒 1米的速度出发。但是，随着时间的推移，她变得越来越疲倦，她开始放慢脚步。每次放慢脚步，贝茜的速度都会降低：减速一次后，她以每秒 1/2米的速度移动，减速两次后，则以每秒 1/3 米的速度移动，依此类推。你将被告知何时何地贝茜会减速。
>
> 当减速信息格式为：
>
> ```
> T 17
> ```
>
> 意味着，贝茜在某个时间点减速，本例表示比赛开始第 17 秒贝茜减速。
>
> 当减速信息格式为：
>
> ```
> D 10
> ```
>
> 意味着，贝茜在某个地点减速，本例表示在行进 10米处减速。
>
> 给定 *N*个减速信息，请计算贝茜滑完一千米需要多少秒。
>
> 将你的答案四舍五入到最接近的整数（ 0.5向上舍入为 1）。
>
> #### 输入格式
>
> 第一行包含整数 *N*
>
> 接下来 *N*行，每行描述一个减速信息，格式为 `T x` 或 `D x`。
>
> 无论哪种情况，*x*
>
> 都是一个整数，保证所有减速都在贝茜滑完一千米前发生。
>
> 可能同时发生多次减速，那么这会使得贝茜的速度一下子变慢很多。
>
> 所有减速信息不一定按顺序给出。
>
> #### 输出格式
>
> 输出贝茜滑完一千米所需的总时间。
>
> #### 数据范围
>
> 1≤*N*≤10000
>
> #### 输入样例：
>
> ```
> 2
> T 30
> D 10
> ```
>
> #### 输出样例：
>
> ```
> 2970
> ```
>
> ![image-20220119165636763](https://gitee.com/demon_night/images/raw/master/imgs/202201301011738.png)

```java
package 习题;

import java.util.*;

public class acw1934_test {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int num=sc.nextInt();//减速次数
        ArrayList<Integer> a=new ArrayList<>();//存储减速的时间位置
        ArrayList<Integer> b=new ArrayList<>();//存储减速的距离位置
        for(int i=0;i<num;i++){
            if(sc.next().charAt(0)=='T'){//如果输入T，则将对应的数存储在时间数组里
                a.add(sc.nextInt());
            }
            else{//如果输入D，则将对应的数存储在距离数组里
                b.add(sc.nextInt());
            }
        }
        b.add(1000);//由于可能所给的时间或距离根本到达不了1000米，因此可以把1000存放在距离数组里面
        Collections.sort(a);//由于输入的数据并不是按照从小到大的顺序输入的，因此还需要排序
        Collections.sort(b);
        double s=0,t=0,v=1;//定义时间、距离为0，速度其实为1
        int i=0,j=0;//定义两个指针指向两个数组
        while(i<a.size()||j<b.size()){//知道两个数组都走完，才结束循环
            if(j==b.size()||i<a.size()&&(a.get(i)-t)<(b.get(j)-s)*v){//如果b数组遍历完了，或者a数组是没有遍历完并且当前a的值发生在b之前
                s+=(a.get(i)-t)/v;//距离为当前距离+时间差*速度
                t=a.get(i);//时间刷新
                v++;//速度的分母+1
                i++;//走向a的下一个元素
            }
            else{
                t+=(b.get(j)-s)*v;//时间为距离差除以速度【距离差*分母】
                s=b.get(j);//刷新距离
                v++;//速度的分母+1
                j++;//走向b数组的下一个元素
            }
        }
        System.out.println(Math.round(t));//对double类型的
    }
}
```

# 第一周

## \3346. 你知道你的ABC吗            

> ![image-20220314152622101](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220314152622101.png)

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int[] array=new int[7];
        for(int i=0;i<7;i++) array[i]=sc.nextInt();
        Arrays.sort(array);
        int c=array[6]-array[0]-array[1];
        System.out.println(array[0]+" "+array[1]+" "+c);
    }
}
```

- 由于已经确定了A<=B<=C,因此数组排序后一定第一个是A，由于*C*、*A*+*B*、*B*+*C*、*C*+*A* 和 *A*+*B*+*C*都B大，因此B一定是位于第二个位置，因此知道了两个数后，由于最后一个数是A+B+C，因此，可以将其和减去A+B即可得到C

## \3358. 放养但没有完全放养            

> ![image-20220315093649546](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220315093649546.png)

```java
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        String s1=sc.next();
        HashMap<Character,Integer> h=new HashMap<>();
        for(int i=0;i<s.length();i++){
            h.put(s.charAt(i),i);
        }
        int ans=1;
        for(int i=1;i<s1.length();i++){
            if(h.get(s1.charAt(i))<=h.get(s1.charAt(i-1))){
                ans++;
            }
        }
        System.out.println(ans);
    }
}
```

- 两个字符，如果第二个字符在字母表里的顺序在在第一个前面或者顺序相同，说明新唱的歌，否则就认为是同一首歌

## \3370. 牛年

> Farmer John 的奶牛们得知最近正在庆祝牛年的到来时十分兴奋。
>
> 牛年总是奶牛们的最爱。
>
> 我们知道，中国历法中每一年所对应的生肖遵循 1212 年的周期：`Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig, Rat`（牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪、鼠），然后回到牛。
>
> 奶牛 Bessie 自豪地说她是在许多年前的一个牛年出生的。
>
> 她的朋友 Elsie 想要知道她与 Bessie 出生相差多少年，并且希望你能够通过查看农场上若干奶牛出生年份之间的关系来帮助她推算。
>
> #### 输入格式
>
> 输入的第一行包含一个整数 NN。
>
> 以下 NN 行每行包含一个 88 个单词的短语，指定了两头奶牛的出生年份之间的关系，格式为 `Mildred born in previous Dragon year from Bessie`（Mildred 在 Bessie 出生的前一个龙年出生），或 `Mildred born in next Dragon year from Bessie`（Mildred 在 Bessie 出生的后一个龙年出生）。
>
> 最后一个单词是农场上某一头奶牛的名字，为 “Bessie” 或一头已经在之前的输入中出现过的奶牛。
>
> 第一个单词是农场上某一头奶牛的名字，不为 “Bessie” 且未在之前的输入中出现过。
>
> 所有的奶牛名字不超过 1010 个字符，且仅包含字符 a..za..z 或 A..ZA..Z。
>
> 第 55 个单词是上述十二生肖之一。
>
> 第 44 个单词是 `previous`（之前）或 `next`（之后）之一。
>
> 例如，如果短语为 `Mildred born in previous Dragon year from Bessie`，则 Mildred 的出生年份为最为接近且严格处于 Bessie 的出生年份之前（不等于）的龙年。
>
> #### 输出格式
>
> 输出 Bessie 和 Elsie 的出生年份之间相差的年数。输入保证可以通过给定的信息求出结果。
>
> #### 数据范围
>
> 1≤N≤1001≤N≤100
>
> #### 输入样例：
>
> ```
> 4
> Mildred born in previous Dragon year from Bessie
> Gretta born in previous Monkey year from Mildred
> Elsie born in next Ox year from Gretta
> Paulina born in next Dog year from Bessie
> ```
>
> #### 输出样例：
>
> ```
> 12
> ```
>
> #### 样例解释
>
> 在以上的输入中，
>
> - Elsie 在 Bessie 之前 1212 年出生。
> - Mildred 在 Bessie 之前 99 年出生。
> - Gretta 在 Bessie 之前 1717 年出生。
> - Paulina 在 Bessie 之后 99 年出生

```java
import java.util.*;
import java.io.*;
public class Main {
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        Map<String,Integer> id=new HashMap<>(){{
            put("Ox",0);
            put("Tiger",1);
            put("Rabbit",2);
            put("Dragon",3);
            put("Snake",4);
            put("Horse",5);
            put("Goat",6);
            put("Monkey",7);
            put("Rooster",8);
            put("Dog",9);
            put("Pig",10);
            put("Rat",11);
        }};
        HashMap<String,Integer> name_ans=new HashMap<>();
        name_ans.put("Bessie",0);
        int n=sc.nextInt();
        for(int i=0;i<n;i++){
            String[] s=new String[8];
            for(int j=0;j<8;j++) s[j]=sc.next();
            if(s[3].equals("previous")){
                int x=name_ans.get(s[7]),y=id.get(s[4]);
                int r=((x-y)%12+12)%12;
                if(r==0) r=12;
                name_ans.put(s[0],x-r);
            }
            else{
                int x=name_ans.get(s[7]),y=id.get(s[4]);
                int r=((y-x)%12+12)%12;
                if(r==0) r=12;
                name_ans.put(s[0],x+r);
            }
        }
        System.out.println(Math.abs(name_ans.get("Elsie")));
    }
}
```

- 将生肖与数值进行映射，由于知道了Bessie的生肖，也就知道了位置，根据相对位置，然后对新牛进行查找
- `((x-y)%12+12)%12;`能够将不管取余结果是正还是负的，都能将取取正
-  `Map<String,Integer> id=new HashMap<>(){{}}`两个大括号可以直接put信息

# 力扣

## [554. 砖墙](https://leetcode.cn/problems/brick-wall/)

> 你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。
>
> 你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。
>
> 给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。
>
>  
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/yzk_image/raw/master/img/cutwall-grid.jpg)
>
>
> 输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
> 输出：2
> 示例 2：
>
> 输入：wall = [[1],[1],[1]]
> 输出：3
>
> ![image-20220512214440955](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220512214440955.png)

```java
class Solution {
    public int leastBricks(List<List<Integer>> wall) {
        HashMap<Integer,Integer> h=new HashMap<>();
    
        int len=0;
        for(List<Integer> i:wall){
            len+=i.size();
        }
        
        if(len==wall.size()) return wall.size();
        
        for (List<Integer> i:wall){
            int temp=0;
            for(int j:i){
                temp+=j;
                h.put(temp,h.getOrDefault(temp,0)+1);
            }
        }

        int ans=0;
        int temp=-1;
        int sum=0;
        
        for(List<Integer> i:wall){
            for (int j:i){
                sum+=j;
            }
            break;
        }

        for(int i:h.keySet()){
            if(i!=sum)
            ans=Math.max(ans,h.get(i));
        }

        return wall.size()-ans;
    }
}
```

## [692. 前K个高频单词](https://leetcode.cn/problems/top-k-frequent-words/)

> 给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。
>
> 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。
>
>  
>
> 示例 1：
>
> 输入: words = ["i", "love", "leetcode", "i", "love", "coding"], k = 2
> 输出: ["i", "love"]
> 解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。
>     注意，按字母顺序 "i" 在 "love" 之前。
> 示例 2：
>
> 输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
> 输出: ["the", "is", "sunny", "day"]
> 解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词，
>     出现次数依次为 4, 3, 2 和 1 次。
>
> ![image-20220512214656602](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220512214656602.png)

```java
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        HashMap<String,Integer> h=new HashMap<>();

        for(String i:words){
            h.put(i,h.getOrDefault(i,0)+1);
        }

        List<Map.Entry<String, Integer>> list = new ArrayList<Map.Entry<String, Integer>>(h.entrySet());

        Collections.sort(list, new Comparator<Map.Entry<String, Integer>>() {
            @Override
            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                if(o1.getValue()==o2.getValue()){
                    return o1.getKey().compareTo(o2.getKey());
                }
                return o2.getValue().compareTo(o1.getValue());
            }
        });

        int temp=0;
        List<String> l=new ArrayList<>();
        for(Map.Entry<String,Integer> i:list){
            l.add(i.getKey());
            temp++;
            if(temp==k) break;
        }

        return l;

    }
}
```

1. 由于哈希表是不能进行排序，但是ArrayList可以，因此可以将HashMap的Entry节点进行排序
   1. 排序时可以使用内部类comparator，使用compare方法
   2. 对于String类的compareTo方法是通过字典序进行排序的
2. sort函数是通过快排来进行实现的
   1. 排在最糟糕得情况下时间复杂度是O(n²)，平均的复杂度是O(nlogn)，这里的n和logn, 分别代表了调用栈的高度，和完成每层的时间，在a取数组的第一项时候，是最糟的情况，完成每层需要的时间是n，栈的高读是n，时间复杂度就是n²，当取中间的值得时候，完成每层的时间是n，但是调用栈的高度变成了logn，所以这个时候时间复杂度是nlogn

## [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

> 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
>
>  
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/yzk_image/raw/master/img/mat1.jpg)
>
> 输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
> 输出：[[1,0,1],[0,0,0],[1,0,1]]
> 示例 2：
>
> ![img](https://gitee.com/demon_night/yzk_image/raw/master/img/mat2.jpg)
>
>
> 输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
> 输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
>
> ![image-20220513215103899](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220513215103899.png)

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        ArrayList<int[]> l=new ArrayList<>();

        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                if(matrix[i][j]==0){
                    l.add(new int[]{i,j});
                }
            }
        }

        for(int[] i:l){
            int a=i[0],b=i[1];
            for(int m=0;m<matrix[0].length;m++){
                matrix[a][m]=0;
            }
            for(int m=0;m<matrix.length;m++){
                matrix[m][b]=0;
            }
        }
        
    }
}
```

> 对于O（1）空间复杂

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        boolean flag_x=false,flag_y=false;

        for(int i=0;i<matrix[0].length;i++){
            if(matrix[0][i]==0) flag_y=true;
        }
        for(int i=0;i<matrix.length;i++){
            if(matrix[i][0]==0) flag_x=true;
        }

        for(int i=1;i<matrix.length;i++){
            for(int j=1;j<matrix[0].length;j++){
                if(matrix[i][j]==0){
                    matrix[0][j]=matrix[i][0]=0;
                }
            }
        }

        for(int i=1;i<matrix.length;i++){
            for(int j=1;j<matrix[0].length;j++){
                if(matrix[i][0]==0||matrix[0][j]==0){
                    matrix[i][j]=0;
                }
            }
        }
        
        if(flag_x){
            for(int i=0;i<matrix.length;i++){
                matrix[i][0]=0;
            }
        }
        if(flag_y){
            for(int i=0;i<matrix[0].length;i++){
                matrix[0][i]=0;
            }
        }

    }
}
```

1. 将图中所有为0的信息都存储在边缘
2. 而对于边缘部分只要有一个0，该行、列全为0
3. 分成两份
   1. 边缘的信息总过两个flag标志进行存储
   2. 里面的内容覆盖边缘部分的信息
   3. 进行处理两部分

## [274. H 指数](https://leetcode.cn/problems/h-index/)

> 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。
>
> 根据维基百科上 h 指数的定义：h 代表“高引用次数”，一名科研人员的 h指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。
>
> 如果 h 有多种可能的值，h 指数 是其中最大的那个。
>
>  
>
> 示例 1：
>
> 输入：citations = [3,0,6,1,5]
> 输出：3 
> 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
>      由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
> 示例 2：
>
> 输入：citations = [1,3,1]
> 输出：1
>
> ![image-20220513222802649](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220513222802649.png)

```java
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);

        for (int i=0;i<citations.length/2;i++){
            int temp=citations[i];
            citations[i]=citations[citations.length-i-1];
            citations[citations.length-i-1]=temp;
        }

        int ans=0;
        int l=0,r=citations.length-1;
        while (l<=r){
            int mid=(l+r)>>>1;
            if(citations[mid]>=mid+1){
                l=mid+1;
                ans=mid+1;
            }else{
                r=mid-1;
            }
        }

        return ans;
    }
}
```

1. 右移运算符>>>:无符号右移运算符；>>时带符号的右移运算符

## 迪杰斯特拉算法

> BFS模板

```java
// 输入一棵多叉树的根节点，层序遍历这棵多叉树
void levelTraverse(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    int depth = 1;
    // 从上到下遍历多叉树的每一层
    while (!q.isEmpty()) {
        int sz = q.size();
        // 从左到右遍历每一层的每个节点
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            printf("节点 %s 在第 %s 层", cur, depth);

            // 将下一层节点放入队列
            for (TreeNode child : cur.children) {
                q.offer(child);
            }
        }
        depth++;
    }
}
```

> Dijkstra

```java
// 返回节点 from 到节点 to 之间的边的权重
int weight(int from, int to);

// 输入节点 s 返回 s 的相邻节点
List<Integer> adj(int s);

// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
int[] dijkstra(int start, List<Integer>[] graph) {
    // 图中节点的个数
    int V = graph.length;
    // 记录最短路径的权重，你可以理解为 dp table
    // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重
    int[] distTo = new int[V];
    // 求最小值，所以 dp table 初始化为正无穷
    Arrays.fill(distTo, Integer.MAX_VALUE);
    // base case，start 到 start 的最短距离就是 0
    distTo[start] = 0;

    // 优先级队列，distFromStart 较小的排在前面
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
        return a.distFromStart - b.distFromStart;
    });

    // 从起点 start 开始进行 BFS
    pq.offer(new State(start, 0));

    while (!pq.isEmpty()) {
        State curState = pq.poll();
        int curNodeID = curState.id;
        int curDistFromStart = curState.distFromStart;

        if (curDistFromStart > distTo[curNodeID]) {
            // 已经有一条更短的路径到达 curNode 节点了
            continue;
        }
        // 将 curNode 的相邻节点装入队列
        for (int nextNodeID : adj(curNodeID)) {
            // 看看从 curNode 达到 nextNode 的距离是否会更短
            int distToNextNode = distTo[curNodeID] + weight(curNodeID, nextNodeID);
            if (distTo[nextNodeID] > distToNextNode) {
                // 更新 dp table
                distTo[nextNodeID] = distToNextNode;
                // 将这个节点以及距离放入队列
                pq.offer(new State(nextNodeID, distToNextNode));
            }
        }
    }
    return distTo;
}
```

## [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

> 给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
>
> 示例 1：
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/xogrid.jpg)
>
> 输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
> 输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
> 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
> 示例 2：
>
> 输入：board = [["X"]]
> 输出：[["X"]]
>
>
> 提示：
>
> m == board.length
> n == board[i].length
> 1 <= m, n <= 200
> board[i][j] 为 'X' 或 'O'
>

### DFS

```java
class Solution {
    public void solve(char[][] board) {
        int m=board.length,n=board[0].length;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0||i==m-1||j==0||j==n-1){
                    if(board[i][j]=='O'){
                        dfs(board,i,j);
                    }
                }
            }
        }

        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]=='V'){
                    board[i][j]='O';
                }
                else if(board[i][j]=='O'){
                    board[i][j]='X';
                }
            }
        }

    }
    public void dfs(char[][] board,int i,int j){
        if(i<0||i>=board.length||j<0||j>=board[0].length||board[i][j]!='O'){
            return;
        }
        board[i][j]='V';
        dfs(board,i,j+1);
        dfs(board,i+1,j);
        dfs(board,i,j-1);
        dfs(board,i-1,j);
    }
}
```

1. 我发现可以反着想，不是想着到边缘，因为有的能到边缘，有的不能边缘，有这两种情况。但是我们可以反着想，假设他从边缘出发，讲遇到的处理掉就行，然后处理图中的内联通;

## [207. 课程表](https://leetcode.cn/problems/course-schedule/)

> 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
>
> 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。
>
> 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
> 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：true
> 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
> 示例 2：
>
> 输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
> 输出：false
> 解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
>
> ![image-20220516222518141](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220516222518141.png)

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> l=new ArrayList<>();
        for(int i=0;i<numCourses;i++){
            l.add(new ArrayList<>());
        }

        int[] flag=new int[numCourses];
        for(int[] i:prerequisites){
            l.get(i[0]).add(i[1]);
        }

        for(int i=0;i<numCourses;i++){
            if(!dfs(l,flag,i)) return false;
        }
        return true;
    }

    public boolean dfs(List<List<Integer>> l,int[] flag,int i){
        if(flag[i]==1) return false;
        if(flag[i]==2) return true;
        flag[i]=1;
        for (int temp:l.get(i)){
            if(!dfs(l,flag,temp)) return false;
        }
        flag[i]=2;
        return true;
    }
}
```

1. 解题关键：是否有环
2. 解决办法：建立一个flag标志数组
   1. 0代表未被访问问
   2. 1代表在访问的路径上
   3. 2代表已经访问过了

## [1905. 统计子岛屿](https://leetcode.cn/problems/count-sub-islands/)

> 给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。
>
> 如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。
>
> 请你返回 grid2 中 子岛屿 的 数目 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/06/10/test1.png)
>
> 输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
> 输出：3
> 解释：如上图所示，左边为 grid1 ，右边为 grid2 。
> grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png)
>
> 输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
> 输出：2 
>
> 解释：如上图所示，左边为 grid1 ，右边为 grid2 。
> grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。
>
>
> 提示：
>
> m == grid1.length == grid2.length
> n == grid1[i].length == grid2[i].length
> 1 <= m, n <= 500
> grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。

```java
class Solution {
    int count=0;
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int res=0;
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1){
                    count=1;
                    dfs(grid1,grid2,i,j);
                    res+=count;
                }
            }
        }
        return res;
    }
    public void dfs(int[][] g,int[][] land,int x,int y){
        if(x<0||x>=land.length||y<0||y>=land[0].length||land[x][y]==0){
            return;
        }
        land[x][y]=0;

        if(g[x][y]!=1) count=0;
        dfs(g,land,x,y+1);
        dfs(g,land,x+1,y);
        dfs(g,land,x,y-1);
        dfs(g,land,x-1,y);
    }
}
```

1. DFS
2. 他这个在判断是否相同时会产生一种布尔，判断是否越界时也会产生一种;因此我们采用无返回值的
3. 可以用count来作为是否越界的标志

## [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

> 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
>
>  
>
> 示例 1:
>
> ![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)
>
> 输入: [1,2,3,null,5,null,4]
> 输出: [1,3,4]
> 示例 2:
>
> 输入: [1,null,3]
> 输出: [1,3]
> 示例 3:
>
> 输入: []
> 输出: []
>
>
> 提示:
>
> 二叉树的节点个数的范围是 [0,100]
> -100 <= Node.val <= 100 

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> l=new ArrayList<>();
        Deque<TreeNode> q=new LinkedList<>();
        if(root==null) return l;
        q.offer(root);
        while (!q.isEmpty()){
            TreeNode temp=q.getLast();
            l.add(temp.val);
            q.clear();
            if(temp.left!=null){
                q.offer(temp.left);
            }
            if(temp.right!=null){
                q.offer(temp.right);
            }
        }
        return l;
    }
}
```

1. BFS直接找该层的最后一个节点

## 中序遍历

> 首先访问左子树、再访问根节点、右子树；得到的结果是有序的

## [99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/)

> 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg)
>
> 输入：root = [1,3,null,null,2]
> 输出：[3,1,null,null,2]
> 解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg)
>
>
> 输入：root = [3,1,4,null,null,2]
> 输出：[2,1,4,null,null,3]
> 解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
>
> ![image-20220520233232057](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220520233232057.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    TreeNode  ans1=null,ans2=null;
    TreeNode pre=new TreeNode(Integer.MIN_VALUE);
    public void recoverTree(TreeNode root) {
        //TreeNode  ans1=null,ans2=null;

        //TreeNode pre=new TreeNode(Integer.MIN_VALUE);
        dfs(root);

        int temp=ans1.val;
        ans1.val=ans2.val;
        ans2.val=temp;
    }
    public void dfs(TreeNode root){
        if(root==null) return;

        dfs(root.left);
        if(pre.val>root.val){
            if(ans1==null) ans1=pre;
            ans2=root;
        }
        pre=root;
        dfs(root.right);

    }
}
```

1. 中序遍历得到的序列是递增序列Ai>Bi；破坏后存在Ai<Bi
2. 找到第一个Ai和最后一个Bi
3. 

## [2105. 给植物浇水 II](https://leetcode.cn/problems/watering-plants-ii/)

> Alice 和 Bob 打算给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。
>
> 每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，最初是满的 。他们按下面描述的方式完成浇水：
>
>  Alice 按 从左到右 的顺序给植物浇水，从植物 0 开始。Bob 按 从右到左 的顺序给植物浇水，从植物 n - 1 开始。他们 同时 给植物浇水。
> 如果没有足够的水 完全 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。
> 不管植物需要多少水，浇水所耗费的时间都是一样的。
> 不能 提前重新灌满水罐。
> 每株植物都可以由 Alice 或者 Bob 来浇水。
> 如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。
> 给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有两个整数 capacityA 和 capacityB 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 次数 。
>
>  
>
> 示例 1：
>
> 输入：plants = [2,2,3,3], capacityA = 5, capacityB = 5
> 输出：1
> 解释：
> - 最初，Alice 和 Bob 的水罐中各有 5 单元水。
> - Alice 给植物 0 浇水，Bob 给植物 3 浇水。
> - Alice 和 Bob 现在分别剩下 3 单元和 2 单元水。
> - Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 2 ，所以他先重新装满水，再浇水。
> 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 0 = 1 。
> 示例 2：
>
> 输入：plants = [2,2,3,3], capacityA = 3, capacityB = 4
> 输出：2
> 解释：
> - 最初，Alice 的水罐中有 3 单元水，Bob 的水罐中有 4 单元水。
> - Alice 给植物 0 浇水，Bob 给植物 3 浇水。
> - Alice 和 Bob 现在都只有 1 单元水，并分别需要给植物 1 和植物 2 浇水。
> - 由于他们的水量均不足以浇水，所以他们重新灌满水罐再进行浇水。
> 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 1 + 1 + 0 = 2 。
> 示例 3：
>
> 输入：plants = [5], capacityA = 10, capacityB = 8
> 输出：0
> 解释：
> - 只有一株植物
> - Alice 的水罐有 10 单元水，Bob 的水罐有 8 单元水。因此 Alice 的水罐中水更多，她会给这株植物浇水。
> 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 。
>
> ![image-20220520213632618](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220520213632618.png)

```java
class Solution {
    public int minimumRefill(int[] plants, int capacityA, int capacityB) {
        int num_A=capacityA,num_B=capacityB;
        int l=0,r=plants.length-1;
        int ans=0;
        while (l<r){
            int num_l=plants[l];
            int num_r=plants[r];

            if(capacityA>=num_l){
                capacityA-=num_l;
            }else{
                capacityA=num_A-num_l;
                ans++;
            }

            if(capacityB>=num_r){
                capacityB-=num_r;
            }else{
                capacityB=num_B-num_r;
                ans++;
            }

            l++;
            r--;
        }
        if(plants.length%2==0) return ans;
        else{
            int max=Math.max(capacityA,capacityB);
            if(max<plants[plants.length/2]) return ans+1;
            else return ans;
        }
    }
}
```

## [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

> 现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。
>
> 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
> 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。
>
>  
>
> 示例 1：
>
> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：[0,1]
> 解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
> 示例 2：
>
> 输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
> 输出：[0,2,1,3]
> 解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
> 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
> 示例 3：
>
> 输入：numCourses = 1, prerequisites = []
> 输出：[0]
>
> 提示：
> 1 <= numCourses <= 2000
> 0 <= prerequisites.length <= numCourses * (numCourses - 1)
> prerequisites[i].length == 2
> 0 <= ai, bi < numCourses
> ai != bi
> 所有[ai, bi] 互不相同

```java
class Solution {
    List<List<Integer>> l=new ArrayList<>();
    int[] ans;
    int[] flag;
    boolean flag_t=false;
    int index;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        flag=new int[numCourses];
        ans=new int[numCourses];
        index=numCourses-1;

        for(int i=0;i<numCourses;i++){
            l.add(new ArrayList<>());
        }

        for(int[] i:prerequisites){
            l.get(i[0]).add(i[1]);
        }

        for(int i=0;i<numCourses&&!flag_t;i++){
            if(flag[i]==0){
                dfs(i);
            }
        }

        if(flag_t) return new int[0];

        for(int i=0;i<numCourses/2;i++){
            int temp=ans[i];
            ans[i]=ans[numCourses-i-1];
            ans[numCourses-i-1]=temp;
        }

        return ans;
    }
    public void dfs(int i){
        flag[i]=1;
        for(int temp:l.get(i)){
            if(flag[temp]==0){
                dfs(temp);
                if(flag_t){
                    return;
                }
            }else if(flag[temp]==1){
                flag_t=true;
                return;
            }
        }
        flag[i]=2;
        ans[index--]=i;
    }
}
```

1. 使用递归完成拓扑排序

## [6076. 表示一个折线图的最少线段数](https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/)

> 给你一个二维整数数组 stockPrices ，其中 stockPrices[i] = [dayi, pricei] 表示股票在 dayi 的价格为 pricei 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：
>
>
> 请你返回要表示一个折线图所需要的 最少线段数 。
>
>  <img src="https://assets.leetcode.com/uploads/2022/03/30/1920px-pushkin_population_historysvg.png" alt="img" style="zoom: 25%;" />
>
> 示例 1：
>
> <img src="https://assets.leetcode.com/uploads/2022/03/30/ex0.png" alt="img" style="zoom:25%;" />
>
> 输入：stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]
> 输出：3
> 解释：
> 上图为输入对应的图，横坐标表示日期，纵坐标表示价格。
> 以下 3 个线段可以表示折线图：
> - 线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。
> - 线段 2 （蓝色）从 (4,4) 到 (5,4) 。
> - 线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。
> 可以证明，无法用少于 3 条线段表示这个折线图。
> 示例 2：
>
> <img src="https://assets.leetcode.com/uploads/2022/03/30/ex1.png" alt="img" style="zoom:25%;" />
>
> 输入：stockPrices = [[3,4],[1,2],[7,8],[2,3]]
> 输出：1
> 解释：
> 如上图所示，折线图可以用一条线段表示。
>
> ![image-20220522212538946](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220522212538946.png)

```java
class Solution {
    public int minimumLines(int[][] stockPrices) {
        int ans=stockPrices.length-1;

        if(stockPrices.length==1) return 0;

        Arrays.sort(stockPrices,(a,b)->a[0]-b[0]);

        int pre_k1=(stockPrices[1][1]-stockPrices[0][1]);
        int pre_k2=(stockPrices[1][0]-stockPrices[0][0]);

        for(int i=2;i<stockPrices.length;i++){

            int temp_k1=stockPrices[i][1]-stockPrices[i-1][1];
            int temp_k2=stockPrices[i][0]-stockPrices[i-1][0];

            if(temp_k2*pre_k1==pre_k2*temp_k1){
                ans--;
            }

            pre_k1=temp_k1;
            pre_k2=temp_k2;
        }

        return ans;
    }
}
```

1. 斜率相同的交叉乘结果一样

## [6075. 装满石头的背包的最大数量](https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/)

> 现有编号从 0 到 n - 1 的 n 个背包。给你两个下标从 0 开始的整数数组 capacity 和 rocks 。第 i 个背包最大可以装 capacity[i] 块石头，当前已经装了 rocks[i] 块石头。另给你一个整数 additionalRocks ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。
>
> 请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量。
>
>  
>
> 示例 1：
>
> 输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2
> 输出：3
> 解释：
> 1 块石头放入背包 0 ，1 块石头放入背包 1 。
> 每个背包中的石头总数是 [2,3,4,4] 。
> 背包 0 、背包 1 和 背包 2 都装满石头。
> 总计 3 个背包装满石头，所以返回 3 。
> 可以证明不存在超过 3 个背包装满石头的情况。
> 注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。
> 示例 2：
>
> 输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100
> 输出：3
> 解释：
> 8 块石头放入背包 0 ，2 块石头放入背包 2 。
> 每个背包中的石头总数是 [10,2,2] 。
> 背包 0 、背包 1 和背包 2 都装满石头。
> 总计 3 个背包装满石头，所以返回 3 。
> 可以证明不存在超过 3 个背包装满石头的情况。
> 注意，不必用完所有的额外石头。
>
> ![image-20220522220652596](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220522220652596.png)

```java
class Solution {
    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {
        int[] array=new int[capacity.length];

        for(int i=0;i<capacity.length;i++){
            array[i]=capacity[i]-rocks[i];
        }

        Arrays.sort(array);

        int ans=0;
        int temp=0;
        while (additionalRocks>0&&temp<array.length){
            if(additionalRocks-array[temp]>=0){
                ans++;
            }else break;
            additionalRocks-=array[temp];
            temp++;
        }

        return ans;
    }
}
```

1. 这道题直接得到差值，每次减去差值最小的那个，就能得到最多的背包

## [6074. 字母在字符串中的百分比](https://leetcode.cn/problems/percentage-of-letter-in-string/)

> 给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。
>
>  
>
> 示例 1：
>
> 输入：s = "foobar", letter = "o"
> 输出：33
> 解释：
> 等于字母 'o' 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。
> 示例 2：
>
> 输入：s = "jjjj", letter = "k"
> 输出：0
> 解释：
> 等于字母 'k' 的字符在 s 中占到的百分比是 0% ，所以返回 0 。
>
>
> 提示：
>
> 1 <= s.length <= 100
> s 由小写英文字母组成
> letter 是一个小写英文字母

```java
class Solution {
    public int percentageLetter(String s, char letter) {
        int n=s.length();
        double ans=0;
        for(int i=0;i<n;i++){
            if(s.charAt(i)==letter) ans++;
        }
        return (int) ((double)(ans/n)*100);
    }
}
```

1. 用小数除去整数能得到小数

## [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

> 有 n 个网络节点，标记为 1 到 n。
>
> 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
>
> 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)
>
> 输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
> 输出：2
> 示例 2：
>
> 输入：times = [[1,2,1]], n = 2, k = 1
> 输出：1
> 示例 3：
>
> 输入：times = [[1,2,1]], n = 2, k = 2
> 输出：-1
>
>
> 提示：
>
> 1 <= k <= n <= 100
> 1 <= times.length <= 6000
> times[i].length == 3
> 1 <= ui, vi <= n
> ui != vi
> 0 <= wi <= 100
> 所有 (ui, vi) 对都 互不相同（即，不含重复边）

```java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        List<int[]>[] graph=new LinkedList[n+1];
        for(int i=1;i<=n;i++){
            graph[i]=new LinkedList<>();
        }
        for(int[] i:times){
            int from=i[0];
            int end=i[1];
            int weight=i[2];
            graph[from].add(new int[]{end,weight});
        }

        int[] ans=dijkstra(k,graph);

        int res=0;
        for(int i=1;i<graph.length;i++){
            if(ans[i]==Integer.MAX_VALUE){
                return -1;
            }
            res=Math.max(res,ans[i]);
        }

        return res;
    }

    class state{
        int id;
        int dist_from_end;
        public state(int id,int dist_from_end){
            this.id=id;
            this.dist_from_end=dist_from_end;
        }
    }

    public int[] dijkstra(int start,List<int[]>[] graph){
        int[] ans=new int[graph.length];
        Arrays.fill(ans,Integer.MAX_VALUE);
        ans[start]=0;

        Queue<state> q=new PriorityQueue<>((a,b)->a.dist_from_end- b.dist_from_end);
        q.offer(new state(start,0));
        while (!q.isEmpty()){
            state node=q.poll();
            int id=node.id;
            int dist=node.dist_from_end;

            if(dist>ans[id]) continue;

            for(int[] i:graph[id]){
                int next_node_id=i[0];
                int dist_to=i[1]+dist;

                if(ans[next_node_id]>dist_to){
                    ans[next_node_id]=dist_to;
                    q.offer(new state(next_node_id,dist_to));
                }
            }
        }

        return ans;
    }
}
```

## [133. 克隆图](https://leetcode.cn/problems/clone-graph/)

> 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
>
> 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。
>
> class Node {
>     public int val;
>     public List<Node> neighbors;
> }
>
>
> 测试用例格式：
>
> 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。
>
> 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。
>
> 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。
>
>  
>
> 示例 1：
>
> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" alt="img" style="zoom:25%;" />
>
> 输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
> 输出：[[2,4],[1,3],[2,4],[1,3]]
> 解释：
> 图中有 4 个节点。
> 节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
> 节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
> 节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
> 节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png)
>
> 输入：adjList = [[]]
> 输出：[[]]
> 解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
> 示例 3：
>
> 输入：adjList = []
> 输出：[]
> 解释：这个图是空的，它不含任何节点。
> 示例 4：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png)
>
> 输入：adjList = [[2],[1]]
> 输出：[[2],[1]]
>
>
> 提示：
>
> 节点数不超过 100 。
> 每个节点值 Node.val 都是唯一的，1 <= Node.val <= 100。
> 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。
> 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。
> 图是连通图，你可以从给定节点访问到所有节点。

```java
class Solution {
    HashMap<Node,Node> h=new HashMap<>();
    public Node cloneGraph(Node node) {
        if(node==null) return null;
        if(h.containsKey(node)){
            return h.get(node);
        }
        Node cur=new Node(node.val);
        h.put(node,cur);
        for(Node i:node.neighbors){
            cur.neighbors.add(cloneGraph(i));
        }

        return cur;
    }
}
```

## [2271. 毯子覆盖的最多白色砖块数](https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/)

> 给你一个二维整数数组 tiles ，其中 tiles[i] = [li, ri] ，表示所有在 li <= j <= ri 之间的每个瓷砖位置 j 都被涂成了白色。
>
> 同时给你一个整数 carpetLen ，表示可以放在 任何位置 的一块毯子。
>
> 请你返回使用这块毯子，最多 可以盖住多少块瓷砖。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2022/03/25/example1drawio3.png)
>
> 输入：tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10
> 输出：9
> 解释：将毯子从瓷砖 10 开始放置。
> 总共覆盖 9 块瓷砖，所以返回 9 。
> 注意可能有其他方案也可以覆盖 9 块瓷砖。
> 可以看出，瓷砖无法覆盖超过 9 块瓷砖。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2022/03/24/example2drawio.png)
>
> 输入：tiles = [[10,11],[1,1]], carpetLen = 2
> 输出：2
> 解释：将毯子从瓷砖 10 开始放置。
> 总共覆盖 2 块瓷砖，所以我们返回 2 。
>
> ![image-20220525215338751](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220525215338751.png)

```java
class Solution {
    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {
        Arrays.sort(tiles, (o1, o2) -> o1[0] - o2[0]);
        int n = tiles.length, l = 0, r = 0, sum = 0, max = 0;
        while (l <= r && r < n) {
            int left = tiles[l][0];
            int right = left + carpetLen - 1;
            if (tiles[r][1] <= right) {
                sum += tiles[r][1] - tiles[r][0] + 1;
                r++;
                max = Math.max(sum, max);
            } else {
                if (right >= tiles[r][0]) {
                    max = Math.max(sum + right - tiles[r][0] + 1, max);
                }
                sum -= tiles[l][1] - tiles[l][0] + 1;
                l++;
            }
        }

        return max;
    }
}
```

1. 滑动窗口+贪心

## [785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)

> 存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：
> 不存在自环（graph[u] 不包含 u）。
> 不存在平行边（graph[u] 不包含重复值）。
> 如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）
> 这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。
> 二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。
>
> 如果图是二分图，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg)
>
> 输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
> 输出：false
> 解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg)
>
>
> 输入：graph = [[1,3],[0,2],[1,3],[0,2]]
> 输出：true
> 解释：可以将节点分成两组: {0, 2} 和 {1, 3} 。
>
>
> 提示：
>
> graph.length == n
> 1 <= n <= 100
> 0 <= graph[u].length < n
> 0 <= graph[u][i] <= n - 1
> graph[u] 不会包含 u
> graph[u] 的所有值 互不相同
> 如果 graph[u] 包含 v，那么 graph[v] 也会包含 u

```java
class Solution {

    private boolean ok=true;
    private boolean[] color;
    private boolean[] visited;

    public boolean isBipartite(int[][] graph) {
        int n=graph.length;
        color=new boolean[n];
        visited=new boolean[n];

        for(int v=0;v<n;v++){
            if(!visited[v]){
                dfs(graph,v);
            }
        }

        return ok;
    }

    public void dfs(int[][] graph,int v){
        if(!ok) return;

        visited[v]=true;
        for(int i:graph[v]){
            if(!visited[i]){
                color[i]=!color[v];
                dfs(graph,i);
            }else {
                if(color[v]==color[i]){
                    ok=false;
                }
            }
        }
    }
}
```

1. 能否使一条边的两点颜色不同

2. **二分图：**

   二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。

   简单的说，一个图被分成了两部分，相同的部分没有边，那这个图就是二分图，二分图是特殊的图。

## [675. 为高尔夫比赛砍树](https://leetcode.cn/problems/cut-off-trees-for-golf-event/)

> 你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：
>
> 0 表示障碍，无法触碰
> 1 表示地面，可以行走
> 比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度
> 每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。
>
> 你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。
>
> 你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。
>
> 可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。
>
> 
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg)
>
> 输入：forest = [[1,2,3],[0,0,4],[7,6,5]]
> 输出：6
> 解释：沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg)
>
> 输入：forest = [[1,2,3],[0,0,0],[7,6,5]]
> 输出：-1
> 解释：由于中间一行被障碍阻塞，无法访问最下面一行中的树。
> 示例 3：
>
> 输入：forest = [[2,3,4],[0,0,5],[8,7,6]]
> 输出：6
> 解释：可以按与示例 1 相同的路径来砍掉所有的树。
> (0,0) 位置的树，可以直接砍去，不用算步数。
>
> ![image-20220707000006582](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220707000006582.png)

```java
class Solution {
    int[] dx = new int[]{0, 1, 0, -1};
    int[] dy = new int[]{1, 0, -1, 0};

    public int cutOffTree(List<List<Integer>> forest) {
        int ans = 0;
        List<int[]> l = new ArrayList<>();
        for (int i = 0; i < forest.size(); i++) {
            for (int j = 0; j < forest.get(0).size(); j++) {
                if (forest.get(i).get(j) > 1) l.add(new int[]{i, j});
            }
        }

        Collections.sort(l, (a, b) -> forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1]));

        int cx = 0, cy = 0;
        for (int i = 0; i < l.size(); i++) {
            int step = bfs(forest, cx, cy, l.get(i)[0], l.get(i)[1]);

            if (step == -1) return -1;

            cx = l.get(i)[0];
            cy = l.get(i)[1];

            ans += step;
        }

        return ans;
    }

    private int bfs(List<List<Integer>> forest, int cx, int cy, int tx, int ty) {
        if (cx == tx && cy == ty) {
            return 0;
        }

        int step = 0;
        Queue<int[]> q = new ArrayDeque<>();
        boolean[][] flag = new boolean[forest.size()][forest.get(0).size()];
        q.offer(new int[]{cx, cy});
        while (!q.isEmpty()) {
            step++;
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int[] ceil = q.poll();
                for (int j = 0; j < 4; j++) {
                    int x = ceil[0] + dx[j];
                    int y = ceil[1] + dy[j];
                    if (x >= 0 && x < forest.size() && y >= 0 && y < forest.get(0).size()) {
                        if (!flag[x][y] && forest.get(x).get(y) > 0) {
                            if (x == tx && y == ty) {
                                return step;
                            }
                            q.offer(new int[]{x, y});
                            flag[x][y] = true;
                        }
                    }
                }
            }
        }
        return -1;
    }
}
```

1. 排序+bfs

## [LCP 42. 玩具套圈](https://leetcode.cn/problems/vFjcfV/)

> 「力扣挑战赛」场地外，小力组织了一个套玩具的游戏。所有的玩具摆在平地上，toys[i] 以 [xi,yi,ri] 的形式记录了第 i 个玩具的坐标 (xi,yi) 和半径 ri。小扣试玩了一下，他扔了若干个半径均为 r 的圈，circles[j] 记录了第 j 个圈的坐标 (xj,yj)。套圈的规则如下：
>
> 若一个玩具被某个圈完整覆盖了（即玩具的任意部分均在圈内或者圈上），则该玩具被套中。
> 若一个玩具被多个圈同时套中，最终仅计算为套中一个玩具
> 请帮助小扣计算，他成功套中了多少玩具。
>
> 注意：
>
> 输入数据保证任意两个玩具的圆心不会重合，但玩具之间可能存在重叠。
> 示例 1：
>
> ![image.png](https://pic.leetcode-cn.com/1629194140-ydKiGF-image.png)
>
> 输入：toys = [[3,3,1],[3,2,1]], circles = [[4,3]], r = 2
>
> 输出：1
>
> 解释： 如图所示，仅套中一个玩具
>
> 示例 2：
>
> ![image.png](https://pic.leetcode-cn.com/1629194157-RiOAuy-image.png)
>
> 输入：toys = [[1,3,2],[4,3,1],[7,1,2]], circles = [[1,0],[3,3]], r = 4
>
> 输出：2
>
> 解释： 如图所示，套中两个玩具
>
>
> 提示：
>
> 1 <= toys.length <= 10^4
> 0 <= toys[i][0], toys[i][1] <= 10^9
> 1 <= circles.length <= 10^4
> 0 <= circles[i][0], circles[i][1] <= 10^9
> 1 <= toys[i][2], r <= 10

```java
class Solution {
    public int circleGame(int[][] toys, int[][] circles, int r) {
        int sum = 0;
        for(int i = 0; i < toys.length; i++) {
            if(r<toys[i][2])
                continue;
            for (int j = 0; j < circles.length; j++) {
                long d=1l*(toys[i][0]-circles[j][0])*(toys[i][0]-circles[j][0])+1l*(toys[i][1]-circles[j][1])*(toys[i][1]-circles[j][1]);
                if(d<=(r-toys[i][2])*(r-toys[i][2]))
                { 
                    sum++;
                    break;
                }
            }
        }
        return sum;
    }
}
```

1. ![image-20220728012211637](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220728012211637.png)
2. [链接](https://baike.baidu.com/item/%E5%9C%86%E7%9A%84%E6%A0%87%E5%87%86%E6%96%B9%E7%A8%8B/3723940)
2. Math中sqrt函数的时间复杂度（O(logn)）
2. Pow(x, n)---时间复杂度O(logN)

## [1402. 做菜顺序](https://leetcode.cn/problems/reducing-dishes/)

> 一个厨师收集了他 n 道菜的满意程度 satisfaction ，这个厨师做出每道菜的时间都是 1 单位时间。
>
> 一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 time[i]*satisfaction[i] 。
>
> 请你返回做完所有菜 「喜爱时间」总和的最大值为多少。
>
> 你可以按 任意 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。
>
>  
>
> 示例 1：
>
> 输入：satisfaction = [-1,-8,0,5,-9]
> 输出：14
> 解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。
> 示例 2：
>
> 输入：satisfaction = [4,3,2]
> 输出：20
> 解释：按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)
> 示例 3：
>
> 输入：satisfaction = [-1,-4,-5]
> 输出：0
> 解释：大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。
>
>
> 提示：
>
> n == satisfaction.length
> 1 <= n <= 500
> -1000 <= satisfaction[i] <= 1000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/reducing-dishes
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maxSatisfaction(int[] satisfaction) {
        int pre_sum=0,ans=0,n=satisfaction.length;
        Arrays.sort(satisfaction);
        for(int i=n-1;i>=0;i--){
            int num=satisfaction[i];
            if(pre_sum+num>0){
                pre_sum+=num;
                ans+=pre_sum;
            }else break;
        }

        return ans;
    }
}
```

1. 贪心

2. ```java
   s0>0
   s1+2s0>s0
   s2+2S1+3s0>s1+2s
   ```

3. 

##  [335. 路径交叉](https://leetcode.cn/problems/self-crossing/)
> 给你一个整数数组 distance 。
>
> 从 X-Y 平面上的点 (0,0) 开始，先向北移动 distance[0] 米，然后向西移动 distance[1] 米，向南移动 distance[2] 米，向东移动 distance[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。
>
> 判断你所经过的路径是否相交。如果相交，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg)
>
> 输入：distance = [2,1,1,2]
> 输出：true
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross2-plane.jpg)
>
> 输入：distance = [1,2,3,4]
> 输出：false
> 示例 3：
>
> ![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross3-plane.jpg)
>
>
> 输入：distance = [1,1,1,1]
> 输出：true
>
>
> 提示：
>
> 1 <= distance.length <= 105
> 1 <= distance[i] <= 105
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/self-crossing
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean isSelfCrossing(int[] distance) {
        int n=distance.length;
        if(n<4) return false;
        int i=2;

        while (i<n&&distance[i]>distance[i-2]) i++;
        if(i==n) return false;

        if(distance[i]>=distance[i-2]-(i<4?0:distance[i-4])){
            distance[i-1]-=i<3?0:distance[i-3];
        }
        
        for(++i;i<n&&distance[i]<distance[i-2];i++);
        
        return i==n?false:true;
    }
}
```

1. ![image-20220902082720666](https://cdn.jsdelivr.net/gh/yzk656/image/202212090022423.png)

## [1780. 判断一个数字是否可以表示成三的幂的和](https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/)

> 给你一个整数 n ，如果你可以将 n 表示成若干个不同的三的幂之和，请你返回 true ，否则请返回 false 。
>
> 对于一个整数 y ，如果存在整数 x 满足 y == 3x ，我们称这个整数 y 是三的幂。
>
>  
>
> 示例 1：
>
> 输入：n = 12
> 输出：true
> 解释：12 = 31 + 32
> 示例 2：
>
> 输入：n = 91
> 输出：true
> 解释：91 = 30 + 32 + 34
> 示例 3：
>
> 输入：n = 21
> 输出：false
>
>
> 提示：
>
> 1 <= n <= 107
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean checkPowersOfThree(int n) {
        while (n!=0){
            if(n%3==2){
                return false;
            }
            n/=3;
        }
        
        return true;
    }
}
```

1.  将一个数转换成三进制，可以由0、1、2组成，2无法用3的幂次方表示出来，余数为2说明转换不了



# LCP

## [LCP 12. 小张刷题计划](https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua/)

> 为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题，编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。
>
> 在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。
>
> 我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。
>
> 示例 1：
>
> 输入：time = [1,2,3,3], m = 2
>
> 输出：3
>
> 解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。
>
> 示例 2：
>
> 输入：time = [999,999,999], m = 4
>
> 输出：0
>
> 解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。
>
>  
>
> 限制：
>
> 1 <= time.length <= 10^5
> 1 <= time[i] <= 10000
> 1 <= m <= 1000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int minTime(int[] time, int m) {
        int len=time.length;//获得长度
        if(len<=m) return 0;//如果天数比给的长，就返回0

        int l=1,r=(int) 1e9;//定义左右边界
        int ans=0;//存放结果
        while (l<=r){
            int mid=l+((r-l)>>1);//+的优先级比>>高
            int take=1;//对于当前一天得工作量所花费的时间天数
            int sum=0,max=0;//存放一天花费得时间和最大值
            boolean delete=true;//判断是否已经使用了特权
            for(int i=0;i<len;){
                int t=time[i];//记录当前题目需要花费得时间
                sum+=t;//将时间放进总和里面
                max=Math.max(max,t);//在一天所做的题目中寻找这些题目当中的最大值
                if(sum>mid){//如果所花费的时间超出了所猜测的时间，就进行删除最大值
                    if(delete){
                        sum-=max;
                        delete=false;
                        i++;
                    }else {//如果之前进行删除过，就进行重置
                        sum=0;
                        delete=true;
                        max=0;
                        take++;
                    }
                }else {
                    i++;
                }
            }
            if(take<=m){//如果花费的天数小于规定得天数，就减少一天的工作量
                ans=mid;
                r=mid-1;
            }else {//否则就增加工作量
                l=mid+1;
            }
        }

        return ans;
    }
}
```

## [LCP 03. 机器人大冒险](https://leetcode.cn/problems/programmable-robot/)

> 力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：
>
> U: 向y轴正方向移动一格
> R: 向x轴正方向移动一格。
> 不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。
>
> 给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。
>
>  
>
> 示例 1：
>
> 输入：command = "URR", obstacles = [], x = 3, y = 2
> 输出：true
> 解释：U(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)。
> 示例 2：
>
> 输入：command = "URR", obstacles = [[2, 2]], x = 3, y = 2
> 输出：false
> 解释：机器人在到达终点前会碰到(2, 2)的障碍物。
> 示例 3：
>
> 输入：command = "URR", obstacles = [[4, 2]], x = 3, y = 2
> 输出：true
> 解释：到达终点后，再碰到障碍物也不影响返回结果。
>
>
> 限制：
>
> 2 <= command的长度 <= 1000
> command由U，R构成，且至少有一个U，至少有一个R
> 0 <= x <= 1e9, 0 <= y <= 1e9
> 0 <= obstacles的长度 <= 1000
> obstacles[i]不为原点或者终点
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/programmable-robot
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean robot(String command, int[][] obstacles, int x, int y) {
        int n=command.length();//记录指令长度
        int sx=0,sy=0;//当前位置
        for(int i=0;i<n;i++){
            char c=command.charAt(i);
            if(c=='U') ++sy;//如果向上，当前y+1
            else ++sx;//当前x+1
        }

        boolean can_finish=can_reach(command,x,y,sx,sy);//假设没有障碍物
        if(!can_finish) return false;//如果不能走到，直接不能直接返回false
        for(int[] i:obstacles){
            if(i[0]>x||i[1]>y) continue;
            if(can_reach(command,i[0],i[1],sx,sy)) return false;//r如果能走到障碍物，就返回false
        }

        return true;//不会出现任何差错，返回true
    }

    public boolean can_reach(String cmd,int tx,int ty,int x,int y){
        int round=Math.min(tx/x,ty/y);//得到需要走几倍的x，y
        int nx=round*x,ny=round*y;//获得当前整数的位置
        if(nx==tx&&ny==ty) return true;
        int n=cmd.length();
        for(int i=0;i<n;i++){
            char c=cmd.charAt(i);
            if(c=='U') ++ny;
            else ++nx;
            if(nx>tx||ny>ty) return false;
            if(nx==tx&&ny==ty) return true;
        }

        return true;
    }
}
```

## [LCP 08. 剧情触发时间](https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian/)

> 在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。
>
> 随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 increase 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 [[1,2,1],[3,4,2]] 表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。
>
> 所有剧情的触发条件也用一个二维数组 requirements 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 c[i], r[i], h[i]，如果当前 C >= c[i] 且 R >= r[i] 且 H >= h[i] ，则剧情会被触发。
>
> 根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。
>
> 示例 1：
>
> 输入： increase = [[2,8,4],[2,5,0],[10,9,8]] requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]]
>
> 输出: [2,-1,3,-1]
>
> 解释：
>
> 初始时，C = 0，R = 0，H = 0
>
> 第 1 天，C = 2，R = 8，H = 4
>
> 第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0
>
> 第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2
>
> 剧情 1 和 3 无法触发。
>
> 示例 2：
>
> 输入： increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]] requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]]
>
> 输出: [-1,4,3,3,3]
>
> 示例 3：
>
> 输入： increase = [[1,1,1]] requirements = [[0,0,0]]
>
> 输出: [0]
>
> 限制：
>
> 1 <= increase.length <= 10000
> 1 <= requirements.length <= 100000
> 0 <= increase[i] <= 10
> 0 <= requirements[i] <= 100000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int[] getTriggerTime(int[][] increase, int[][] requirements) {
        int n = increase.length, m = requirements.length;
        int[] ans = new int[m];
        //求前缀和
        for (int i = 1; i < n; i++) {
            increase[i][0] += increase[i - 1][0];
            increase[i][1] += increase[i - 1][1];
            increase[i][2] += increase[i - 1][2];
        }

        for (int i = 0; i < m; i++) {
            int c = requirements[i][0], r = requirements[i][1], h = requirements[i][2];
            if (c == 0 && r == 0 && h == 0) {
                ans[i] = 0;
            } else {
                int left = 0;
                int right = n - 1;
                while (left <= right) {
                    int mid = left + (right - left) / 2;
                    if (increase[mid][0] < requirements[i][0] || increase[mid][1] < requirements[i][1] || increase[mid][2] < requirements[i][2]) {
                        left=mid+1;
                    }else {
                        right=mid-1;
                    }
                }
                if(left<increase.length&&increase[left][0]>=requirements[i][0]&&increase[left][1]>=requirements[i][1]&&increase[left][2]>=requirements[i][2]){
                    ans[i]=left+1;
                }else {
                    ans[i]=-1;
                }
            }
        }
        return ans;
    }
}
```

1. LinkedHashMap

## [LCP 41. 黑白翻转棋](https://leetcode.cn/problems/fHi6rV/)

> 在 n*m 大小的棋盘中，有黑白两种棋子，黑棋记作字母 "X", 白棋记作字母 "O"，空余位置记作 "."。当落下的棋子与其他相同颜色的棋子在行、列或对角线完全包围（中间不存在空白位置）另一种颜色的棋子，则可以翻转这些棋子的颜色。
>
> <img src="https://pic.leetcode-cn.com/1630396029-eTgzpN-6da662e67368466a96d203f67bb6e793.gif" alt="1.gif" style="zoom:25%;" />
>
> <img src="https://pic.leetcode-cn.com/1630396240-nMvdcc-8e4261afe9f60e05a4f740694b439b6b.gif" alt="2.gif" style="zoom:25%;" />
>
> <img src="https://pic.leetcode-cn.com/1630396291-kEtzLL-6fcb682daeecb5c3f56eb88b23c81d33.gif" alt="3.gif" style="zoom:25%;" />
>
> 「力扣挑战赛」黑白翻转棋项目中，将提供给选手一个未形成可翻转棋子的棋盘残局，其状态记作 chessboard。若下一步可放置一枚黑棋，请问选手最多能翻转多少枚白棋。
>
> 注意：
>
> 若翻转白棋成黑棋后，棋盘上仍存在可以翻转的白棋，将可以 继续 翻转白棋
> 输入数据保证初始棋盘状态无可以翻转的棋子且存在空余位置
> 示例 1：
>
> 输入：chessboard = ["....X.","....X.","XOOO..","......","......"]
>
> 输出：3
>
> 解释：
> 可以选择下在 [2,4] 处，能够翻转白方三枚棋子。
>
> 示例 2：
>
> ![2126c1d21b1b9a9924c639d449cc6e65.gif](https://pic.leetcode-cn.com/1626683255-OBtBud-2126c1d21b1b9a9924c639d449cc6e65.gif)
>
> 输入：chessboard = [".X.",".O.","XO."]
>
> 输出：2
>
> 解释：
> 可以选择下在 [2,2] 处，能够翻转白方两枚棋子。
>
>
> 示例 3：
>
> 输入：chessboard = [".......",".......",".......","X......",".O.....","..O....","....OOX"]
>
> 输出：4
>
> ![803f2f04098b6174397d6c696f54d709.gif](https://pic.leetcode-cn.com/1630393770-Puyked-803f2f04098b6174397d6c696f54d709.gif)
>
> 解释：
> 可以选择下在 [6,3] 处，能够翻转白方四枚棋子。
>
>
> 提示：
>
> 1 <= chessboard.length, chessboard[i].length <= 8
> chessboard[i] 仅包含 "."、"O" 和 "X"
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/fHi6rV
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int[] dx = new int[]{-1, -1, 0, 1, 1, 1, 0, -1};//行变量
    int[] dy = new int[]{0, 1, 1, 1, 0, -1, -1, -1};//列变量
    int n, m;//行数、列数

    public int flipChess(String[] chessboard) {
        n = chessboard.length;
        m = chessboard[0].length();
        char[][] board = copy_board(chessboard);//将字符串数组转换成二维数组

        int ans = 0;//存放的结果
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == '.') {//如果当前为空格，说明当前节点可以放置
                    char[][] copy = copy_board(chessboard);//对于每个节点的尝试，都是从源数组出发进行的
                    copy[i][j] = 'X';//将当前空格赋值为“黑棋子”
                    int cnt = process(copy, i, j);//对于在当前空格放置黑棋子，所能翻转的白棋子个数
                    ans=Math.max(ans,cnt);//更新最大值
                }
            }
        }

        return ans;
    }

    public char[][] copy_board(String[] chessboard) {//将字符串数组转换成二维字符数组
        char[][] board = new char[n][m];
        int idx = 0;

        for (String i : chessboard) {
            board[idx++] = i.toCharArray();
        }

        return board;
    }

    public int process(char[][] arr, int x, int y) {
        LinkedList<Integer> q = new LinkedList<>();//存放更新得到的黑棋子位置

        for (int i = 0; i < 8; i++) {//向四周扩散
            int new_x = x + dx[i];
            int new_y = y + dy[i];
            q.addAll(search(arr, new_x, new_y, dx[i], dy[i]));//获得从当前方向所新更新的黑子
        }

        int ans=q.size();
        while (!q.isEmpty()){//对于每个新新黑点都进行bfs，每次返回对于当前节点所找到的新黑子
            int pos=q.poll();
            ans+=process(arr,pos/10,pos%10);
        }

        return ans;//返回最终结果
    }

    public LinkedList<Integer> search(char[][] arr, int x, int y, int step_x, int step_y) {
        LinkedList<Integer> queue = new LinkedList<>();//存放新更新为黑点的位置
        boolean flag = false;//是否满足更新条件

        while (check(x, y)) {//判断是否在图内
            if(arr[x][y]!='O'){//如果当前节点不是白棋子，说明遇到了空格或者黑子
                flag=arr[x][y]=='X';
                break;
            }else{
                queue.add(x*10+y);//将位置转换成数组放进链表中
                arr[x][y]='X';//将白子置为黑子
            }

            x+=step_x;//更新位置
            y+=step_y;
        }
        if(!flag){//如果不满足更新条件，再退回变色
            while (!queue.isEmpty()){
                int temp1=queue.poll();
                arr[temp1/10][temp1%10]='O';
            }
        }

        return queue;//满足变色条件，将路上的白子置为黑子，同时将新更新的黑子放进链表中，作为下一次起点
    }

    public boolean check(int x, int y) {//判断是否在图内
        return x >= 0 && x < n && y >= 0 && y < m;
    }
}
```

## [LCP 30. 魔塔游戏](https://leetcode.cn/problems/p0NxJO/)

小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。每个房间的补血道具/怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。

小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。

示例 1：

输入：nums = [100,100,100,-250,-60,-140,-50,-50,100,150]

输出：1

解释：初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求。

示例 2：

输入：nums = [-200,-300,400,0]

输出：-1

解释：调整访问顺序也无法完成全部房间的访问。

提示：

1 <= nums.length <= 10^5
-10^5 <= nums[i] <= 10^5

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/p0NxJO
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int magicTower(int[] nums) {
        int sum=0,n=nums.length;//计算访问所有房间后，剩余的血量
        for(int i=0;i<n;i++)
            sum+=nums[i];
        if(sum+1<=0) return -1;//如果血量小于等于0，返回-1

        PriorityQueue<Integer> priorityQueue=new PriorityQueue<>();//存放负数
        int ans=0;//存放结果
        long blood=1;//存放当前血量
        for(int i=0;i<n;i++){//遍历每一个房间
            int num=nums[i];
            if(num>=0){//如果是加血，就直接添加血量
                blood+=num;
            }else {
                priorityQueue.offer(num);//否则的话，就将其加入到队列中
                if(blood+num<=0){//判断血量是否见底
                    ans++;//见底的话，就将该房间移到最后访问
                    blood-=priorityQueue.poll();//之前扣最多血量那个就先不扣了，把之前的返还回来
                }
                blood+=num;//扣现在这个
            }
        }

        return ans;
    }
}
```

## [2382. 删除操作后的最大子段和](https://leetcode.cn/problems/maximum-segment-sum-after-removals/)

> 给你两个下标从 0 开始的整数数组 nums 和 removeQueries ，两者长度都为 n 。对于第 i 个查询，nums 中位于下标 removeQueries[i] 处的元素被删除，将 nums 分割成更小的子段。
>
> 一个 子段 是 nums 中连续 正 整数形成的序列。子段和 是子段中所有元素的和。
>
> 请你返回一个长度为 n 的整数数组 answer ，其中 answer[i]是第 i 次删除操作以后的 最大 子段和。
>
> 注意：一个下标至多只会被删除一次。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]
> 输出：[14,7,2,2,0]
> 解释：用 0 表示被删除的元素，答案如下所示：
> 查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。
> 查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。
> 查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。
> 查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。
> 查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。
> 所以，我们返回 [14,7,2,2,0] 。
> 示例 2：
>
> 输入：nums = [3,2,11,1], removeQueries = [3,2,1,0]
> 输出：[16,5,3,0]
> 解释：用 0 表示被删除的元素，答案如下所示：
> 查询 1 ：删除第 3 个元素，nums 变成 [3,2,11,0] ，最大子段和为子段 [3,2,11] 的和 16 。
> 查询 2 ：删除第 2 个元素，nums 变成 [3,2,0,0] ，最大子段和为子段 [3,2] 的和 5 。
> 查询 3 ：删除第 1 个元素，nums 变成 [3,0,0,0] ，最大子段和为子段 [3] 的和 3 。
> 查询 5 ：删除第 0 个元素，nums 变成 [0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。
> 所以，我们返回 [16,5,3,0] 。
>
>
> 提示：
>
> n == nums.length == removeQueries.length
> 1 <= n <= 105
> 1 <= nums[i] <= 109
> 0 <= removeQueries[i] < n
> removeQueries 中所有数字 互不相同 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-segment-sum-after-removals
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int[] f;
    int n;
    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {
        n=nums.length;//获得原数组长度
        f=new int[n+1];//创建父亲数组
        long[] sum=new long[n+1];//创建求和数组
        init();//并查集初始化

        long[] ans=new long[n];//创建结果数组
        for(int i=n-1;i>0;--i){
            int x=removeQueries[i];//获得当前元素[连接点]
            int to=find(x+1);//获得当前位置的下一个元素的祖先
            f[x]=to;//将其加入到集合中
            sum[to]+=sum[x]+nums[x];//合并集合，右边集合的值更新
            ans[i-1]=Math.max(ans[i],sum[to]);//最后一位肯定是0，可
        }

        return ans;
    }

    public void init(){
        for(int i=1;i<=n;i++)
            f[i]=i;
    }

    public int find(int x){
        if(f[x]!=x) f[x]=find(f[x]);
        return f[x];
    }
}
```





# 字符串

## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n=s.length();
        int ans=0;
        Map<Character,Integer> map=new HashMap<Character,Integer>();
        for(int left=0,right=0;right<n;right++){
            char c=s.charAt(right);
            if(map.containsKey(c)){
                left=Math.max(map.get(c)+1,left);
            }
            ans=Math.max(ans,right-left+1);
            map.put(c,right);
        }
        return ans;
    }
}
```

1. 用哈希表来存，键：字符，值：下标
2. 主要靠两个指针来进行遍历
3. 如果该字符有了【用containsKey方法来判断】就判断是该字符重复的位置在哪，【因为重复的字符可能不在最左边】，left=重复值下标的后一个
4. 判断改长度是否大于之前的长度
5. 如果该字符没有，就把该字符存入哈希表

## [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

> 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
>
> 比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：
>
> P   A   H   N
> A P L S I I G
> Y   I   R
>
> 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。
>
> 请你实现这个将字符串进行指定行数变换的函数：
>
> string convert(string s, int numRows);
>
> 
>
> 示例 1：
>
> 输入：s = "PAYPALISHIRING", numRows = 3
> 输出："PAHNAPLSIIGYIR"
>
> 示例 2：
>
> 输入：s = "PAYPALISHIRING", numRows = 4
> 输出："PINALSIGYAHRPI"
> 解释：
> P     I    N
> A   L S  I G
> Y A   H R
> P     I
>
> 示例 3：
>
> 输入：s = "A", numRows = 1
> 输出："A"

```java
class Solution {
    public String convert(String s, int numRows) {
        int n=s.length();
        if(numRows==1) return s;
        String[] s1=new String[numRows];
        Arrays.fill(s1,"");
        char[] s2=s.toCharArray();
        
        int t=2*numRows-2;
        
        for(int i=0;i<s.length();i++){
            int temp=i%t;
            if(temp<numRows){
                s1[temp]+=s.charAt(i);
            }
            else{
                s1[t-temp]+=s.charAt(i);
            }
        }
        StringBuilder ans=new StringBuilder();
        for(String str:s1){
            ans.append(str);
        }
        return ans.toString();
    }
}
```

1. 如果只有一行，把该数据输出就行
2. 找到周期：周期等于行数减去两头的，所以t=row*2-2
3. 遍历每个周期，把该行的数据拼接到该行的字符串上【字符串数组相当于二维数组】
4. 若行数为3【下标为2】，周期为4时，对于第四个可以用4-2=2【相当于剩余几个数】，因为i是从0开始的，因此temp最大是5。对于为什么用t-temp：比如说i从0开始的，少的那个1正好补了下一列中的第一行不在周期范围内，此时t-temp正好可以看作剩余几个，结果正好比正常从1开始的数字少1，正好可以放在索引从0开始的数组中
5. 利用StringBuilder的append方法，将字符串数组连接到一起
6. 通过StringBuilder的toString方法，将格式转换成String类型

## [12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)

> 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
>
> 字符          数值
> I             1
> V             5
> X             10
> L             50
> C             100
> D             500
> M             1000
>
> 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
>
> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
>
>  I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
>  X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
>  C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
>
> 给你一个整数，将其转为罗马数字。
>
> 
>
> 示例 1:
>
> 输入: num = 3
> 输出: "III"
>
> 示例 2:
>
> 输入: num = 4
> 输出: "IV"
>
> 示例 3:
>
> 输入: num = 9
> 输出: "IX"
>
> 示例 4:
>
> 输入: num = 58
> 输出: "LVIII"
> 解释: L = 50, V = 5, III = 3.
>
> 示例 5:
>
> 输入: num = 1994
> 输出: "MCMXCIV"
> 解释: M = 1000, CM = 900, XC = 90, IV = 4.
>
> ```
> 1 <= num <= 3999
> ```

```java
class Solution {
    public String intToRoman(int num) {
        String[] g=new String[]{"","I","II","III","IV","V","VI","VII","VIII","IX"};
        String[] s=new String[]{"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};
        String[] b=new String[]{"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};
        String[] q=new String[]{"","M","MM","MMM"};
        return q[num/1000%10]+b[num/100%10]+s[num/10%10]+g[num%10];
    }
}
```

1. 将每位所对应的数列出来，然后字符串拼接起来

## [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)
>
> 示例 1：
>
> 输入：digits = "23"
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
>
> 示例 2：
>
> 输入：digits = ""
> 输出：[]
>
> 示例 3：
>
> 输入：digits = "2"
> 输出：["a","b","c"]
>
> 
>
> 提示：
>
>  0 <= digits.length <= 4
>  digits[i] 是范围 ['2', '9'] 的一个数字。
>

```java
class Solution {
    
    List<String> ans=new ArrayList<>();
    String[] array=new String[]{"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    
    public List<String> letterCombinations(String digits) {
        int len=digits.length();
        if(len==0) return ans;
        dfs(new StringBuilder(),digits);
        return ans;
    }
    
    private void dfs(StringBuilder s1,String digits){
        if(s1.length()==digits.length()){
            ans.add(s1.toString());
            return;
        }
        String s2=array[digits.charAt(s1.length())-'0'];
        for(char c:s2.toCharArray()){
            s1.append(c);
            dfs(s1,digits);
            s1.deleteCharAt(s1.length()-1);
        }
    } 
}
```

1. 深度优先搜索
2. 通过StringBuilder类对象进行连接
3. 如果Stringbuilder类对象的长度等于源数组长度的，就把该路径上生成的对象放进ans字符串链表中
4. 对于第一个数的的数组的获得可以通过当前StringBuilder类对象的长度去获取当前位置的字符数字，然后减去字符‘0’，得到的差值，根据差值就可以找到字符串
4. 遍历该字符串【由于字符串不能使用增强for，因此需要调用StringBuilder类的toCharArray方法，将其转换成字符数组】，分别处理加上该字符，不加上该字符的情况，如果要删除该字符，需要调用StringBuilder类对象的deleteCharAt方法，可以删除字符串指定位置的的字符
4. StringBuilder类的toString方法可以把StringBuilder类对象转换成String类对象

## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

> 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
>
> 路径和 是路径中各节点值的总和。
>
> 给你一个二叉树的根节点 root ，返回其 最大路径和 。
>
> 
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)
>
> 输入：root = [1,2,3]
> 输出：6
> 解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)
>
> 输入：root = [-10,9,20,null,null,15,7]
> 输出：42
> 解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
>
>
> 提示：
>
> 树中节点数目范围是 [1, 3 * 104]
> -1000 <= Node.val <= 1000

```java
class Solution {
    int ans=Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }
    private int dfs(TreeNode root){
        if(root==null) return 0;
        int left=Math.max(0,dfs(root.left));
        int right=Math.max(0,dfs(root.right));
        ans=Math.max(ans,left+right+root.val);
        return Math.max(left,right)+root.val;
    }
}
```

1. `递归调用`
2. 如果该节点为空，就退出该次搜索
3. 左子树节点的最大值为Math.max(left,right)+root.val;【左子树左、右子节点中的最大值+当前节点的值，然后与0进行比较】
4. 右子树节点最大值同理
5. 由于最终得到的左子树、右子树的节点不可能小于0，因此，结果：ans=Math.max(ans,left+right+root.val);

## [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

> 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
>
> 字符          数值
> I             1
> V             5
> X             10
> L             50
> C             100
> D             500
> M             1000
> 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
>
> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
>
> I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
> X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
> C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
> 给定一个罗马数字，将其转换成整数。
>
> 
>
> 示例 1:
>
> 输入: s = "III"
> 输出: 3
> 示例 2:
>
> 输入: s = "IV"
> 输出: 4
> 示例 3:
>
> 输入: s = "IX"
> 输出: 9
> 示例 4:
>
> 输入: s = "LVIII"
> 输出: 58
> 解释: L = 50, V= 5, III = 3.
> 示例 5:
>
> 输入: s = "MCMXCIV"
> 输出: 1994
> 解释: M = 1000, CM = 900, XC = 90, IV = 4.
>
>
> 提示：
>
> 1 <= s.length <= 15
> s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
> 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
> 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
> IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。

```java
class Solution {
    public int romanToInt(String s) {
        Map<Character,Integer> hashmap=new HashMap<Character,Integer>();
        hashmap.put('I',1);
        hashmap.put('V',5);
        hashmap.put('X',10);
        hashmap.put('L',50);
        hashmap.put('C',100);
        hashmap.put('D',500);
        hashmap.put('M',1000);
        int ans=0;
        int n=s.length();
        for(int i=0;i<n-1;i++){
            if(hashmap.get(s.charAt(i))>=hashmap.get(s.charAt(i+1))){
                ans+=hashmap.get(s.charAt(i));
            }
            else{
                ans-=hashmap.get(s.charAt(i));
            }
        }
        return ans+hashmap.get(s.charAt(n-1));
    }
}
```

1. 把每个可能出现的字母所对应的数值放进哈希表中
2. 遍历字符串，如果当前字符大于后一个字符，则就加上该字符所对应的数值，如果当前字符小于后一个字符则就减去该字符所对应的数值，由于倒数第一个没有进行计算，因此还要在最后的返回值加上最后一个数，因为不管前面的大于最后一个还是小于最后1个，最后一个值肯定只能是加

## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

> 示例 1：
>
> 输入：s = "()"
> 输出：true
> 示例 2：
>
> 输入：s = "()[]{}"
> 输出：true
> 示例 3：
>
> 输入：s = "(]"
> 输出：false
> 示例 4：
>
> 输入：s = "([)]"
> 输出：false
> 示例 5：
>
> 输入：s = "{[]}"
> 输出：true
>
>
> 提示：
>
> 1 <= s.length <= 104
> s 仅由括号 '()[]{}' 组成

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack=new Stack<Character>();
        int n=s.length();
        for(int i=0;i<n;i++){
            char c=s.charAt(i);
            if(c=='('||c=='{'||c=='['){
                stack.push(c);
            }
            else{
                if(!stack.isEmpty()&&stack.peek()==pd(c)){
                    stack.pop();
                }
                else{
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
    public char pd(char c){
        if(c=='}') return '{';
        else if(c==')') return '(';
        else return '[';
    }
}
```

1. 对于字符串匹配问题，一般通过栈解决，Stack<Character> stack=new Stack<Character>();
2. 遍历字符出，如果属于’（‘，’{‘，’【‘，就将其添加到栈里面
3. 如果不上虞上面的，则一定是与之相反的，判断此时字符串是否为空，并且判断栈顶元素是否与之相反，通过判断返回与之相反的字符，如果返回的字符与之不相等则说明是不同种的，返回false
4. 最终，如果栈为空，返回true，否则返回false
5. 取栈顶元素：peek方法。isEmpty判断栈是否为空，push：向栈中添加元素。pop：移去栈顶元素

## 输入

## 知识点

- 对于sc.next()【当遇到空格则认为输入结束】
- 对于sc.nextLine()【对于空格，会将其看成字符串的1部分，直到遇到回车键才看作输入结束】
- Math.pow方法的返回值类型为double类型

## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
> 
>
> **示例 1：**
>
> ```
> 输入：n = 3
> 输出：["((()))","(()())","(())()","()(())","()()()"]
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：["()"]
> ```
>
> 
>
> **提示：**
>
> - `1 <= n <= 8`

```java
class Solution {
    List<String> ans=new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        if(n==0) return ans;
        String path="";
        dfs(path,n,0,0);
        return ans;
    }
    //open:开括号。close：闭括号
    private void dfs(String path,int n,int open,int close){
        if(open>n||close>open) return;
        if(path.length()==2*n){
            ans.add(path);
            return;
        }
        dfs(path+"(",n,open+1,close);
        dfs(path+")",n,open,close+1);
    }
}
```

1. 先遍历后，在进行剪枝
2. 如果说开括号大于闭括号或者闭括号大于开括号就不符合条件，则返回，对于close>n,则不需要考虑，因为close>n的范围包含close>open,如果小条件都不成立，那么大条件肯定也成立不了
3. 每次都是面临加”（“或者是加上”）“因此需要在一次dfs有两种选择，所以有两个dfs，同时加上”（“是open加1，加上”）“时close+1
4. ![image-20220115163031911](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220115163031911.png)

## 150. 括号画家            

> 达达是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。
>
> 这一天，刚刚起床的达达画了一排括号序列，其中包含小括号 `( )`、中括号 `[ ]` 和大括号 `{ }`，总长度为 *N*
>
> 。
>
> 这排随意绘制的括号序列显得杂乱无章，于是达达定义了什么样的括号序列是美观的：
>
> 1. 空的括号序列是美观的；
> 2. 若括号序列 *A*
>
>  是美观的，则括号序列 (*A*)、[*A*]、{*A*}
>
>  也是美观的；
>
> 若括号序列 *A*、*B*
>
>  都是美观的，则括号序列 *A**B*
>
> 1.  也是美观的。
>
> 例如 `[(){}]()` 是美观的括号序列，而`)({)[}](` 则不是。
>
> 现在达达想在她绘制的括号序列中，找出其中连续的一段，满足这段子串是美观的，并且长度尽量大。
>
> 你能帮帮她吗？
>
> #### 输入格式
>
> 输入一行由括号组成的字符串。
>
> #### 输出格式
>
> 输出一个整数，表示最长的美观的子段的长度。
>
> #### 数据范围
>
> 字符串长度不超过 105
>
> 。
>
> #### 输入样例：
>
> ```
> ({({(({()}})}{())})})[){{{([)()((()]]}])[{)]}{[}{)
> ```
>
> #### 输出样例：
>
> ```java
> 4
> ```

```java
package 习题;

import java.util.Scanner;
import java.util.Stack;

public class acw150_test {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        String s1=sc.next();
        int ans=0;//存储结果
        Stack<Integer> stack=new Stack<>();//将对应字符的下标用栈来存储
        for(int i=0;i<s1.length();i++){//遍历字符串
            char c=s1.charAt(i);//获取当前字符
            if(stack.size()!=0){//如果栈里面有元素
                char t=s1.charAt(stack.peek());//获取栈中第一个元素
                if(t=='('&&c==')'||t=='{'&&c=='}'||t=='['&&c==']') stack.pop();//如果当前元素能够与栈中元素的所对应的值能陪成对，就去除栈中的第一个元素
                else stack.push(i);//否则就把该值所对应的索引添加到栈里面
            }
            else stack.push(i);//如果栈中没有元素就将该目前该值所对应的下标加到栈里面
            if(stack.size()!=0) ans=Math.max(ans,i-stack.peek());//如果栈中元素不为0，则能配成对的元素为当前位置减去栈顶元素的索引【贪心算法，保证获取的序列一定是对称连续的】如果i=3，stack.peek()==1,说明2，3两个字符是满足y
            else ans=Math.max(ans,i+1);//如果栈为空。则说明目前所遇到的值都能配成对，由于索引从零开始，因此还要+1
        }
        System.out.println(ans);
    }
}

```

## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

> 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
>
> 有效 二叉搜索树定义如下：
>
>  节点的左子树只包含 小于 当前节点的数。
>  节点的右子树只包含 大于 当前节点的数。
>  所有左子树和右子树自身必须也是二叉搜索树。
>
> ![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)
>
>
> 示例 1：
>
> 输入：root = [2,1,3]
> 输出：true
>
> 示例 2：
>
> 输入：root = [5,1,4,null,null,3,6]
> 输出：false
> 解释：根节点的值是 5 ，但是右子节点的值是 4 。
>
> ![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)
>
> 提示：
>
> ![image-20220117212854094](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220117212854094.png)

![](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220117210307878.png)

![image-20220117215637676](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220117215637676.png)

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return dfs(root,Long.MAX_VALUE,Long.MIN_VALUE);//递归解决，由于范围为2的31次幂，因此采用包装类Long的最大值，判断该数是否在这个区间
    }
    private boolean dfs(TreeNode root,long hight,long low){//传的是long类型的
        if(root==null) return true;//如果该节点为空，说明遍历到该节点之前还没有遇见false
		
        //判断是否在区间内
        if(root.val<=low) return false;//如果该节点的值不在当前的区间，就返回false
        if(root.val>=hight) return false;//如果该节点的值不在当前的区间，就返回false
		
        //确定区间
        if(!dfs(root.left,root.val,low)) return false;//对于左分支，最小值不变，当前值变成上区间
        if(!dfs(root.right,hight,root.val)) return false;//对于右分支，最大值不变，当前值变成下区间
        return true;//如果过了上面这些关卡，说明在区间内，返回true；
    }
}
```

## [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

> 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。
>
> 网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
>
> 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png)
>
> 示例 1：
>
> 输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
> 输出：16
> 解释：它的周长是上面图片中的 16 个黄色的边
>
> 示例 2：
>
> 输入：grid = [[1]]
> 输出：4
>
> 示例 3：
>
> 输入：grid = [[1,0]]
> 输出：4
>
> 
>
> 提示：
>
>  row == grid.length
>  col == grid[i].length
>  1 <= row, col <= 100
>  grid[i][j] 为 0 或 1
>

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int m=grid.length;//确定矩阵的行数
        int n=grid[0].length;//确定矩阵的列数
        int ans=0;//存储结果
        for(int i=0;i<m;i++){//遍历矩阵中所有的元素
            for(int j=0;j<n;j++){
                if(grid[i][j]==0) continue;//如果改元素为0，则进行下一个数的遍历
                else{//如果该元素不为0，则对该元素进行操作
                    ans+=4;//一个方格有4条边，首先+4。如果两个方格相邻，就有两条边重复，因此，有重复的就-2，由于遍历了所有元素，对于两个相邻的，会重复减去两次2，因此我们可以
             				//只减去下边和右边重复的即可
                    if(j+1<n){//对于矩阵的右边界要确定好位置，不能越界，因此，要添加限制
                        if(grid[i][j+1]==1) ans-=2;//有相邻，-2
                    }
                    if(i+1<m){//对于矩阵的下边界要确定好位置，不能越界，因此，要添加限制
                        if(grid[i+1][j]==1) ans-=2;//有相邻，-2
                    }
                }
            }
        }
        return ans;//f
    }
}
```

## [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

> 给你一个大小为 m x n 的二进制矩阵 grid 。
>
> 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
>
> 岛屿的面积是岛上值为 1 的单元格的数目。
>
> 计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
>
> <img src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" alt="img" style="zoom: 33%;" />
>
> 示例 1：
>
> 输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
> 输出：6
> 解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
>
> 示例 2：
>
> 输入：grid = [[0,0,0,0,0,0,0,0]]
> 输出：0
>
> 
>
> 提示：
>
>  m == grid.length
>  n == grid[i].length
>  1 <= m, n <= 50
>  grid[i][j] 为 0 或 1
>

```java
class Solution {
    int ans=0;//存放结果
    int temp=0;//存放是否变成结果的中间变量
    public int maxAreaOfIsland(int[][] grid) {
        int m=grid.length;//行数
        int n=grid[0].length;//列数
        for(int i=0;i<m;i++){//遍历每个元素
            for(int j=0;j<n;j++){
                if(grid[i][j]==0) continue;//如果该元素为0，就看下一个元素
                else {//对该元素进行深度优先搜索
                    temp=0;//对每一个为1的元素进行深度遍历时，都要把中间变量置为0
                    dfs(grid,i,j);//进入递归
                }
            }
        }
        return ans;
    }
    private void dfs(int[][] grid,int i,int j){
        if(grid[i][j]==1) {//如果该元素为1
            temp++;//中间变量temp+1
            ans=Math.max(ans,temp);//如果该中间变量temp大于之前的遇到的就将ans置为temp
            grid[i][j]=0;//将该元素置为0.防止遍历相同值(防止“转圈圈”)
        }
        else return;//如果该值为0，就退出递归
        if(i-1>=0) dfs(grid,i-1,j);//往上边走，，同时要在边界内
        if(i+1<grid.length) dfs(grid,i+1,j);//往下边走，同时要在边界内
        if(j-1>=0) dfs(grid,i,j-1);//往左边走，同时要在边界内
        if(j+1<grid[0].length) dfs(grid,i,j+1);//往右边走，同时要在边界内
    }
}
```

## 1934. 贝茜放慢脚步

> 奶牛贝茜正在参加冬季哞林匹克运动会的越野滑雪比赛。
>
> 她以每秒 1米的速度出发。但是，随着时间的推移，她变得越来越疲倦，她开始放慢脚步。每次放慢脚步，贝茜的速度都会降低：减速一次后，她以每秒 1/2米的速度移动，减速两次后，则以每秒 1/3 米的速度移动，依此类推。你将被告知何时何地贝茜会减速。
>
> 当减速信息格式为：
>
> ```
> T 17
> ```
>
> 意味着，贝茜在某个时间点减速，本例表示比赛开始第 17 秒贝茜减速。
>
> 当减速信息格式为：
>
> ```
> D 10
> ```
>
> 意味着，贝茜在某个地点减速，本例表示在行进 10米处减速。
>
> 给定 *N*个减速信息，请计算贝茜滑完一千米需要多少秒。
>
> 将你的答案四舍五入到最接近的整数（ 0.5向上舍入为 1）。
>
> #### 输入格式
>
> 第一行包含整数 *N*
>
> 接下来 *N*行，每行描述一个减速信息，格式为 `T x` 或 `D x`。
>
> 无论哪种情况，*x*
>
> 都是一个整数，保证所有减速都在贝茜滑完一千米前发生。
>
> 可能同时发生多次减速，那么这会使得贝茜的速度一下子变慢很多。
>
> 所有减速信息不一定按顺序给出。
>
> #### 输出格式
>
> 输出贝茜滑完一千米所需的总时间。
>
> #### 数据范围
>
> 1≤*N*≤10000
>
> #### 输入样例：
>
> ```
> 2
> T 30
> D 10
> ```
>
> #### 输出样例：
>
> ```
> 2970
> ```
>
> ![image-20220119165636763](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220119165636763.png)

```java
package 习题;

import java.util.*;

public class acw1934_test {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int num=sc.nextInt();//减速次数
        ArrayList<Integer> a=new ArrayList<>();//存储减速的时间位置
        ArrayList<Integer> b=new ArrayList<>();//存储减速的距离位置
        for(int i=0;i<num;i++){
            if(sc.next().charAt(0)=='T'){//如果输入T，则将对应的数存储在时间数组里
                a.add(sc.nextInt());
            }
            else{//如果输入D，则将对应的数存储在距离数组里
                b.add(sc.nextInt());
            }
        }
        b.add(1000);//由于可能所给的时间或距离根本到达不了1000米，因此可以把1000存放在距离数组里面
        Collections.sort(a);//由于输入的数据并不是按照从小到大的顺序输入的，因此还需要排序
        Collections.sort(b);
        double s=0,t=0,v=1;//定义时间、距离为0，速度其实为1
        int i=0,j=0;//定义两个指针指向两个数组
        while(i<a.size()||j<b.size()){//知道两个数组都走完，才结束循环
            if(j==b.size()||i<a.size()&&(a.get(i)-t)<(b.get(j)-s)*v){//如果b数组遍历完了，或者a数组是没有遍历完并且当前a的值发生在b之前
                s+=(a.get(i)-t)/v;//距离为当前距离+时间差*速度
                t=a.get(i);//时间刷新
                v++;//速度的分母+1
                i++;//走向a的下一个元素
            }
            else{
                t+=(b.get(j)-s)*v;//时间为距离差除以速度【距离差*分母】
                s=b.get(j);//刷新距离
                v++;//速度的分母+1
                j++;//走向b数组的下一个元素
            }
        }
        System.out.println(Math.round(t));//对double类型的
    }
}
```

## 2058. 笨拙的手指

> 奶牛贝茜正在学习如何在不同进制之间转换数字。但是她总是犯错误，因为她无法轻易的用两个前蹄握住笔。每当贝茜将数字转换为一个新的进制并写下结果时，她总是将其中的某一位数字写错。例如，如果她将数字 14 转换为二进制数，那么正确的结果应为 1110，但她可能会写下 0110 或 1111。贝茜不会额外添加或删除数字，但是可能会由于写错数字的原因，写下包含前导 0的数字。给定贝茜将数字 *N* 转换为二进制数字以及三进制数字的结果，请确定 *N*的正确初始值（十进制表示）。
>
> #### 输入格式
>
> 第一行包含 *N*的二进制表示，其中一位是错误的。
>
> 第二行包含 *N*的三进制表示，其中一位是错误的。
>
> #### 输出格式
>
> 输出正确的 *N*的值。
>
> #### 数据范围
>
> 0≤*N*≤109，且存在唯一解。
>
> #### 输入样例：
>
> ```
> 1010
> 212
> ```
>
> #### 输出样例：
>
> ```
> 14
> ```
>
> #### 样例解释
>
> 14
>
> 在二进制下的正确表示为 1110，在三进制下的正确表示为 112。

```java
package 习题;

import java.util.*;

/**
 * 在1110、110有问题
 */
public class finger {
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        char[] a=sc.next().toCharArray();
        char[] b=sc.next().toCharArray();
        Set<Integer> s=new HashSet<Integer>();
        for(int i=0;i<a.length;i++){
            a[i]=a[i]=='0'? '1':'0';
            s.add(Integer.parseInt(new String(a),2));
            a[i]=a[i]=='0'? '1':'0';
        }
        for(int i=0;i<b.length;i++){
            char t=b[i];
            for(int j=0;j<3;j++){
                if(j+'0'!=t){
                    b[i]=(char)(j+'0');
                    int x=Integer.parseInt(new String(b),3);
                    if(s.contains(x)){
                        System.out.println(x);
                        return;
                    }
                }
            }
            b[i]=t;
        }
    }
}

```

## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

> 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
>
> 
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)
>
> 输入：p = [1,2,3], q = [1,2,3]
> 输出：true
>
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)
>
> 输入：p = [1,2], q = [1,null,2]
> 输出：false
>
> 示例 3：
>
> ![img](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)
>
> 输入：p = [1,2,1], q = [1,1,2]
> 输出：false
>
> 
>
> 提示：
>
> 两棵树上的节点数目都在范围 [0, 100] 内
> -104 <= Node.val <= 104

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null) return true;//如果当前值遍历完l，还没又return，说明没有错误，返回true；
        else if(p==null&&q!=null||p!=null&&q==null) return false;//由于对于访问null，会遭成空指针异常，因此，还需要把为null的情况排除掉
        else if(p.val!=q.val) return false;//如果有值，但是两个值不相等，就返回false
        else return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);//如果没有相同，就继续遍历下一个j
    }
} 
```

## [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

> #### 
>
> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
>
> 
>
> **示例 1：**
>
> ```
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[1,2,3,6,9,8,7,4,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
> 输出：[1,2,3,4,8,12,11,10,9,5,6,7]
> ```
>
> 
>
> **限制：**
>
> - `0 <= matrix.length <= 100`
> - `0 <= matrix[i].length <= 100`

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        int m=matrix.length;
        if(m==0) return new int[0];//如果出现【】，返回1个空数组
        int n=matrix[0].length;
        if(n==0) return new int[0];//如果出现【【】，【】】,返回1个空数组
        int[] ans=new int[m*n];//定义返回的数组
        int temp=0;//往ans数组中添加值的自增变量
        int a=0,b=n-1,c=0,d=m-1;//左边界、右边界、上边界、下边界
        while(true){//右、下、左、上
            //注意：由于”++“的出现可以正好避免同一个值添加两次的g
            for(int i=a;i<=b;i++) ans[temp++]=matrix[c][i];//从左往右，上边界不变
            if(++c>d) break;//该行遍历完了，上边界就往下走一行，如果超过下边界就退出
            for(int i=c;i<=d;i++) ans[temp++]=matrix[i][b];//从上往下，右边界不变
            if(--b<a) break;//该列遍历完了，右边界就往左走一列，如果超过左边界就退出
            for(int i=b;i>=a;i--) ans[temp++]=matrix[d][i];//从右往左，下边界不变
            if(--d<c) break;//该行遍历完了，下边界就往上走一行，如果超过上边界就退出
            for(int i=d;i>=c;i--) ans[temp++]=matrix[i][a]; //从下往上，左边界不变
            if(++a>b) break;//该列遍历完了，左边界就往右走一行，如果超过右边界就退出
        }
        return ans;
    }
}
```

## 抓住那头牛（BFS广搜）

> 农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点N(0≤N≤100000)，牛位于点K(0≤K≤100000)。农夫有两种移动方式：
>
> 1、从X移动到X-1或X+1，每次移动花费一分钟
>
> 2、从X移动到2*X，每次移动花费一分钟
>
> 假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛？
>
> 
>
> 输入格式
>
> 两个整数，N和K。
>
> 输出格式
>
> 一个整数，农夫抓到牛所要花费的最小分钟数。
>
> 样例
>
> 输入样例
>
> 5 17
>
> 输出样例
>
> 4
>
> 限制
>
> 时间限制: 1000 ms
>
> 内存限制: 65536 KB

```java
package 习题;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class POJ_2971_test {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int a=sc.nextInt();//农夫位置
        int b=sc.nextInt();//奶牛位置
        bfs(a,b);//广度优先遍历
    }
    public static void bfs(int a,int b){
        int[] step=new int[3];//三种决策
        Queue<Integer> q=new LinkedList<>();//用队列来处理广度优先问题
        q.offer(a);//往队列中添加值
        int[] ans=new int[100002];//存储时间
        Arrays.fill(ans,-1);//将所有位置状态设为-1，以便于辨别是否添加过值
        ans[a]=0;//农夫不动，花费时间为0
        while(!q.isEmpty()){//判断队列中是否遍历完了
            int temp= q.poll();//取出队列中的第一个数，并将其删除
            if(temp==b) break;//如果当前位置等于奶牛位置，就退出循环
            step[0]=temp*2;//三种决策后的位置
            step[1]=temp-1;
            step[2]=temp+1;
            for(int i=0;i<3;i++){//分别将三种决策添加到队列中
                if(step[i]>=0&&step[i]<=100001&&ans[step[i]]==-1){//如果决策后的位置小于0或者大于100001【最大走到100001】并且当前位置还没有被访问过
                    q.offer(step[i]);//将该决策加入队列
                    ans[step[i]]=ans[temp]+1;//ans中奶牛的位置一定是最小值，因为队列是优先处理先添加进来的决策，因此就算下一个决策满足题意也比前一个满足题意的大1分钟
                }
            }
        }
        System.out.println(ans[b]);//输出d
    }
}
```

## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

> 给你二叉树的根结点 root ，请你将它展开为一个单链表：
>
> 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
> 展开后的单链表应该与二叉树 先序遍历 顺序相同。
>
>
> 示例 1：
>
>
> 输入：root = [1,2,5,3,4,null,6]
> 输出：[1,null,2,null,3,null,4,null,5,null,6]
> 示例 2：
>
> 输入：root = []
> 输出：[]
> 示例 3：
>
> 输入：root = [0]
> 输出：[0]
>
>
> 提示：
>
> 树中结点数在范围 [0, 2000] 内
> -100 <= Node.val <= 100

```java
class Solution {
    public void flatten(TreeNode root) {
        List<TreeNode> l1=new ArrayList<>();//结果链表
        dfs(root,l1);//对二叉树进行先序遍历
        for(int i=1;i<l1.size();i++){//第一个节点位置不变
            TreeNode pre=l1.get(i-1);//前一个节点
            TreeNode cur=l1.get(i);//
            pre.left=null;//将左子树赋值为空
            pre.right=cur;//该节点的右子树指向下一个节点
        }
    }
    public void dfs(TreeNode root,List<TreeNode> l1){
        if(root!=null){
            l1.add(root);
            //先序遍历方法
            dfs(root.left,l1);
            dfs(root.right,l1);
        }
    }
}
```

## [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)[广搜+队列]

> 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
>
> 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
>
> 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。
>
> 最后返回经过上色渲染后的图像。
>
> 示例 1:
>
> 输入: 
> image = [[1,1,1],[1,1,0],[1,0,1]]
> sr = 1, sc = 1, newColor = 2
> 输出: [[2,2,2],[2,2,0],[2,0,1]]
> 解析: 
> 在图像的正中间，(坐标(sr,sc)=(1,1)),
> 在路径上所有符合条件的像素点的颜色都被更改成2。
> 注意，右下角的像素没有更改为2，
> 因为它不是在上下左右四个方向上与初始点相连的像素点。
>
> 注意:
>
>  image 和 image[0] 的长度在范围 [1, 50] 内。
>  给出的初始点将满足 0 <= sr < image.length 和 0 <= sc < image[0].length。
>  image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。
>

```java
class Solution {
    int[] dx=new int[]{1,0,-1,0};//横向变化量：右、下、左、上
    int[] dy=new int[]{0,1,0,-1};//列向变化量：右、下、左、上
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int num=image[sr][sc];//记录当前值
        int m=image.length;//行数
        int n=image[0].length;//列数
        if(image[sr][sc]==newColor) return image;//如果当前值等于要修改的值，就不会发生改变，直接返回原数组即可
        Queue<int[]> q=new LinkedList<>();//用一个队列来存储变化的位置，先添加的先处理，一般广搜与队列相搭配使用
        q.offer(new int[]{sr,sc});//将该第一个值存在队列中【将位置信息分别放在数组的第一个和第二个】
        image[sr][sc]=newColor;//将第一个值得数改为newColor
        while(!q.isEmpty()){//当队列为空时，就处理了所有由第一个引出来的所有数
            int[] temp=q.poll();//该数处理后将该书删除【取出并删除：poll()】
            int x=temp[0],y=temp[1];//行、列
            for(int i=0;i<4;i++){//分别对四个方向进行处理
                int cur_x=x+dy[i],cur_y=y+dx[i];//行数应该加上"列向"的变化量，列数应该加上"横向"的变化量
                if(cur_x>=0&&cur_x<m&&cur_y>=0&&cur_y<n&&image[cur_x][cur_y]==num){//满足不越界，该值等于初值，就说明满足“传染”的要求，将其加入队列
                    q.offer(new int[]{cur_x,cur_y});//将该位置信息加到队列中
                    image[cur_x][cur_y]=newColor;//修改该位置的数
                }
            }
        }
        return image;//返回修改后的数组
    }
}
```

## [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

> 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
> struct Node {
> int val;
> Node *left;
> Node *right;
> Node *next;
> }
>
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。
>
> 
>
> 示例 1：
>
> <img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img" style="zoom:33%;" />
>
> 输入：root = [1,2,3,4,5,6,7]
> 输出：[1,#,2,3,#,4,5,6,7,#]
> 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
>
> 示例 2:
>
> 输入：root = []
> 输出：[]
>
> 
>
> 提示：
>
>  树中节点的数量在 [0, 212 - 1] 范围内
>  -1000 <= node.val <= 1000
>

```java
//本题采用BFS算法，一般来说BFS【按层遍历】一般与队列相搭配
class Solution {
    public Node connect(Node root) {
        if(root==null) return root;//如果当前节点为空，直接把根节点返回
        Queue<Node> q=new LinkedList<>();//利用队列进行1层1层的遍历
        q.offer(root);//首先把根节点添加到队列中
        while(!q.isEmpty()){//如果队列为空，说明处理了所有的节点
            int n=q.size();//记录该层的个数
            for(int i=0;i<n-1;i++){//该层最后一个数单独处理
                Node n1=q.poll();//取出第一个节点，并将其从队列中移除
                n1.next=q.peek();//该节点的next指向下一个节点
                if(n1.left!=null) q.offer(n1.left);//如果该节点的左子树不为空，就将其添加到队列中
                if(n1.right!=null) q.offer(n1.right);//如果该节点的右子树不为空，就将其添加到队列中
            }
            if(q.peek().left!=null) q.offer(q.peek().left);//对于该层的最后一个节点也需要判断左右子树是否为空
            if(q.peek().right!=null) q.offer(q.peek().right);
            q.poll().next=null;//该层最后1个节点的next指向null
        }
        return root;
    }
}
```

# 图论

## [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)

> 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
>
> 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
>
> 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。
>
> 最后返回经过上色渲染后的图像。
>
> 示例 1:
>
> 输入: 
> image = [[1,1,1],[1,1,0],[1,0,1]]
> sr = 1, sc = 1, newColor = 2
> 输出: [[2,2,2],[2,2,0],[2,0,1]]
> 解析: 
> 在图像的正中间，(坐标(sr,sc)=(1,1)),
> 在路径上所有符合条件的像素点的颜色都被更改成2。
> 注意，右下角的像素没有更改为2，
> 因为它不是在上下左右四个方向上与初始点相连的像素点。
>
> 注意:
>
>  image 和 image[0] 的长度在范围 [1, 50] 内。
>  给出的初始点将满足 0 <= sr < image.length 和 0 <= sc < image[0].length。
>  image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]
>

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int m=image.length;
        int n=image[0].length;
        int ans=image[sr][sc];
        if(image[sr][sc]==newColor) return image;
        int[] dx=new int[]{0,1,0,-1};
        int[] dy=new int[]{1,0,-1,0};
        Queue<int[]> q=new LinkedList<int[]>();
        int[] temp=new int[]{sr,sc};
        q.offer(temp);
        image[sr][sc]=newColor;
        while(!q.isEmpty()){
            int[] temp1=q.poll();
            for(int i=0;i<4;i++){
                int x=temp1[0]+dx[i];
                int y=temp1[1]+dy[i];
                if(x>=0&&x<m&&y>=0&&y<n&&image[x][y]==ans){
                    image[x][y]=newColor;
                    q.offer(new int[]{x,y});
                }
            }
        }
        return image;
    }
}
```

## [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

> 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。
>
> 
>
> 示例 1：
>
> 输入：grid = [
> ["1","1","1","1","0"],
> ["1","1","0","1","0"],
> ["1","1","0","0","0"],
> ["0","0","0","0","0"]
> ]
> 输出：1
>
> 示例 2：
>
> 输入：grid = [
> ["1","1","0","0","0"],
> ["1","1","0","0","0"],
> ["0","0","1","0","0"],
> ["0","0","0","1","1"]
> ]
> 输出：3
>
> 
>
> 提示：
>
>  m == grid.length
>  n == grid[i].length
>  1 <= m, n <= 300
>  grid[i][j] 的值为 '0' 或 '1'
>

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1};//行变化量
    int[] dy=new int[]{1,0,-1,0};//列变化量
    public int numIslands(char[][] grid) {
        int m=grid.length;//行数
        int n=grid[0].length;//列数
        int ans=0;//记录结果值
        Queue<int[]> q=new LinkedList<>();//把坐标存储在队列中
        for(int i=0;i<m;i++){//遍历每一个坐标
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){//如果该点为1就将其加入到队列
                    ans++;//发现一个岛屿，结果+1
                    q.offer(new int[]{i,j});//将坐标加入到队列中
                    grid[i][j]='0';
                    while(!q.isEmpty()){//能够找到岛屿的边缘
                        int[] temp1=q.poll();
                        for(int t=0;t<4;t++){//向四周扩展
                            int x=temp1[0]+dx[t];
                            int y=temp1[1]+dy[t];
                            if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]=='1'){//如果该位置左边的临界为1，同样将其加入到队列
                                q.offer(new int[]{x,y});
                                grid[x][y]='0';
                            }
                        }
                    }
                }
            }
        }
        return ans;//返回结果
    }
}
```

## [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

> 给你一个大小为 m x n 的二进制矩阵 grid 。
>
> 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
>
> 岛屿的面积是岛上值为 1 的单元格的数目。
>
> 计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202031535626.jpeg)
>
> 输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
> 输出：6
> 解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
>
> 示例 2：
>
> 输入：grid = [[0,0,0,0,0,0,0,0]]
> 输出：0
>
> 
>
> 提示：
>
>  m == grid.length
>  n == grid[i].length
>  1 <= m, n <= 50
>  grid[i][j] 为 0 或 1
>

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1};//行变量
    int[] dy=new int[]{1,0,-1,0};//列变量
    public int maxAreaOfIsland(int[][] grid) {
        int ans=0;//存放结果
        int m=grid.length;//行数
        int n=grid[0].length;//列数
        Queue<int[]> q=new LinkedList<>();//存储队列
        int temp1=0;//结果的中间变量
        for(int i=0;i<m;i++){//遍历所有点
            for(int j=0;j<n;j++){
                if(grid[i][j]==1){//如果该点为1，就将其加入到队列中
                   temp1=1; //该点为1，中间结果+1
                   ans=Math.max(ans,temp1);//如果当前值大于结果中存的，就进行替换
                    q.offer(new int[]{i,j});//将位置存储在队列中
                    grid[i][j]=0;//将该位置置为0，防止下次再遍历到该点
                    while(!q.isEmpty()){//查找到岛屿的边缘
                        int[] temp=q.poll();//取出队列中存储的第一个值
                        for(int t=0;t<4;t++){//对其四周进行遍历
                            int x=temp[0]+dx[t];
                            int y=temp[1]+dy[t];
                            if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]==1){//如果该点不越界并且该点值为1就将其加到队列中，并将该位置的值置为0
                                q.offer(new int[]{x,y});
                                temp1++;
                                ans=Math.max(ans,temp1);
                                grid[x][y]=0;
                            }
                        }
                    }
                }
            }
        }
        return ans;//返回结果
    }
}
```

## [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

> #### 
>
> 二维矩阵 `grid` 由 `0` （土地）和 `1` （水）组成。岛是由最大的4个方向连通的 `0` 组成的群，封闭岛是一个 `完全` 由1包围（左、上、右、下）的岛。
>
> 请返回 *封闭岛屿* 的数目。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png)
>
> ```
> 输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
> 输出：2
> 解释：
> 灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/07/sample_4_1610.png)
>
> ```
> 输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：grid = [[1,1,1,1,1,1,1],
>           [1,0,0,0,0,0,1],
>           [1,0,1,1,1,0,1],
>           [1,0,1,0,1,0,1],
>           [1,0,1,1,1,0,1],
>           [1,0,0,0,0,0,1],
>           [1,1,1,1,1,1,1]]
> 输出：2
> ```
>
> 
>
> **提示：**
>
> - `1 <= grid.length, grid[0].length <= 100`
> - `0 <= grid[i][j] <=1`

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1};//行变化量
    int[] dy=new int[]{1,0,-1,0};//列变换量
    public int closedIsland(int[][] grid) {
        int m=grid.length;//行数
        int n=grid[0].length;//列数
        int ans=0;//存放结果的变量
        Queue<int[]> q=new LinkedList<>();//存储坐标的队列
        for(int i=1;i<m-1;i++){//遍历二维数组中每一个位置
            for(int j=1;j<n-1;j++){
                if(grid[i][j]==0){//如果该位置为0，就将其加入到队列中
                    ans++;//加过+1；
                    q.offer(new int[]{i,j});//将其加入到队列中
                    grid[i][j]=1;//将该位置置为1，防止下次再遍历到
                    boolean flag=false;//用于判断是否在边缘遇到过0，只要遇到1次边缘0，由最初位置遍历而来的+1的那个再减去1
                    while(!q.isEmpty()){//查找到陆地边缘
                        int[] temp=q.poll();
                        for(int t=0;t<4;t++){
                            int x=temp[0]+dx[t];
                            int y=temp[1]+dy[t];
                            if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]==0){//往四周扩散
                                if(x==0||x==m-1||y==0||y==n-1){//如果陆地扩散到边缘，说明这个陆地不是闭合的，将flag置为true；，但是并不退出，而是继续探索这个不是闭合陆地的边缘
                                    flag=true;
                                }
                                q.offer(new int[]{x,y});
                                grid[x][y]=1;
                            }
                        }
                    }
                    if(flag) ans--;//说明不是闭合路径，将结果再减去1
                }
            }
        }
        return ans;//返回结果
    }
}
```

## [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)

> 给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。
>
> 一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。
>
> 返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202041414187.jpeg)
>
> 输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
> 输出：3
> 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
>
> 示例 2：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202041414763.jpeg)
>
> 输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
> 输出：0
> 解释：所有 1 都在边界上或可以到达边界。
>
> 
>
> 提示：
>
>  m == grid.length
>  n == grid[i].length
>  1 <= m, n <= 500
>  grid[i][j] 的值为 0 或 1
>

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1};
    int[] dy=new int[]{1,0,-1,0};
    public int numEnclaves(int[][] grid) {
        int m=grid.length;
        int n=grid[0].length;
        int ans=0;
        int temp1=0;
        Queue<int[]> q=new LinkedList<>();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1){
                    boolean flag=false;
                    q.offer(new int[]{i,j});
                    grid[i][j]=0;
                    ans++;
                    temp1=1;
                    if(i==0||i==m-1||j==0||j==n-1) flag=true;
                    while(!q.isEmpty()){
                        int[] temp=q.poll();
                        for(int t=0;t<4;t++){
                            int x=temp[0]+dx[t];
                            int y=temp[1]+dy[t];
                            if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]==1){
                                if(x==0||x==m-1||y==0||y==n-1) flag=true;
                                q.offer(new int[]{x,y});
                                ans++;
                                temp1++;
                                grid[x][y]=0;
                            }
                        }
                    }
                    if(flag) ans-=temp1;
                }
            }
        }
        return ans;
    }
}
```

## [1905. 统计子岛屿](https://leetcode-cn.com/problems/count-sub-islands/)

> 给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。
>
> 如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。
>
> 请你返回 grid2 中 子岛屿 的 数目 。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202041554036.png)
>
> 输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
> 输出：3
> 解释：如上图所示，左边为 grid1 ，右边为 grid2 。
> grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。
>
> 示例 2：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202041554585.png)
>
> 输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
> 输出：2 
> 解释：如上图所示，左边为 grid1 ，右边为 grid2 。
> grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。
>
> 
>
> 提示：
>
>  m == grid1.length == grid2.length
>  n == grid1[i].length == grid2[i].length
>  1 <= m, n <= 500
>  grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 
>

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1};//行变换量
    int[] dy=new int[]{1,0,-1,0};//列变化量
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int m=grid1.length;//行数
        int n=grid1[0].length;//列数
        int ans=0;//存放结果的变量
        Queue<int[]> q=new LinkedList<>();//扩散时用到队列
        for(int i=0;i<m;++i){//遍历grid2的每一个位置
            for(int j=0;j<n;++j){
                if(grid2[i][j]==1){//如果该点位置的值为1
                    boolean flag=false;//用于判断grid2是否某一点为1时，grid1相对应的位置不为1
                    ans++;//当前位置为1，结果+1
                    if(grid1[i][j]!=1) flag=true;//如果grid1不为1，则说明不在grid1里面
                    q.offer(new int[]{i,j});//将位置添加到队列中
                    grid2[i][j]=0;//将该位置的值置为0
                    while(!q.isEmpty()){//进行扩散，找到边缘
                        int[] temp=q.poll();
                        for(int t=0;t<4;++t){//进行四周的扩散
                            int x=temp[0]+dx[t];
                            int y=temp[1]+dy[t];
                            if(x>=0&&x<m&&y>=0&&y<n&&grid2[x][y]==1){
                                q.offer(new int[]{x,y});
                                grid2[x][y]=0;
                                if(grid1[x][y]!=1) flag=true;//如果有一项不符合就进行将flag置为true
                            }
                        }
                    }
                    if(flag) ans--;//如果有不符合的点就不进行添加，即再减去1
                }
            }
        }
        return ans;//返回结果
    }
}
```

## [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

> 你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。如果网格上只有陆地或者海洋，请返回 -1。
>
> 我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202062040211.jpeg)
>
> 输入：grid = [[1,0,1],[0,0,0],[1,0,1]]
> 输出：2
> 解释： 
> 海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。
>
> 示例 2：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202062040243.jpeg)
>
> 输入：grid = [[1,0,0],[0,0,0],[0,0,0]]
> 输出：4
> 解释： 
> 海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。
>
> 
>
> 提示：
>
>  n == grid.length
>  n == grid[i].length
>  1 <= n <= 100
>  grid[i][j] 不是 0 就是 1
>

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1};//行变化量
    int[] dy=new int[]{1,0,-1,0};//列变化量
    public int maxDistance(int[][] grid) {
        int m=grid.length;//行数
        int n=grid[0].length;//列数
        Queue<int[]> q=new LinkedList<>();
        int ans=0;//最懂结果变量
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1) q.offer(new int[]{i,j});//记录投石点位置
            }
        }
        boolean flag=false;//用于判断是否全是海水
        if(q.isEmpty()) flag=true;//如果全是海水，结果置为true，返回false
        while(!q.isEmpty()){//如果有陆地【投石点】
            int[] temp=q.poll();
            for(int t=0;t<4;t++){
                int x=temp[0]+dx[t];//向四周变化
                int y=temp[1]+dy[t];
                if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]==0){//如果该点不是陆地，就继续扩散
                    grid[x][y]=grid[temp[0]][temp[1]]+1;//波纹半径+1
                    q.offer(new int[]{x,y});
                    ans=Math.max(ans,grid[x][y]);//记录最大值
                }
            }
        }
        if(flag) return -1;//返回结果
        else return ans-1;
    }
}
```

- 需要注意的是BFS是波纹似的变化，把陆地当做投石点，波纹走的最远的地方就是离陆地最远的地方

## [1091. 二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

> 给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。
>
> 二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：
>
>  路径途经的所有单元格都的值都是 0 。
>  路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。
>
> 畅通路径的长度 是该路径途经的单元格总数。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202072257330.png)
>
> 输入：grid = [[0,1],[1,0]]
> 输出：2
>
> 示例 2：
>
> ![](https://gitee.com/demon_night/images/raw/master/imgs/202202072257871.png)
>
> 输入：grid = [[0,0,0],[1,1,0],[1,1,0]]
> 输出：4
>
> 示例 3：
>
> 输入：grid = [[1,0,0],[1,1,0],[1,1,0]]
> 输出：-1
>
> 
>
> 提示：
>
>  n == grid.length
>  n == grid[i].length
>  1 <= n <= 100
>  grid[i][j] 为 0 或 1
>

```java
class Solution {
    int[] dx=new int[]{0,1,1,1,0,-1,-1,-1};//行变化量
    int[] dy=new int[]{1,1,0,-1,-1,-1,0,1};//列变换量
    public int shortestPathBinaryMatrix(int[][] grid) {
        int m=grid.length;//行数
        int n=grid[0].length;//列数
        if(grid[0][0]==1) return -1;//如果左顶点为1，则直接返回-1
        Queue<int[]> q=new LinkedList<>();
        q.offer(new int[]{0,0,1});//如果左顶点不为1，就将其加到队列中，将步数存在数组的第三个位置
        grid[0][0]=1;
        while(!q.isEmpty()){//进行波纹式扩散
            int[] temp1=q.poll();
            if(temp1[0]==m-1&&temp1[1]==n-1){//如果该点就是终点，就返回结果
                return temp1[2];
            }
            for(int t=0;t<8;t++){//进行四周扩散
                int x=temp1[0]+dx[t];
                int y=temp1[1]+dy[t];
                if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]==0){
                    q.offer(new int[]{x,y,temp1[2]+1});//如果扩散到达的点的值为0，步数就再+1
                    grid[x][y]=1;
                }
            }
        }
        return -1;//如果没有到达终点，就返回-1；
    }
}
```

## [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

> 给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。
>
> 两个相邻元素间的距离为 1 。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202081218265.png)
>
> 输入：mat = [[0,0,0],[0,1,0],[0,0,0]]
> 输出：[[0,0,0],[0,1,0],[0,0,0]]
>
> 示例 2：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202081218409.png)
>
> 输入：mat = [[0,0,0],[0,1,0],[1,1,1]]
> 输出：[[0,0,0],[0,1,0],[1,2,1]]
>
> 
>
> 提示：
>
>  m == mat.length
>  n == mat[i].length
>  1 <= m, n <= 104
>  1 <= m * n <= 104
>  mat[i][j] is either 0 or 1.
>  mat 中至少有一个 0 
>

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1};//行变量
    int[] dy=new int[]{1,0,-1,0};//列变量
    public int[][] updateMatrix(int[][] mat) {
        int m=mat.length;//行数
        int n=mat[0].length;//列数
        Queue<int[]> q=new LinkedList<>();//用于存储“0”位置的队列
        boolean[][] flag=new boolean[m][n];//用于判断该点是否被访问过
        for(int i=0;i<m;i++){//遍历整个图，把值为0的添加到队列中，同时将相对应位置的flag置为true
            for(int j=0;j<n;j++){
                if(mat[i][j]==0){
                    q.offer(new int[]{i,j});
                    flag[i][j]=true;
                } 
            }
        }
        while(!q.isEmpty()){//当不能再扩散时，就退出
            int[] temp=q.poll();
            for(int t=0;t<4;t++){//向四周扩散
                int x=temp[0]+dx[t];
                int y=temp[1]+dy[t];
                if(x>=0&&x<m&&y>=0&&y<n&&mat[x][y]==1&&!flag[x][y]){//如果该位置还没有为1，并且还没被访问过，就将该位置加到队列中
                    q.offer(new int[]{x,y});
                    mat[x][y]=mat[temp[0]][temp[1]]+1;//到达该位置的步数+1，同时将该位置置为true
                    flag[x][y]=true;
                }
            }
        }
        return mat;//返回修改后的数组
    }
}
```

- 对于为什么队列存储”0“的位置，而不是”1“的位置？
  - 因为我们可以想象一下，到达聚集的“1”的中心的值才是最大的，因此，我们可以从边缘向中心扩散时，正好能达到递增的想法，而如果我们存储“1”的位置，我们只能改变扩散的边缘的值，因为最初的值已经被poll掉了
- 同时我们还需要知道最先改变的位置，肯定是最先到达，也就是最近的，我们将该位置置为true，以后别人慢的到达该位置时，同样不能更改该位置的值

## [934. 最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)

> 在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）
>
> 现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。
>
> 返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）
>
> 
>
> 示例 1：
>
> 输入：A = [[0,1],[1,0]]
> 输出：1
> 示例 2：
>
> 输入：A = [[0,1,0],[0,0,0],[0,0,1]]
> 输出：2
> 示例 3：
>
> 输入：A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
> 输出：1
>
>
> 提示：
>
> - `2 <= A.length == A[0].length <= 100`
> - `A[i][j] == 0` 或 `A[i][j] == 1`

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1};//行变化量
    int[] dy=new int[]{1,0,-1,0};//列变化量
    int[][] g;//整个图
    int m,n;//行数、列数
    ArrayList<int[]>[] l=new ArrayList[]{new ArrayList(),new ArrayList()};//用于存储两个连通图的集合，注意new时不能是泛型
    public int shortestBridge(int[][] grid) {
        m=grid.length;//行数
        n=grid[0].length;//列数
        g=grid;//此时g相当于grid
        for(int i=0,k=0;i<m;i++){//找出两个集合
            for(int j=0;j<n;j++){
                if(grid[i][j]==1){
                    dfs(i,j,l[k++]);//如果第一个集合找到了，就会退出dfs，此时，如果遇到第二个集合，此时值就会进入到第二个集合，注意，k在第一个for中已经定义了
                }
            }
        }
        int ans=m*n;
        for(int[] i:l[0]){//取出第一个集合中的所有值与第二个集合中的所有值进行比较
            for(int[] j:l[1]){
                ans=Math.min(ans,Math.abs(i[0]-j[0])+Math.abs(i[1]-j[1]));//根据“曼哈顿算法”求两点之间的距离
            }
        }
        return ans-1;//最终结果-1后就是需要翻转0的数目        
    }
    //进行DFS
    private void dfs(int i,int j,ArrayList a){
        a.add(new int[]{i,j});//将位置添加进集合中
        g[i][j]=0;//将访问过的1进行该值，防止“转圈圈”
        for(int t=0;t<4;t++){//向四周进行变化
            int x=i+dx[t];
            int y=j+dy[t];
            if(x>=0&&x<m&&y>=0&&y<n&&g[x][y]==1){
                dfs(x,y,a);
            }
        }
    }
}
```

## [797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

> 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）
>
> graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202082208200.jpeg)
>
> 输入：graph = [[1,2],[3],[3],[]]
> 输出：[[0,1,3],[0,2,3]]
> 解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
> 示例 2：
>
> ![](https://gitee.com/demon_night/images/raw/master/imgs/202202082208314.jpeg)
>
> 输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
> 输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
>
>
> 提示：
>
> n == graph.length
> 2 <= n <= 15
> 0 <= graph[i][j] < n
> graph[i][j] != i（即不存在自环）
> graph[i] 中的所有元素 互不相同
> 保证输入为 有向无环图（DAG）

```java
class Solution {
    List<List<Integer>> l=new ArrayList<List<Integer>>();//返回结果的集合
    int m;//行数
    int[][] g;//引用地图
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        m=graph.length;//求行数
        g=graph;//引用给的图
        ArrayList<Integer> l1=new ArrayList<>();//用于存储遇到的值集合
        dfs(0,l1);//进行DFS
        return l;//返回结果
    }
    private void dfs(int i,ArrayList<Integer> path){
        if(i==m-1){//如果走到n-1了
            path.add(i);//将该点的值添加到path集合中
            l.add(new ArrayList<>(path));//将遇到的集合进行拷贝，注意是拷贝path，而不是引用path
            path.remove(path.size()-1);//将该点从path集合中移除
            return;//走到底了，退出
        }
        path.add(i);//如果没有走到n-1，就将其加入到path中
        for(int t:g[i]){//有该点引出下一个数组，分别进行DFS
            dfs(t,path);
        }
        path.remove(path.size()-1);//移到上一个下标
    }
}
```

- 对于为什么用`l.add(new ArrayList<>(path));`而不是用`l.add(path)`
  - 因为因为`path`指向的对象在不断地增加和删除元素，最后会变成空。得到的结果会变成`[[][][][][]]`所以要用`new linkedList(path)`拷贝一个对象加入`res`
  - 回溯过程中，将数字使用状态重置撤销的时候，会将list的元素移除掉，也会影响到res里面的list情况。因为它们是同一个引用。 全部为空，是因为回溯结束的同时，会将全部数字重置撤销，这样list里面的元素就会为空了，同样的，也会影响到res的存放情况
  - 总结：path是引用，因为DFS最终会撤销到原点，即path为空，而所有添加过path的也将变空，因此我们需要拷贝内容，将其放在l集合中即可，而`new ArrayList(你的一维数组)`相当于给你的一维数组取了个快照。

## [841. 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)

> 有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。
>
> 当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。
>
> 给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。
>
> 
>
> 示例 1：
>
> 输入：rooms = [[1],[2],[3],[]]
> 输出：true
> 解释：
> 我们从 0 号房间开始，拿到钥匙 1。
> 之后我们去 1 号房间，拿到钥匙 2。
> 然后我们去 2 号房间，拿到钥匙 3。
> 最后我们去了 3 号房间。
> 由于我们能够进入每个房间，我们返回 true。
> 示例 2：
>
> 输入：rooms = [[1,3],[3,0,1],[2],[0]]
> 输出：false
> 解释：我们不能进入 2 号房间。
>
>
> 提示：
>
> n == rooms.length
> 2 <= n <= 1000
> 0 <= rooms[i].length <= 1000
> 1 <= sum(rooms[i].length) <= 3000
> 0 <= rooms[i][j] < n
> 所有 rooms[i] 的值 互不相同

```java
class Solution {
    List<List<Integer>> l=new ArrayList<List<Integer>>();//用于引用路径
    boolean[] flag;//标志，用于判断该点是否被访问过
    int m;//行数
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        l=rooms;//引用
        m=rooms.size();//赋值行数
        flag=new boolean[m];//定义flag
        dfs(0);//进行DFS
        for(int i=0;i<m;i++){//用于判断是否有放假没有被访问过
            if(!flag[i]) return false;//如果有没被访问过的点就返回false
        }
        return true;//如果都为true，就返回true
    }
    private void dfs(int t){
        if(flag[t]) return;//如果该点被访问过，就退出向下钻
        flag[t]=true;//如果没有被访问过，就将该点置为true
        for(int i:l.get(t)){//1点引多点，分别向下进行DFS
            dfs(i);
        }
    }
}
```

## [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

> 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
>
> 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
>
> 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。
>
> 返回矩阵中 省份 的数量。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202092307534.jpeg)
>
> 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
> 输出：2
> 示例 2：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202092308692.jpeg)
>
> 输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
> 输出：3
>
>
> 提示：
>
> 1 <= n <= 200
> n == isConnected.length
> n == isConnected[i].length
> isConnected[i][j] 为 1 或 0
> isConnected[i][i] == 1
> isConnected[i][j] == isConnected[j][i]

```java
class Solution {
    int[][] g;//用于引用图
    int m;//行数
    boolean[] flag;//标志数组，用于判断该点是否被访问过
    public int findCircleNum(int[][] isConnected) {
        g=isConnected;
        m=isConnected.length;
        flag=new boolean[m];
        int ans=0;//用于存放最终结果
        for(int i=0;i<m;i++){//分别遍历每一点：0~n-1
            if(!flag[i]){//记住我们判断的是数是否被访问过，而不是判断的二维数组的坐标
                flag[i]=true;
                dfs(i);
                ans++;//如果从dfs中退出来理论，说明遍历出1个强联通分量
            }
        }
        return ans;
    }
    private void dfs(int i){
        for(int j=0;j<m;j++){
            if(g[i][j]==1&&!flag[j]){
                flag[j]=true;
                dfs(j);
            }
        }
    }
}
```

## [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)

> 用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。
>
> 网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。
>
> 给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202101301843.png)
>
> 输入：n = 4, connections = [[0,1],[0,2],[1,2]]
> 输出：1
> 解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。
> 示例 2：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202101437082.png)
>
> 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
> 输出：2
> 示例 3：
>
> 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
> 输出：-1
> 解释：线缆数量不足。
> 示例 4：
>
> 输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]
> 输出：0
>
>
> 提示：
>
> 1 <= n <= 10^5
> 1 <= connections.length <= min(n*(n-1)/2, 10^5)
> connections[i].length == 2
> 0 <= connections[i][0], connections[i][1] < n
> connections[i][0] != connections[i][1]
> 没有重复的连接。
> 两台计算机不会通过多条线缆连接

```java
class Solution {
    int[] p;//用于给点进行编号
    public int find(int x){//寻找祖先
        if(p[x]==x) return x;//如果该点的下标与该点的编号一致，就认为该点就是祖先
        return p[x]=find(p[x]);//将遇到的点的编号都设置为祖先的编号
    }
    public int makeConnected(int n, int[][] connections) {
        p=new int[n];//定义数组
        int m=connections.length;//求出线缆的个数
        if(n-1>m) return -1;//如果线缆的个数小于节点数组就说明不够连得
        for(int i=0;i<n;i++) p[i]=i;//对节点进行初始化，将节点数作为下标吗，值i作为编号
        int ans=n-1;//节点总数
        for(int[] temp:connections){
            int x=find(temp[0]);//寻找该点的祖先
            int y=find(temp[1]);//寻找该点的祖先
            if(x!=y){//如果祖先不相同，就进行合并
                p[x]=y;//两个节点连接
                ans--;//就减去1个节点
            }
        }
        return ans;//剩下的单个节点数
    }
}
```

- 此题目的就是让求单个节点的数目

## [1376. 通知所有员工所需的时间](https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/)

> 公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。
>
> 在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。
>
> 公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。
>
> 第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。
>
> 返回通知所有员工这一紧急消息所需要的 分钟数 。
>
> 
>
> 示例 1：
>
> 输入：n = 1, headID = 0, manager = [-1], informTime = [0]
> 输出：0
> 解释：公司总负责人是该公司的唯一一名员工。
> 示例 2：
>
> 
>
> 输入：n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
> 输出：1
> 解释：id = 2 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 1 分钟来通知所有员工。
> 上图显示了公司员工的树结构。
> 示例 3：
>
> 
>
> 输入：n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1]
> 输出：21
> 解释：总负责人 id = 6。他将在 1 分钟内通知 id = 5 的员工。
> id = 5 的员工将在 2 分钟内通知 id = 4 的员工。
> id = 4 的员工将在 3 分钟内通知 id = 3 的员工。
> id = 3 的员工将在 4 分钟内通知 id = 2 的员工。
> id = 2 的员工将在 5 分钟内通知 id = 1 的员工。
> id = 1 的员工将在 6 分钟内通知 id = 0 的员工。
> 所需时间 = 1 + 2 + 3 + 4 + 5 + 6 = 21 。
> 示例 4：
>
> 输入：n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]
> 输出：3
> 解释：第一分钟总负责人通知员工 1 和 2 。
> 第二分钟他们将会通知员工 3, 4, 5 和 6 。
> 第三分钟他们将会通知剩下的员工。
> 示例 5：
>
> 输入：n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914]
> 输出：1076
>
>
> 提示：
>
> 1 <= n <= 10^5
> 0 <= headID < n
> manager.length == n
> 0 <= manager[i] < n
> manager[headID] == -1
> informTime.length == n
> 0 <= informTime[i] <= 1000
> 如果员工 i 没有下属，informTime[i] == 0 。
> 题目 保证 所有员工都可以收到通知。

```java
class Solution {
    int[] m,t;//上下级关系数组、时间数组
    int len,ans;//存储时间、最终结果
    List<Integer>[] l;//存储树，每个空间都能够存放集合
    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {//先建树，然后DFS
        len=n;m=manager;t=informTime;
        if(n==1) return 0;//如果只有1个人就直接返回0
        hs();//建树
        dfs(headID,0);//DFS
        return ans;//返回最终结果
    }
    private void hs(){
        l=new ArrayList[len];//定义数组
        for(int i=0;i<len;i++){//分别遍历每一个成员，上级作下标，下级作为值
            if(m[i]==-1) continue;//如果下标为-1，则不进行处理
            if(l[m[i]]==null) l[m[i]]=new ArrayList<>();//如果该数位置还没定义就进行定义
            l[m[i]].add(i);//将他的下级加到该集合中
        }
    }
    private void dfs(int i,int temp){
        if(l[i]==null){//如果该成员没有下级，就说明走到底了，就进行判断最大值，返回
            ans=Math.max(ans,temp);
            return;
        }
        for(int j:l[i]){//遍历每一个下属
            dfs(j,temp+t[i]);//之前花费的时间+该上级花费到下级的时间
        }
    }
}
```

# 并查集

## [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

> 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
>
> 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
>
> 
>
> 示例 1：
>
> 输入：nums = [100,4,200,1,3,2]
> 输出：4
> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
> 示例 2：
>
> 输入：nums = [0,3,7,2,5,8,4,6,0,1]
> 输出：9
>
> ![image-20220211225537007](https://gitee.com/demon_night/images/raw/master/imgs/202202112255368.png)
>

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Arrays.sort(nums);//将数组进行排序
        if(nums.length==0) return 0;//如果数组里面没有值，就返回0
        int ans=1;//存储最终的结果
        int temp=1;//存储中间的结果
        for(int i=1;i<nums.length;i++){//遍历数组中的每一个值
            if(nums[i]==nums[i-1]+1||nums[i]==nums[i-1]){//如果前一个值等于后一个值+1，或者两个相等，就判断成是连续的
                if(nums[i]!=nums[i-1]) temp++;//如果不相等，连续子序列长度就+1，否则不加
                ans=Math.max(ans,temp);//判断是否大于之前遇到的最长连续子序列
            }else{
                temp=1;//如果连续断了，就重置temp
            }
        }
        return ans;//返回最终的结果
    }
}
```

## [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

> 给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202122302594.jpeg)
>
>
> 输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
> 输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
> 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
> 示例 2：
>
> 输入：board = [["X"]]
> 输出：[["X"]]
>
>
> 提示：
>
> m == board.length
> n == board[i].length
> 1 <= m, n <= 200
> board[i][j] 为 'X' 或 'O'

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1};
    int[] dy=new int[]{1,0,-1,0};
    public void solve(char[][] board) {
        int m=board.length;
        int n=board[0].length;
        Queue<int[]> q=new LinkedList<>();
        //使用BFS将边缘的联通‘O'转换成’T'
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0||j==0||i==m-1||j==n-1){
                    if(board[i][j]=='O'){
                        q.offer(new int[]{i,j});
                        board[i][j]='T';
                        while(!q.isEmpty()){
                            int[] temp=q.poll();
                            for(int t=0;t<4;t++){
                                int x=temp[0]+dx[t];
                                int y=temp[1]+dy[t];
                                if(x>=0&&x<m&&y>=0&&y<n&&board[x][y]=='O'){
                                    q.offer(new int[]{x,y});
                                    board[x][y]='T';
                                }
                            }
                        }
                    }
                }
            }
        }
        //使用BFS将里面的遇到‘O'转成’X‘，与边缘相连的’O‘已经被转成了’T‘
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]=='O'){
                    q.offer(new int[]{i,j});
                    board[i][j]='X';
                    while(!q.isEmpty()){
                        int[] temp=q.poll();
                        for(int t=0;t<4;t++){
                            int x=temp[0]+dx[t];
                            int y=temp[1]+dy[t];
                            if(x>=0&&x<m&&y>=0&&y<n&&board[x][y]=='O'){
                                q.offer(new int[]{x,y});
                                board[x][y]='X';
                            }
                        }
                    }
                }
            }
        }
        //遍历二维数组，将所有的’T‘转换成’O‘
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]=='T'){
                    board[i][j]='O';
                }
            }
        }
    }
}
```

## [990. 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)

> 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
>
> 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 
>
> 
>
> 示例 1：
>
> 输入：["a==b","b!=a"]
> 输出：false
> 解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
> 示例 2：
>
> 输入：["b==a","a==b"]
> 输出：true
> 解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
> 示例 3：
>
> 输入：["a==b","b==c","a==c"]
> 输出：true
> 示例 4：
>
> 输入：["a==b","b!=c","c==a"]
> 输出：false
> 示例 5：
>
> 输入：["c==c","b==d","x!=z"]
> 输出：true
>
>
> 提示：
>
> 1 <= equations.length <= 500
> equations[i].length == 4
> equations[i][0] 和 equations[i][3] 是小写字母
> equations[i][1] 要么是 '='，要么是 '!'
> equations[i][2] 是 '='

```java
class Solution {
    int[] p=new int[26];
    private void init(){//初始化
        for(int i=0;i<26;i++) p[i]=i;
    }
    private void union(int a,int b){//"并"
        p[f(a)]=f(b);
    }
    private int f(int t){//查
        if(p[t]==t) return t;
        else return p[t]=f(p[t]);
    }
    public boolean equationsPossible(String[] equations) {
        init();
        for(String s:equations){
            if(s.charAt(1)=='='){
                union(s.charAt(0)-'a',s.charAt(3)-'a');
            }
        }
        for(String s:equations){
            if(s.charAt(1)=='!'){
                if(f(s.charAt(0)-'a')==f(s.charAt(3)-'a')) return false;
            }
        }
        return true;
    }
}
```

## [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

> 树可以看成是一个连通且 无环 的 无向 图。
>
> 给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。
>
> 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202162203097.png)
>
> 输入: edges = [[1,2], [1,3], [2,3]]
> 输出: [2,3]
> 示例 2：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202162203757.png)
>
> 输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
> 输出: [1,4]
>
>
> 提示:
>
> n == edges.length
> 3 <= n <= 1000
> edges[i].length == 2
> 1 <= ai < bi <= edges.length
> ai != bi
> edges 中无重复元素
> 给定的图是连通的 

```java
class Solution {
    int[] p;//节点数组
    private void init(int n){
        for(int i=1;i<n;i++) p[i]=i;//赋初值
    }
    private void union(int a,int b){
        if(find(a)!=find(b)) p[find(b)]=find(a); //如果两个节点属于同一个集合，就进行合并
    }
    private int find(int x){
        if(p[x]==x) return x;//如果该节点的下标与值相同，就说明该节点是根节点，就返回该下标【下标是唯一确定的，用于表示值，值则是标志】
       else return p[x]=find(p[x]);//如果不同，进行递归，一层层往下找
    }
    public int[] findRedundantConnection(int[][] edges) {
        int n=edges.length;//节点个数
        p=new int[n+1];//定义数组
        init(n);//对节点进行初始化
        for(int[] i:edges){//遍历每个节点
            if(find(i[0])!=find(i[1])) union(i[0],i[1]);//如果这两个连通点还没有连通，就进行合并
            else return i;//如果这两个点属于同一个集合，就说明该连通边就是导通树成为图的边，返回该节点
        }
        return new int[0];//如果
    }
}
```

## [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)

> 给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。
>
> 另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。
>
> 返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。
>
> 注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。
>
> 
>
> 示例 1：
>
> 输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
> 输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
> 解释：
> 条件：a / b = 2.0, b / c = 3.0
> 问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
> 结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
>
> 示例 2：
>
> 输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
> 输出：[3.75000,0.40000,5.00000,0.20000]
>
> 示例 3：
>
> 输入：equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
> 输出：[0.50000,2.00000,-1.00000,-1.00000]
>
> ![image-20220218224021796](https://gitee.com/demon_night/images/raw/master/imgs/202202182240249.png)

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int n=equations.size();//变量对个数
        union_find u=new union_find(n*2);//并查集
        Map<String,Integer> m=new HashMap<>();//利用哈希表的映射，将变量名与数值相对应
        int temp=0;//普通变量
        for(int i=0;i<n;i++){//遍历每一个变量对，进行映射
            List<String> l=equations.get(i);
            String a=l.get(0);
            String b=l.get(1);
            if(!m.containsKey(a)) m.put(a,temp++);//进行映射
            if(!m.containsKey(b)) m.put(b,temp++);
            u.union(m.get(a),m.get(b),values[i]);//将两个变量进行“联系”
        }
        int temp1=queries.size();//需要判断的变量对的个数
        double[] ans=new double[temp1];//存放结果的数组
        for(int i=0;i<temp1;i++){//遍历每一个变量对
            List<String> l=queries.get(i);
            String a=l.get(0);
            String b=l.get(1);
            //只有Integer这种对象才可以判断是否为空
            Integer num_a=m.get(a);
            Integer num_b=m.get(b);
            if(num_a==null||num_b==null){//如果找不到该变量，就将存放结果的数组的该位置置为-1
                ans[i]=-1.0d;
            }else{
                ans[i]=u.pd(num_a,num_b);//否则计算得到结果
            }
        }
        return ans;
    }
    private class union_find{
        private int[] p;//父亲数组
        private double[] w;//权值数组
        public union_find(int n){//进行初始化，各自是各自的根节点
            p=new int[n];
            w=new double[n];
            for(int i=0;i<n;i++){
                p[i]=i;
                w[i]=1.0d;
            }
        }
        public void union(int a,int b,double value){//将两个进行进行“联系”
            int root_a=find(a);//找到该变量的根节点
            int root_b=find(b);//找到该变量的根节点
            if(root_a==root_b) return;//如果两个根节点相同，则就不需要“联系”了
            p[root_a]=root_b;//否则，相连
            w[root_a]=w[b]*value/w[a];//只能是根指向子节点，因为根节点只能存一个值
        }
        public int find(int x){
            if(p[x]==x) return x;//如果该点的值等于下标，就说明该节点是根节点
            else {
                int temp1=p[x];//必须要有个暂存变量
                p[x]=find(p[x]);
                w[x]*=w[temp1];//不能写成w[x]*=w[p[x]],因为这是引用，递归后p[x]都为根节点下标
                return p[x];//返回根节点的值
            }
        }
        public double pd(int a,int b){//得到两个变量相除结果
            int root_a=find(a);//找到该变量的根节点
            int root_b=find(b);//找到该变量的根节点
            if(root_a==root_b) return w[a]/w[b];//如果是有“联系”，计算结果
            else return -1.0d;//否则返回-1
        }
    }
}
```

- 只有Integer这种对象才可以判断是否为空
- ![image.png](https://gitee.com/demon_night/images/raw/master/imgs/202202182305691.png)

## [721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)

>给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。
>
>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。
>
>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 按字符 ASCII 顺序排列 的邮箱地址。账户本身可以以 任意顺序 返回。
>
>
>
>示例 1：
>
>输入：accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
>输出：[["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
>解释：
>第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 "johnsmith@mail.com"。 
>第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。
>可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，
>['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。
>
>示例 2：
>
>输入：accounts = [["Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"],["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]
>输出：[["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]
>
>
>
>提示：
>
>1 <= accounts.length <= 1000
>2 <= accounts[i].length <= 10
>1 <= accounts[i][j].length <= 30
>accounts[i][0] 由英文字母组成
>accounts[i][j] (for j > 0) 是有效的邮箱地址
>

```java
class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        Map<String,Integer> email_index=new HashMap<>();//邮箱与数值进行映射，一个地址获得一个专属下标
        Map<String,String> email_name=new HashMap<>();//邮箱与名字进行映射
        int temp=0;//普通变量，用于值得映射
        for(List<String> l:accounts){//遍历每一个账户，用于邮箱与数值、名字与邮箱的映射
            String name=l.get(0);//得到当前账户的名字
            int size=l.size();//获得该账户的邮箱个数
            for(int i=1;i<size;i++){
                String email=l.get(i);//获得当前邮箱
                if(!email_index.containsKey(email)){//检查当前邮箱是否已经被添加过了
                    email_index.put(email,temp++);//进行映射
                    email_name.put(email,name);//进行映射
                }
            }
        }
        union_find u=new union_find(temp);//并查集格式
        for(List<String > l:accounts){//遍历每一个账户，将该账户的所有邮箱进行“联系”
            String email1=l.get(1);//获得第一个邮箱地址
            Integer index1=email_index.get(email1);//获得第一个邮箱所对应的数值
            int size=l.size();//获得该账户的邮箱个数
            for(int i=2;i<size;i++){//将第一个邮箱与当前账户的其他邮箱进行“联系”
                String email2=l.get(i);
                Integer index2=email_index.get(email2);
                u.union(index1,index2);
            }
        }
        HashMap<Integer,List<String>> index_email=new HashMap<>();//存储邮箱与集合根节点的映射关系
        for(String email:email_index.keySet()){//遍历所有的邮箱
            int num=email_index.get(email);//获得该邮箱的所对应的数值
            int index=u.find(num);//获得该数值对应的根节点
            List<String> account=index_email.getOrDefault(index,new ArrayList<>());//如果该根节点创建过集合，就将当前邮箱加到集合里面
            account.add(email);
            index_email.put(index,account);//进行根节点领导多个邮箱的关系
        }
        List<List<String>> ans=new ArrayList<>();//存储最终结果的集合
        for(List<String> email:index_email.values()){//遍历根节点与邮箱的集合【因为已经泛型了，可以直接使用values方法】
            Collections.sort(email);//将邮箱按照ASCLL码进行排序
            String email1=email.get(0);//获得当前一个邮箱集合的第一邮箱
            String name=email_name.get(email1);//找到该邮箱的主人名字
            List<String> l=new ArrayList<>();//定义一个集合
            l.add(name);//将名字添加到第一个位置
            l.addAll(email);//将邮箱集合添加到集合中
            ans.add(l);//将该集合添加到结果中
        }
        return ans;//返回最终结果
    }
}
class union_find{//并查集模板
    int p[];//父亲结点
    public union_find(int n){//初始化
        p=new int[n];
        for(int i=0;i<n;i++) p[i]=i;
    }
    public void union(int a,int b){//将两个结点所对应的集合进行“联系”
        p[find(a)]=find(b);
    }
    public int find(int x){//找到该值的父亲结点
        if(p[x]==x) return x;
        return p[x]=find(p[x]);
    }
}
```

- 

  - ```
    hashmap.getOrDefault(Object key, V defaultValue)
    ```

  - 如果找到对应的key则返回key对应的value，返回defalutValue

- 整体思路：并查集联系时是针对数值的，因此需要详见邮箱与数值进行映射，然后遍历账户的邮箱，将给出的账户里面的邮箱进行联系，就会得到一个个邮箱集合，然后通过遍历所有邮箱，根据根节点将其放入到集合中，找到每个邮箱集合的主人名称，将他放进最终的集合里面，返回即可。

## [765. 情侣牵手](https://leetcode-cn.com/problems/couples-holding-hands/)

> #### 
>
> `n` 对情侣坐在连续排列的 `2n` 个座位上，想要牵到对方的手。
>
> 人和座位由一个整数数组 `row` 表示，其中 `row[i]` 是坐在第 `i `个座位上的人的 **ID**。情侣们按顺序编号，第一对是 `(0, 1)`，第二对是 `(2, 3)`，以此类推，最后一对是 `(2n-2, 2n-1)`。
>
> 返回 *最少交换座位的次数，以便每对情侣可以并肩坐在一起*。 *每次*交换可选择任意两人，让他们站起来交换座位。
>
> 
>
> **示例 1:**
>
> ```
> 输入: row = [0,2,1,3]
> 输出: 1
> 解释: 只需要交换row[1]和row[2]的位置即可。
> ```
>
> **示例 2:**
>
> ```
> 输入: row = [3,2,0,1]
> 输出: 0
> 解释: 无需交换座位，所有的情侣都已经可以手牵手了。
> ```
>
> 
>
> **提示:**
>
> - `2n == row.length`
> - `2 <= n <= 30`
> - `n` 是偶数
> - `0 <= row[i] < 2n`
> - `row` 中所有元素均**无重复**

```java
class Solution {
    public int minSwapsCouples(int[] row) {
        int n=row.length;//记录人数
        union_find u=new union_find(n/2);//将一对情侣看成一个结点
        for(int i=0;i<n;i+=2){
            u.union(row[i]/2,row[i+1]/2);//向下取整可以将一对情侣看成一个点
        }
        return n/2-u.getCount();//情侣对数-连通分量就是要交换的次数
    }
}
class union_find{
    int[] p;
    int count;//用于返回连通分量情侣对数-非情侣间的连接数
    public int getCount(){
        return count;
    }
    public union_find(int n){//进行初始化
        count=n;
        p=new int[n];
        for(int i=0;i<n;i++) p[i]=i;
    }
    public void union(int a,int b){//非情侣之间进行“联系”
        if(find(a)==find(b)) return;
        else {
            p[find(a)]=find(b);
            count--;
        }
    }
    public int find(int x){//寻找根节点
        if(p[x]==x) return x;
        else return p[x]=find(p[x]);
    }
}
```

- 首先要知道一对情侣可以看成1个节点，因为除2向下取整可以将一对情侣看成1个节点，例如0,1
- 其次要知道：
  - ![image-20220223211755254](https://gitee.com/demon_night/images/raw/master/imgs/202202232118982.png)
  - 其次对于“0 4 1 2 3 5 ”可以看做0和2、0和1、1和2产生联系（在进行联系时向下取整了），由于0和1,0和1产生联系就说明0,1,2处于同一个连通分量，因此对于1和2就不会再次进行相连，同样，count也不会再－1
  - 对于1个连通分量一定是彼此牵扯的，例如：三对情侣成为1个连通分量，1=3-2、1=2-1==》5-2=3

# 博弈论

## [292. Nim 游戏](https://leetcode-cn.com/problems/nim-game/)

> 你和你的朋友，两个人一起玩 Nim 游戏：
>
> 桌子上有一堆石头。
> 你们轮流进行自己的回合， 你作为先手 。
> 每一回合，轮到的人拿掉 1 - 3 块石头。
> 拿掉最后一块石头的人就是获胜者。
> 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。
>
> 
>
> 示例 1：
>
> 输入：n = 4
> 输出：false 
> 解释：以下是可能的结果:
> 1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
> 2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
> 3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
> 在所有结果中，你的朋友是赢家。
> 示例 2：
>
> 输入：n = 1
> 输出：true
> 示例 3：
>
> 输入：n = 2
> 输出：true
>
> ![image-20220217165351945](https://gitee.com/demon_night/images/raw/master/imgs/202202171653338.png)
>

```java
class Solution {
    public boolean canWinNim(int n) {
        if(n%4==0) return false;
        else return true;
    }
}
```

- 总是按照想让自己成功来取石子，来进行找规律，只有三个石子，无论如何自己都能赢，如果是4个，无论如何都赢不了，挨个往下试，发现每四个一循环“赢赢赢输”

# 蓝桥杯

## 辗转相除法

![image-20220220204936701](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220220204936701.png)

![image-20220220205254270](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220220205254270.png)

> ![image-20220220211053529](https://gitee.com/demon_night/images/raw/master/imgs/202202202110869.png)

```java
public class LQB_test1 {
    public static void main(String[] args) {
        int ans=0;
        for(int i=1;i<=2020;i++){
            for(int j=1;j<=2020;j++){
                if(find(i,j)==1) ans++;
            }
        }
        System.out.println(ans);
    }
    public static int find(int a,int b){
        int r=a%b;
        if(r==0) return b;
        else return find(b,a%b);
    }
}
```

## 蛇形填数

> ![image-20220220223335686](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220220223335686.png)

```java
public class LQB_test2 {
    public static void main(String[] args) {
        int ans=0;
        for(int i=1;i<20;i++){
            ans+=4*i;
        }
        System.out.println(ans+1);
    }
}
```

- 找规律：1-5-13==1-1+1$\cdot$4-1+1$\cdot$4+2*4

## 闰年与非闰年

- 闰年能被4整除但是不能被100整除
- 闰年能被400整除
- 闰年的2月份29天，非闰年的2月份28天

## 跑步锻炼

> ![image-20220221231429439](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220221231429439.png)

```java
package LQB;

import java.util.Scanner;

public class LQB_test3 {
    public static void main(String[] args) {
        int[][] run={{0,31,28,31,30,31,30,31,31,30,31,30,31},{0,31,29,31,30,31,30,31,31,30,31,30,31}};
        int y=2000,m=1,d=1;
        int ans=0;
        int week_num=6;
        while(!(y==2020&&m==10&&d==1)){
            if(week_num>=8) week_num=1;
            if(week_num==1||d==1) ans+=2;
            else ans+=1;
            d++;
            week_num++;
            int temp=pd(y);
            if(d>run[temp][m]) {
                d=1;
                m++;
            }
            if(m>=13){
                m=1;
                y++;
            }
        }
        System.out.println(ans+2);
    }
    public static int pd(int y){
        if((y%4==0&&y%100!=0)||y%400==0) return 1;
        else return 0;
    }
}
```

## 成绩统计

>小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是一个 0 到 100 的整数。
>
>如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。
>
>请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整 数。
>
>### 输入描述
>
>输入的第一行包含一个整数 n\ (1 \leq n \leq 10^4)*n* (1≤*n*≤104)，表示考试人数。
>
>接下来 n*n* 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。
>
>### 输出描述
>
>输出两行，每行一个百分数，分别表示及格率和优秀率。百分号前的部分 四舍五入保留整数。
>
>### 输入输出样例
>
>#### 示例
>
>> 输入
>
>```txt
>7
>80
>92
>56
>74
>88
>100
>0
>```
>
>> 输出
>
>```txt
>71%
>43%
>```

```java
package LQB;

import java.util.Scanner;

public class LQB_test4 {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int a=0,b=0;
        for(int i=0;i<n;i++){
            int temp=sc.nextInt();
            if(temp>=60) a++;
            if(temp>=85) b++;
        }
        System.out.println(Math.round((a*100.0)/n)+"%");
        System.out.print(Math.round((b*100.0)/n)+"%");
    }
}
```

- 对小数进行四舍五入：Math的round()方法可以实现

## 子串分值和【`没理解`】

> 对于一个字符串 S*S*，我们定义 S*S* 的分值 f(S)*f*(*S*) 为 S*S* 中出现的不同的字符个数。例如 f(“aba”) = 2，f(“abc”) = 3, f(“aaa”) = 1*f*(“*a**b**a*”)=2，*f*(“*a**b**c*”)=3,*f*(“*a**a**a*”)=1。
>
> 现在给定一个字符串 S [0...n − 1]*S*[0...*n*−1]（长度为 n*n*），请你计算对于所有 S*S* 的非空子串 S [i...j](0 ≤ i ≤ j < n)*S*[*i*...*j*](0≤*i*≤*j*<*n*)，f(S [i...j])*f*(*S*[*i*...*j*]) 的和是多少。
>
> ### 输入描述
>
> 输入一行包含一个由小写字母组成的字符串 S*S*。
>
> 其中，1 ≤ n ≤ 10^51≤*n*≤105。
>
> ### 输出描述
>
> 输出一个整数表示答案。
>
> ### 输入输出样例
>
> #### 示例 1
>
> > 输入
>
> ```txt
> ababc
> ```
>
> > 输出
>
> ```txt
> 28
> ```

```java
package LQB;

import java.util.Scanner;

public class LQB_test6 {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int[] array=new int[26];
        Long ans=0L;
        for (int i=0;i<26;i++) array[i]=-1;
        String s=sc.next();
        char[] str=s.toCharArray();
        int index=str.length;
        for(int i=0;i<index;i++){
            int last_index=array[str[i]-97];
            ans+=(long)1L*(i-last_index)*(index-i);
            array[str[i]-97]=i;
        }
        System.out.println(ans);
    }
}
```

- 将字符串直接赋给StringBuilder对象

  - ```java
    StringBuilder s=new StringBuilder(sc.next());
    ```

- 截取StringBuilder对象的部分内容

  - ```java
    s.substring(i,j);//看清楚String的“s”是小写的
    ```

- 看set集合是否存在某个元素

  - ```java
    set.contains(temp.charAt(m)
    ```

# 贪心

## [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

> 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
>
> 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。
>
> 说明：你不能倾斜容器。
>
> 
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202202241632878.jpeg)
>
> 输入：[1,8,6,2,5,4,8,3,7]
> 输出：49 
> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
> 示例 2：
>
> 输入：height = [1,1]
> 输出：1
>
> ![image-20220224163152499](https://gitee.com/demon_night/images/raw/master/imgs/202202241631646.png)

```java
class Solution {
    public int maxArea(int[] height) {
        int ans=0,n=height.length;
        int l=0,r=n-1;
        while(l<r){
            int temp=Math.min(height[l],height[r])*(r-l);
            ans=Math.max(ans,temp);
            if(height[l]<=height[r]){
                l++;
            }else r--;
        }
        return ans;
    }
}
```

- 解法：双指针
- 影响区域的大小的永远是小的那一边，因此，哪边矮就移动哪边

## [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

> 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
>
> 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
>
> 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
>
> 
>
> 示例 1:
>
> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
> 输出: 3
> 解释:
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。
> 示例 2:
>
> 输入: gas = [2,3,4], cost = [3,4,3]
> 输出: -1
> 解释:
> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。
>
> ![image-20220228215328903](https://gitee.com/demon_night/images/raw/master/imgs/202202282153255.png)

![image-20220228215254123](https://gitee.com/demon_night/images/raw/master/imgs/202202282212568.png)

![image-20220228221230177](https://gitee.com/demon_night/images/raw/master/imgs/202202282212361.png)

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n=gas.length;//记录个数
        int ans=0;//油箱里面油的剩余量
        for(int i=0;i<n;){//遍历整个圆
            ans=gas[i];//先把当前加油站的油取完
            int j=i;//中间变量
            while(ans-cost[j]>=0){//如果能跑到下一站就继续跑
                ans=ans-cost[j]+gas[(j+1)%n];//变换油量
                j=(j+1)%n;//由于是个环，就进行取余操作
                if(i==j) return i;//如果走到了最开始的地方就说明这个加油站可以完成目标
            }
            if(j<i) return -1;//如过完不成目标，就将该车停到走到最远的地方的下一个，因为如果最初的加油站则其中任何一个加油站都走不出这个范围，因为走完一段路程油箱剩余的油>=0，j<i说明走完了一圈，如果让j=i+1，则就重复了，因此就退出即可
            i=j+1;//就将车停到能跑的最远处+1
        }
        return -1;
    }  
}
```

- 处理环的问题一般用到“取余操作”

## [179. 最大数](https://leetcode-cn.com/problems/largest-number/)

> 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。
>
> 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。
>
> 
>
> 示例 1：
>
> 输入：nums = [10,2]
> 输出："210"
> 示例 2：
>
> 输入：nums = [3,30,34,5,9]
> 输出："9534330"
>
> ![image-20220301213814119](https://gitee.com/demon_night/images/raw/master/imgs/202203012138682.png)

```java
class Solution {
    public String largestNumber(int[] nums) {
        int n=nums.length;
        List<String> l=new ArrayList<>();
        for(int i:nums) l.add(i+"");
        l.sort(new Comparator<String>(){
            public int compare(String a,String b){
                String s1=a+b;
                String s2=b+a;
                return s2.compareTo(s1);
            }
        });
        StringBuilder ans=new StringBuilder();
        for(String temp:l) ans.append(temp);
        if(ans.charAt(0)=='0') return "0";
        return ans.toString();
    }
}
```

- 将数字数组转成字符串数组

  - ```java
    for(int i:nums) l.add(i+"");
    ```

- 集合的排序对象是`new Comparator<>(){}`、重写比较方法是`compare()`、字符串的比较方法是`compareTo()`

  - 字符串的比较方法**按字典顺序从小到大排序。**
  - 由于30>3,会把3排在30后面，因此需要判断两个数拼接后的大小，因此比较两数如何拼接才最大

- 对于特事故情况**0 0**就判断第一个字符是否为0，因为第一个字符是整个字符串中最大的，因此如果最大的字符为0，则后面都为0，返回0即可

## [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)[还不懂]

> #### 
>
> 给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。
>
> 
>
> **示例 1：**
>
> ```
> 输入：s = "bcabc"
> 输出："abc"
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "cbacdcbc"
> 输出："acdb"
> ```
>
> 
>
> - ![image-20220303203659491](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220303203659491.png)

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        boolean[] vis=new boolean[26];
        int[] num=new int[26];
        for(int i=0;i<s.length();i++) num[s.charAt(i)-'a']++;
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<s.length();i++){
            char ch=s.charAt(i);
            if(!vis[ch-'a']){
                while(sb.length()>0&&sb.charAt(sb.length()-1)>ch){
                    if(num[sb.charAt(sb.length()-1)-'a']>0){
                        vis[sb.charAt(sb.length()-1)-'a']=false;
                        sb.deleteCharAt(sb.length()-1);
                    }else{
                        break;
                    }
                }
                vis[ch-'a']=true;
                sb.append(ch);
            }
            num[ch-'a']-=1;
        }
        return sb.toString();
    }
}
```

## [605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

> #### 
>
> 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
>
> 给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false`。
>
> 
>
> **示例 1：**
>
> ```
> 输入：flowerbed = [1,0,0,0,1], n = 1
> 输出：true
> ```
>
> **示例 2：**
>
> ```
> 输入：flowerbed = [1,0,0,0,1], n = 2
> 输出：false
> ```
>
> ![image-20220304184624850](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220304184624850.png)

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int len=flowerbed.length;
        for(int i=0;i<len;i++){
            if(flowerbed[i]==0&&(i==0||flowerbed[i-1]==0)&&((i+1)==len||flowerbed[i+1]==0)){
                n--;
                flowerbed[i]=1;
                if(n<=0) return true;
            }
        }
        return n<=0;
    }
}
```

- 对于需要从下标0开始判断同时需要判断i-1这种情况时，可以使用`i==0||flowerbed[i-1]==0`,这样可以当i！=0时可以理所应当的去判断前一个值是否为0
- 这里可以种花的条件是：
  - 自己为空
  - 左边为空 或者 自己是最左
  - 右边为空 或者 自己是最右
- 由于n可以为0，n<=0的结果是false、true可以作为返回结果

## [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

> #### 
>
> 给定一个包含大写字母和小写字母的字符串 `s` ，返回 *通过这些字母构造成的 **最长的回文串*** 。
>
> 在构造过程中，请注意 **区分大小写** 。比如 `"Aa"` 不能当做一个回文字符串。
>
> 
>
> **示例 1:** 
>
> ```
> 输入:s = "abccccdd"
> 输出:7
> 解释:
> 我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
> ```
>
> **示例 2:**
>
> ```
> 输入:s = "a"
> 输入:1
> ```
>
> **示例 3:**
>
> ```
> 输入:s = "bb"
> 输入: 2
> ```
>
> 
>
> **提示:**
>
> - `1 <= s.length <= 2000`
> - `s` 只能由小写和/或大写英文字母组成

```java
class Solution {
    public int longestPalindrome(String s) {
        int[] hx=new int[52];
        int len=s.length();
        for(int i=0;i<len;i++){
            char temp=s.charAt(i);
            if(temp>='A'&&temp<='Z'){
                hx[temp-'A']++;
            }else hx[temp-'a'+26]++;
        }
        int ans=0;
        boolean flag=false;
        for(int i=0;i<52;i++){
            if(hx[i]%2==0) ans+=hx[i];
            else {
                ans+=hx[i]-1;
                flag=true;
            }
        }
        if(flag) return ans+1;
        return ans;
    }
}
```

- 首先要知道偶数时一个子回文字符串，因此个数可以加到结果里面
- 对于奇数个的字符，可以将其-1后加到结果中
- 由于回文字符串的个数可以是奇数也可以是偶数，因此需要判断是否有“奇数个”的字符，如果有，结果就加1，如果没有，则说明都是偶数个的，结果就不+1

## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)[贪心+双指针]

>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
>
>示例 1:
>
>输入: g = [1,2,3], s = [1,1]
>输出: 1
>解释: 
>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
>所以你应该输出1。
>
>示例 2:
>
>输入: g = [1,2], s = [1,2,3]
>输出: 2
>解释: 
>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
>你拥有的饼干数量和尺寸都足以让所有孩子满足。
>所以你应该输出2.
>
>![image-20220307202149633](https://gitee.com/demon_night/images/raw/master/imgs/202203072021235.png)

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int l=0,r=0;
        int ans=0;
        int g_len=g.length;
        int s_len=s.length;
        while(l<g_len){
            if(r==s_len) break;
            if(s[r]>=g[l]) {
                ans++;
                l++;
                r++;
            }else{
                r++;
            }
        }
        return ans;
    }
}
```

## [2195. 向数组中追加 K 个整数](https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/)【贪心+集合】

> 给你一个整数数组 nums 和一个整数 k 。请你向 nums 中追加 k 个 未 出现在 nums 中的、互不相同 的 正 整数，并使结果数组的元素和 最小 。
>
> 返回追加到 nums 中的 k 个整数之和。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,4,25,10,25], k = 2
> 输出：5
> 解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。
> nums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。
> 所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。
>
> 示例 2：
>
> 输入：nums = [5,6], k = 6
> 输出：25
> 解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 1 、2 、3 、4 、7 和 8 。
> nums 最终元素和为 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36 ，这是所有情况中的最小值。
> 所以追加到数组中的两个整数之和是 1 + 2 + 3 + 4 + 7 + 8 = 25 ，所以返回 25 。
>
> ![image-20220307202501543](https://gitee.com/demon_night/images/raw/master/imgs/202203072025899.png)

> 等差数列求和

- <img src="https://pic3.zhimg.com/v2-00171242d42a94fd27bbd7c53e1db1e2_r.jpg" alt="查看源图像" style="zoom: 25%;" />

```java
class Solution {
    public long minimalKSum(int[] nums, int k) {
        Arrays.sort(nums);//将数组进行排序
        LinkedHashSet<Integer> h=new LinkedHashSet<>();//放进LinkedHashSet，这样存入顺序和取出顺序一致同时也去重了
        for(int i:nums) h.add(i);//将其添加到集合中
        Long ans=0L;//用于存放最终结果
        int start=1;//等差数列的第一个数；因为我们是按顺序求和的即1,2,3...
        for(int i:h){
            int n=i-start;//数列中个数，也就是两个数之间能够添加的数的个数
            if(n==0) {//如果个数为0，则找下一个值同时要改变数列的值
                start=i+1;
                continue;
            }
            if(k>n){//如果剩余添加的个数大于当前数列的个数，就进行整个数列的求和
                ans+=1L*start*n+1L*n*(n-1)/2;
                k-=n;
            } else {//否则就进行部分数列的求和
                ans+=1L*k*start+1L*k*(k-1)/2;
                k=0;
            }
            start=i+1;//数列的头节点改变
            if(k==0) return ans;
        }
        if(k>0) ans+=1L*k*start+1L*k*(k-1)/2;//如果整个数组里面空余的房间填满了，就进行数组外的数进行额外添加
        return ans;//返回最终结果
    }
}
```

- 哎，大意了，当时等差数列求和忘了Sn=a1**n+n**(n-1)/2

  还有一点需要注意的是对于中间变量如：1L**n**(n-1)/2;必须要乘1L否则默认存储长度是int类型的，因此我们需要将其乘于1L，这样就会将这个表达式的结果放在longlong空间大小的存储空间中，这一定要总结教训！！！

## [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

> 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
>
> 
>
> 示例 1:
>
> 输入: s = "aba"
> 输出: true
>
> 示例 2:
>
> 输入: s = "abca"
> 输出: true
> 解释: 你可以删除c字符。
>
> 示例 3:
>
> 输入: s = "abc"
> 输出: false
>
> ![image-20220308195404358](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220308195404358.png)

```java
class Solution {
    public boolean validPalindrome(String s) {
        int len=s.length();
        String s1="";
        String s2="";
        int l=0,r=len-1;
        while(l<r){
            char temp1=s.charAt(l),temp2=s.charAt(r);
            if(temp1==temp2){
                ++l;
                --r;
            }else{
                s1=s.substring(l,r);
                s2=s.substring(l+1,r+1);
                return pd(s1)||pd(s2);
            }
        }
        return true;
    }
    public boolean pd(String s){
        int len=s.length();
        int l=0,r=len-1;
        while(l<r){
            if(s.charAt(l)!=s.charAt(r)) return false;
            l++;
            r--;
        }
        return true;
    }
}
```

- 对于“cuucu”的解决办法是分成两份,而不是进行两次if判断

  ```java
  s1=s.substring(l,r);
  s2=s.substring(l+1,r+1);
  return pd(s1)||pd(s2);
  ```


## [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

> #### 
>
> 假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。
>
> 请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。
>
> 
>
> 
>
> **示例 1：**
>
> ```
> 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
> 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
> 解释：
> 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
> 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
> 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
> 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
> 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
> 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
> 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
> ```
>
> **示例 2：**
>
> ```
> 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
> 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
> ```
>
> ![image-20220310214224837](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220310214224837.png)

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,(o1,o2)->o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0]);
        List<int[]> l=new ArrayList<>();
        for(int[] i:people){
            l.add(i[1],i);
        }
        return l.toArray(new int[l.size()][2]);
    }
}
```

- k-v:k逆序排列，v正序排列

- Lambda表达式：o1-o2:从小到大；o2-o1：从大到小

- List.add(int index,int num):可以使用下标对集合进行添加数据

- List.toArray(T[] a):用于存储数组元素的数组，必须要实例化

  - ```java
    		sites.add("Runoob");
            sites.add("Google");
            sites.add("Wiki");
            sites.add("Taobao");
            System.out.println("网站列表: " + sites);
      
            // 创建一个新的 String 类型的数组
            // 数组长度和 ArrayList 长度一样
            String[] arr = new String[sites.size()];
      
            // 将ArrayList对象转换成数组
            sites.toArray(arr);
    ```

## [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
> 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。
>
> 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
> 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
> 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,7,4,9,2,5]
> 输出：6
> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
> 示例 2：
>
> 输入：nums = [1,17,5,10,13,15,10,5,16,8]
> 输出：7
> 解释：这个序列包含几个长度为 7 摆动序列。
> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
> 示例 3：
>
> 输入：nums = [1,2,3,4,5,6,7,8,9]
> 输出：2
>
>
> 提示：
>
> 1 <= nums.length <= 1000
> 0 <= nums[i] <= 1000

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n=nums.length;
        if(n==1) return 1;
        int pre_diff=nums[1]-nums[0];
        int ans=pre_diff==0 ? 1:2;
        for(int i=2;i<n;i++){
            int next_diff=nums[i]-nums[i-1];
            if((pre_diff<=0&&next_diff>0)||pre_diff>=0&&next_diff<0){
                ans++;
                pre_diff=next_diff;
            }
        }
        return ans;
    }
}
```

- 贪心，永远将数列保持成一个跌宕起伏的数列，不满足就直接判断下一个
- 对于**if((pre_diff<=0&&next_diff>0)||pre_diff>=0&&next_diff<0)**为什么要用等于号，是为了解决刚开始两数相差为0的情况，由于next_diff不能为0，而pre_diff是由next_diff得到，因此，在后续筛除后的队列中不会出现相差为0的情况
- **pre_diff<=0&&next_diff>0)||pre_diff>=0&&next_diff<0**正好将两种情况都描述出来

# 链表

## [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

> 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。
>
> 
>
> 示例 1：
>
> 输入：head = [1,1,2]
> 输出：[1,2]
>
> 示例 2：
>
> 输入：head = [1,1,2,3,3]
> 输出：[1,2,3]
>
> 
>
> 提示：
>
>  链表中节点数目在范围 [0, 300] 内
>  -100 <= Node.val <= 100
>  题目数据保证链表已经按升序 排列
>

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode pre_node=head;
        if(head==null) return head;
        ListNode next_node=head.next;
        while(next_node!=null){
            if(pre_node.val==next_node.val){
                pre_node.next=next_node.next;
                next_node=pre_node.next;
            }else{
                pre_node=next_node;
                next_node=next_node.next;
            }
        }
        return head;
    }
}
```

## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。
>
> 图示两个链表在节点 c1 开始相交：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)
>
> 题目数据 保证 整个链式结构中不存在环。
>
> 注意，函数返回结果后，链表必须 保持其原始结构 。
>
> 自定义评测：
>
> 评测系统 的输入如下（你设计的程序 不适用 此输入）：
>
>  intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
>  listA - 第一个链表
>  listB - 第二个链表
>  skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
>  skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数
>
> 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。
>
> 
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)
>
> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
> 输出：Intersected at '8'
> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
>
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)
>
> 输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
> 输出：Intersected at '2'
> 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
> 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
>
> 示例 3：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)
>
> 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
> 输出：null
> 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
> 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
> 这两个链表不相交，因此返回 null 。
>
> ![image-20220314230258872](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220314230258872.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> s=new LinkedHashSet<>();
        ListNode temp=headA;
        while(temp!=null) {
            s.add(temp);
            temp=temp.next;
        }
        temp=headB;
        ListNode ans=null;
        while(temp!=null){
            if(s.contains(temp)){
                ListNode temp1=temp;
                while(temp1!=null){
                    if(!s.contains(temp1)) break;
                    temp1=temp1.next;
                }
                if(temp1==null)  {
                    return temp;
                }
            }
            temp=temp.next;
        }
        return ans;
    }
}
```

## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

> #### 
>
> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)
>
> ```
> 输入：head = [1,2,6,3,4,5,6], val = 6
> 输出：[1,2,3,4,5]
> ```
>
> **示例 2：**
>
> 
>
> ```
> 输入：head = [], val = 1
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [7,7,7,7], val = 7
> 输出：[]
> 
> ```

![image-20220314232810543](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220314232810543.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode ans=new ListNode(0);
        ListNode ans1=ans;
        ListNode temp=head;
        while(temp!=null){
            if(temp.val!=val) {
                ans1.next=new ListNode(temp.val);//重新建立个结点，连接成一个dan'lia'nba
                ans1=ans1.next;
            }
            temp=temp.next;
        }
        return ans.next;
    }
}
```

## [705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)

> 不使用任何内建的哈希表库设计一个哈希集合（HashSet）。
>
> 实现 MyHashSet 类：
>
>  void add(key) 向哈希集合中插入值 key 。
>  bool contains(key) 返回哈希集合中是否存在这个值 key 。
>  void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。
>
> 
>
>
> 示例：
>
> 输入：
> ["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
> [[], [1], [2], [1], [3], [2], [2], [2], [2]]
> 输出：
> [null, null, null, true, false, null, true, null, false]
>
> 解释：
> MyHashSet myHashSet = new MyHashSet();
> myHashSet.add(1);      // set = [1]
> myHashSet.add(2);      // set = [1, 2]
> myHashSet.contains(1); // 返回 True
> myHashSet.contains(3); // 返回 False ，（未找到）
> myHashSet.add(2);      // set = [1, 2]
> myHashSet.contains(2); // 返回 True
> myHashSet.remove(2);   // set = [1]
> myHashSet.contains(2); // 返回 False ，（已移除）
>
> ![image-20220315181752347](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220315181752347.png)

```java
class MyHashSet {
    private static final int base=7;
    private LinkedList[] data;
    public MyHashSet() {
        data=new LinkedList[base];
        for(int i=0;i<base;i++) data[i]=new LinkedList<Integer>();
    }

    public void add(int key) {
        int h=hash(key);
        Iterator<Integer> iterator=data[h].iterator();
        while(iterator.hasNext()){
            Integer element=iterator.next();
            if(element==key){
                return;
            }
        }
        data[h].offerLast(key);
    }

    public void remove(int key) {
        int h=hash(key);
        Iterator<Integer> iterator=data[h].iterator();
        while(iterator.hasNext()){
            Integer element=iterator.next();
            if(element==key){
                data[h].remove(element);
                return;
            }
        }
    }

    public boolean contains(int key) {
        int h=hash(key);
        Iterator<Integer> iterator=data[h].iterator();
        while(iterator.hasNext()){
            Integer element=iterator.next();
            if(element==key){
                return true;
            }
        }
        return false;
    }

    public static int hash(int key){
        return key%base;
    }
}


/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * boolean param_3 = obj.contains(key);
 */
```

- offerLast(E e):将指定元素插入到LinkedList的末尾
- 对于LinkedList同样可以使用Iterator()方法
- 对于哈希函数hash(x)=x%modbase,base最好是一个质数
- 对于集合删除一个节点时可以直接调用remove()方法

## [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)

> 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。
>
> 实现 MyHashMap 类：
>
>  MyHashMap() 用空映射初始化对象
>  void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。
>  int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。
>  void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。
>
> 
>
>
> 示例：
>
> 输入：
> ["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
> [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
> 输出：
> [null, null, null, 1, -1, null, 1, null, -1]
>
> 解释：
> MyHashMap myHashMap = new MyHashMap();
> myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]
> myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]
> myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]
> myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]
> myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）
> myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]
> myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]
> myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]
>
> ![image-20220315185250209](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220315185250209.png)

```java
class MyHashMap {
    private class pair{
        private int key;
        private int value;
        public pair(int key,int value){
            this.key=key;
            this.value=value;
        }
        public int getKey(){
            return key;
        }
        public int getValue(){
            return value;
        }
        public void setValue(int value){
            this.value=value;
        }
    }
    private static final int base=111;
    private LinkedList[] data;
    public MyHashMap() {
        data=new LinkedList[base];
        for(int i=0;i<base;i++) data[i]=new LinkedList<pair>();
    }

    public void put(int key, int value) {
        int h=hash(key);
        Iterator<pair> iterator=data[h].iterator();
        while(iterator.hasNext()){
            pair element=iterator.next();
            if(element.getKey()==key){
                element.setValue(value);
                return;
            }
        }
        data[h].offerLast(new pair(key,value));
    }

    public int get(int key) {
        int h=hash(key);
        Iterator<pair> iterator =data[h].iterator();
        while(iterator.hasNext()){
            pair element=iterator.next();
            if(element.getKey()==key){
                return element.getValue();
            }
        }
        return -1;
    }

    public void remove(int key) {
        int h=hash(key);
        Iterator<pair> iterator=data[h].iterator();
        while(iterator.hasNext()){
            pair element=iterator.next();
            if(element.getKey()==key){
                data[h].remove(element);
                return;
            }
        }
    }

    private int hash(int key){
        return key%base;
    }
} 
```

## [1290. 二进制链表转整数](https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/)

> 给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。
>
> 请你返回该链表所表示数字的 十进制值 。
>
> 
>
> 示例 1：
>
> 输入：head = [1,0,1]
> 输出：5
> 解释：二进制数 (101) 转化为十进制数 (5)
>
> 示例 2：
>
> 输入：head = [0]
> 输出：0
>
> 示例 3：
>
> 输入：head = [1]
> 输出：1
>
> 示例 4：
>
> 输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]
> 输出：18880
>
> 示例 5：
>
> 输入：head = [0,0]
> 输出：0
>
> 
>
> 提示：
>
>  链表不为空。
>  链表的结点总数不超过 30。
>  每个结点的值不是 0 就是 1。
>

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int getDecimalValue(ListNode head) {
        ListNode temp=head;
        int len=0;
        while(temp!=null){
            len++;
            temp=temp.next;
        }
        int[] array=new int[len];
        temp=head;
        int n=len;
        while (temp!=null){
            array[--n]=temp.val;
            temp=temp.next;
        }
        int ans=0;
        for(int i=0;i<len;i++){
            if(array[i]==1) ans+=Math.pow(2,i);
        }
        return ans;
    }
}
```

- 其实并不一定要求的整个链表长度，即采用秦九韶算法

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int getDecimalValue(ListNode head) {
        ListNode temp=head;
        int ans=0;
        while (temp!=null){
            ans=ans*2+temp.val;
            temp=temp.next;
        }
        return ans;
    }
}
```

## [1474. 删除链表 M 个节点之后的 N 个节点](https://leetcode-cn.com/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/)

> 给定链表 head 和两个整数 m 和 n. 遍历该链表并按照如下方式删除节点:
>
> 开始时以头节点作为当前节点.
> 保留以当前节点开始的前 m 个节点.
> 删除接下来的 n 个节点.
> 重复步骤 2 和 3, 直到到达链表结尾.
> 在删除了指定结点之后, 返回修改过后的链表的头节点.
>
> 
>
> 示例 1:
>
> 
>
> 输入: head = [1,2,3,4,5,6,7,8,9,10,11,12,13], m = 2, n = 3
> 输出: [1,2,6,7,11,12]
> 解析: 保留前(m = 2)个结点,  也就是以黑色节点表示的从链表头结点开始的结点(1 ->2).
> 删除接下来的(n = 3)个结点(3 -> 4 -> 5), 在图中以红色结点表示.
> 继续相同的操作, 直到链表的末尾.
> 返回删除结点之后的链表的头结点.
> 示例 2:
>
> 
>
> 输入: head = [1,2,3,4,5,6,7,8,9,10,11], m = 1, n = 3
> 输出: [1,5,9]
> 解析: 返回删除结点之后的链表的头结点.
> 示例 3:
>
> 输入: head = [1,2,3,4,5,6,7,8,9,10,11], m = 3, n = 1
> 输出: [1,2,3,5,6,7,9,10,11]
> 示例 4:
>
> 输入: head = [9,3,7,7,9,10,8,2], m = 1, n = 2
> 输出: [9,7,8]
>
> ![image-20220316203742180](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220316203742180.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteNodes(ListNode head, int m, int n) {
        ListNode temp=head;
        ListNode ans=new ListNode(0);
        ListNode temp1=ans;
        while (temp!=null){
            for(int i=0;i<m;i++){
                temp1.next=new ListNode(temp.val);
                temp1=temp1.next;
                temp=temp.next;
                if(temp==null) return ans.next;
            }
            for(int i=0;i<n;i++){
                temp=temp.next;
                if(temp==null) return ans.next;
            }
        }
        return ans.next;
    }
}
```

- 直接新建结点

## [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

> 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
>
> 
>
> 示例 1：
>
> 输入：head = [1,3,2]
> 输出：[2,3,1]
>
>
> 限制：
>
> 0 <= 链表长度 <= 10000
>

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {
        List<Integer> l=new ArrayList<>();
        ListNode temp=head;
        while(temp!=null){
            l.add(temp.val);
            temp=temp.next;
        }
        int len=l.size();
        int[] ans=new int[len];
        for(int i=0;i<len;i++){
            ans[i]=l.get(len-1-i);
        }
        return ans;
    }
}
```

## [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

> 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
>
> 返回删除后的链表的头节点。
>
> 注意：此题对比原题有改动
>
> 示例 1:
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)
>
> 输入: head = [4,5,1,9], val = 5
> 输出: [4,1,9]
> 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
> 示例 2:
>
> 输入: head = [4,5,1,9], val = 1
> 输出: [4,5,9]
> 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
>
>
> 说明：
>
> 题目保证链表中节点的值互不相同
> 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode ans=new ListNode(0);
        ListNode temp=head;
        ListNode temp1=ans;
        while (temp!=null){
            if(temp.val!=val) {
                temp1.next=new ListNode(temp.val);
                temp1=temp1.next;
            }
            temp=temp.next;
        }
        return ans.next;
    }
}
```

## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

> 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
>
> 请你将两个数相加，并以相同形式返回一个表示和的链表。
>
> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> 
>
> 示例 1：
>
>
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[7,0,8]
> 解释：342 + 465 = 807.
> 示例 2：
>
> 输入：l1 = [0], l2 = [0]
> 输出：[0]
> 示例 3：
>
> 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
> 输出：[8,9,9,9,0,0,0,1]
>
>
> 提示：
>
> 每个链表中的节点数在范围 [1, 100] 内
> 0 <= Node.val <= 9
> 题目数据保证列表表示的数字不含前导零

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode ans=new ListNode(0);
        ListNode temp_ans=ans;
        ListNode temp_l1=l1,temp_l2=l2;
        int next_num=0;
        
        while (!(temp_l1==null&&temp_l2==null)){
            int num_l1=temp_l1==null ? 0:temp_l1.val;
            int num_l2=temp_l2==null ? 0:temp_l2.val;
            temp_ans.next=new ListNode((num_l1+num_l2+next_num)%10);
            temp_ans=temp_ans.next;
            next_num=(num_l1+num_l2+next_num)/10;
            //必须要对该节点进行“非空值”过滤
            if(temp_l1!=null&&temp_l1.next!=null) temp_l1=temp_l1.next;
            else temp_l1=null;
            if(temp_l2!=null&&temp_l2.next!=null) temp_l2=temp_l2.next;
            else temp_l2=null;
        }
        if(next_num==1) temp_ans.next=new ListNode(next_num);
        return ans.next;
    }
}
```

- `if(temp_l1!=null&&temp_l1.next!=null) temp_l1=temp_l1.next;`对于这条语句必须要保证当前结点不是空，才可以访问下一个节点，否则会造成空指针异常，而`temp_l1!=null`可以很好的过滤作用
- 这道题主要是维持一个进位变量`next_num`

# 记忆化搜索

## [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
>
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
>
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> 
>
> 示例 1：
>
> 输入：n = 2
> 输出：1
>
> 示例 2：
>
> 输入：n = 5
> 输出：5
>
> 
>
> 提示：
>
>  0 <= n <= 100
>

```java
class Solution {
    public int fib(int n) {
        int[] array=new int[105];
        if(n==0) return 0;
        if(n==1) return 1;
        array[0]=0;
        array[1]=1;
        for(int i=2;i<=n;i++){
            array[i]=(array[i-1]+array[i-2])%1000000007;
        }
        return array[n]%1000000007;
    }
}
```

- Java中int类型的最大是到2后面跟十个0
- ，因此在进行赋值时也要进行取余运算

## [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

> #### [青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)
>
> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 7
> 输出：21
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 0
> 输出：1
> ```
>
> **提示：**
>
> - `0 <= n <= 100`

```java
class Solution {
    public int numWays(int n) {
        int[] array=new int[105];
        array[0]=1;
        array[1]=1;
        
        for(int i=2;i<=n;i++){
            array[i]=(array[i-1]+array[i-2])%1000000007;
        }
        return array[n];
    }
}
```

- 当前台阶数等于到达前一个台阶数的方法+到达前两个台阶数的方法【也就数斐波那契数列】
- 可以使用数组来存储计算过的值

## [面试题 08.01. 三步问题](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

> 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。
>
> 示例1:
>
> 输入：n = 3 
> 输出：4
> 说明: 有四种走法
>
> 示例2:
>
> 输入：n = 5
> 输出：13
>
> 提示:
>
>  n范围在[1, 1000000]之间
>

```java
class Solution {
    public int waysToStep(int n) {
        long[] array=new long[1000001];
        array[0]=1;
        array[1]=1;
        array[2]=2;
        array[3]=4;
        for(int i=4;i<=n;i++){
            array[i]=(array[i-1]+array[i-2]+array[i-3])%1000000007;
        }
        return (int)array[n];
    }
}
```

- 由于`array[i]=(array[i-1]+array[i-2]+array[i-3])`虽然单个数不可能超过Integer.MAX_VALUE，但是三个数相加还是有可能超过，因此，最好用定义成long类型的数组，否则会造成溢出，导致结果不准确
- 这题和菲波那切数列差不多，当前位置由到达前一个、前两个、前三个位置的方法有关

# 回溯

## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

> 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。
>
> 叶子节点 是指没有子节点的节点。
>
>
> 示例 1：
>
> 输入：root = [1,2,3,null,5]
> 输出：["1->2->5","1->3"]
>
> 示例 2：
>
> 输入：root = [1]
> 输出：["1"]
>
> 
>
> 提示：
>
>  树中节点的数目在范围 [1, 100] 内
>  -100 <= Node.val <= 100
>

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> ans=new ArrayList<>();
        Queue<TreeNode> queue_node=new LinkedList<>();
        Queue<String> queue_path=new LinkedList<>();

        queue_node.offer(root);
        queue_path.offer(String.valueOf(root.val));

        while(!queue_node.isEmpty()){
            TreeNode temp=queue_node.poll();
            String path=queue_path.poll();
            if(temp.left==null&&temp.right==null) ans.add(path);
            else{
                if(temp.left!=null){
                    queue_node.offer(temp.left);
                    queue_path.offer(new StringBuffer(path).append("->").append(temp.left.val).toString());
                }
                if(temp.right!=null){
                    queue_node.offer(temp.right);
                    queue_path.offer(new StringBuilder(path).append("->").append(temp.right.val).toString());
                }
            }
        }
        return ans;
    }
}
```

- 将数字转换成字符串，可以使用`String.valueOf()`
- `new StringBuffer()`返回的是一个对象，Java中的对象都具有`toString()`方法，将对象转换成字符串

## [401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

> 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。
>
>  例如，下面的二进制手表读取 "3:25" 。
>
> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/29/binary_clock_samui_moon.jpg" alt="img" style="zoom: 25%;" />
>
> 给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。
>
> 小时不会以零开头：
>
>  例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。
>
> 分钟必须由两位数组成，可能会以零开头：
>
>  例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。
>
> 
>
>
> 示例 1：
>
> 输入：turnedOn = 1
> 输出：["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
>
> 示例 2：
>
> 输入：turnedOn = 9
> 输出：[]
>
> 
>
> 提示：
>
>  0 <= turnedOn <= 10
>

```java
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> l=new ArrayList<>();
        for(int i=0;i<12;i++){
            for(int j=0;j<60;j++){
                if(Integer.bitCount(i)+Integer.bitCount(j)==turnedOn){
                    l.add(i+":"+(j<10?0:"")+j);
                }
            }
        }
        return l;
    }
}
```

- `Integer.bitCount(int num)`能够用于**统计 二进制 中1的个数**

# 二分

![image-20221025003823712](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221025003823712.png)

### 知识点

※ 求中间值下标的语句，不用 `int = (l + r) / 2`，而采用`int c = l + (r - l) / 2` 的写法乃是为了防止「提前溢出」。

模板

![image-20220710083859440](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710083859440.png)

四种情形

![image-20220710084259067](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710084259067.png)

### 模版一 (相错终止)

![image-20220710092611385](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710092611385.png)

大于等于

![image-20220710092127538](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710092127538.png)

```java
// 模版一「一般」情形1: 大于等于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
            else r = c - 1; // #2 更新后r右侧「必」大于等于target
        }
        // return (l == nums.length || nums[l] != target) ? -1 : l; // 704题的返回，处理:相等/不等
        return l == nums.length ? -1 : l; // 处理: 相等/刚好大于/不存在
    }
}
```

大于

![image-20220710092231772](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710092231772.png)

```java
// 模版一「一般」情形2: 大于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l左侧元素「必」小于等于target
            else r = c - 1; // #2 更新后r右侧「必」大于target
        }
        return l == nums.length ? -1 : l; // 处理: 刚好大于/不存在
    }
}
```

小于等于

![image-20220710092426030](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710092426030.png)

```java
// 模版一「一般」情形3: 小于等于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l左侧「必」小于等于target
            else r = c - 1; // #2 更新后r右侧「必」大于target
        }
        // return (r == -1 || nums[r] != target) ? -1 : r; // 704题的返回，处理:相等/不等
        return r; // 处理: 相等/刚好小于/不存在
    }
}
```

小于

![image-20220710093301234](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710093301234.png)

```java
// 模版一「一般」情形4: 小于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
            else r = c - 1; // #2 更新后r右侧「必」大于等于target
        }
        return r; // 处理: 相等/刚好小于/不存在
    }
}
```

模板总结

![image-20220710093535219](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710093535219.png)

对于大于或者大于等于，判断在else里面，return else里面的【R】；

对于小于或者小于等于，判断在if里面，return if里面的【L】

### 模版二 (相等终止/左闭右开)

![image-20220710094328460](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710094328460.png)

四种一般情形
四种一般情形与模版一时所述相同，均依据「循环不变」原则写出，在书写「情形3」代码时我们发现程序陷入 「无限循环」 ，然后分析该问题发生的原因，并给出正确写法。

大于等于

![image-20220710100950804](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710100950804.png)

```java
// 模版二「一般」情形1: 大于等于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target 
            else r = c; // #2 更新后r及r右侧「必」大于等于target
        }
        // return (r != nums.length && nums[r] == target) ? r : -1; // 704题的返回，处理:相等/不等
        return r != nums.length ? r : -1; // 处理:等于/刚好大于/不存在
    }
}
```

![image-20220725110206754](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220725110206754.png)

![image-20220725110330115](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220725110330115.png)

![image-20220725110731173](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220725110731173.png)

![image-20220725111310498](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220725111310498.png)





## [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

> 整数数组 nums 按升序排列，数组中的值 互不相同 。
>
> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
>
> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
>
> 
>
> 示例 1：
>
> 输入：nums = [4,5,6,7,0,1,2], target = 0
> 输出：4
> 示例 2：
>
> 输入：nums = [4,5,6,7,0,1,2], target = 3
> 输出：-1
> 示例 3：
>
> 输入：nums = [1], target = 0
> 输出：-1
>
> ![image-20220406223238643](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220406223238643.png)

```java
class Solution {
    public int search(int[] nums, int target) {
        int n=nums.length;
        if(n==0) return -1;
        if(n==1) return target==nums[0] ? 0:-1;

        int l=0,r=n-1;
        while(l<=r){
            int mid=(l+r)/2;
            if(target==nums[mid]) return mid;
            if(nums[0]<=nums[mid]){
                if(nums[0]<=target&&target<nums[mid]) r=mid-1;
                else l=mid+1;
            }else{
                if(nums[mid]<target&&target<=nums[n-1]) l=mid+1;
                else r=mid-1;
            }
        }

        return -1; 
    }
}
```

1. ```yaml
   将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。
   此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环. 
   ```

2. 毕竟mid比较过了， 所以绝对不可能相等， 但是start和end是有可能的，所以需要加==

3. ![fig1](https://gitee.com/demon_night/images/raw/master/imgs/202204062233236.png)

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 如果数组中不存在目标值 target，返回 [-1, -1]。
>
> 进阶：
>
> 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
>
>
> 示例 1：
>
> 输入：nums = [5,7,7,8,8,10], target = 8
> 输出：[3,4]
> 示例 2：
>
> 输入：nums = [5,7,7,8,8,10], target = 6
> 输出：[-1,-1]
> 示例 3：
>
> 输入：nums = [], target = 0
> 输出：[-1,-1]
>
> ![image-20220410145105175](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220410145105175.png)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int len=nums.length;
        if(len==0) return new int[]{-1,-1};
        int left=find_first_index(nums, target);
        if(left==-1) return new int[]{-1,-1};
        int right=find_last_index(nums,target);

        return new int[]{left,right};
    }

    private int find_first_index(int[] nums,int target){
        int l=0,r=nums.length-1;
        while (l<r){
            int mid=(l+r)>>>1;
            if(target<nums[mid]) r=mid-1;
            else if(target==nums[mid]) r=mid;
            else l=mid+1;
        }
        if(nums[l]==target) return l;
        else return -1;
    }

    private int find_last_index(int[] nums,int target){
        int l=0,r=nums.length-1;
        while (l<r){
            int mid=(l+r+1)>>>1;
            if(target<nums[mid]) r=mid-1;
            else if(target==nums[mid]) l=mid;
            else l=mid+1;
        }
        return l;
    }
}
```

1. 二分法

2. 对于查找边界问题，while里面不用==
   1. 查找左边界时，对于遇到相等的值时改变右侧范围使得r=mid
   2. 查找右边界时，对于遇到相等的值时改变左侧范围使得l=mid
   
3. 对于区间内的个数可能是奇数也可能是偶数
   1. 对于奇数：>>>1可能会导致向下取整，当我们求左区间的端点时，r肯定是往右走的，因此会出现了l<=r的情况；但是当我们求右区间端点时，会由于向下取整导致mid一直等于l，一直进行循环【因为r是不动的，动的是的左端点，但是由于向下取整导致左端点也动不了】
   2. 对于偶数可以正常进行判断
   
4. ```java
   class Solution {
       public int[] searchRange(int[] nums, int target) {
           int index1=find_index(nums,target-1);
           int index2=find_index(nums,target)-1;
           if(index1<=index2&&nums[index1]==target) return new int[]{index1,index2};
           return new int[]{-1,-1};
       }
   
       private int find_index(int[] nums,int target){
           int l=0,r=nums.length-1;
           int ans=nums.length;
           while(l<=r){
               int mid=(l+r)>>>1;
               if(target>=nums[mid]) l=mid+1;
               else {
                   r=mid-1;
                   ans=mid;
               }
           }
           return ans;
       }
   }
   ```

   1. 寻找比左区间、右区间大的数

## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
>
>
> 示例 1:
>
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
> 示例 2:
>
> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1
> 解释: 2 不存在 nums 中因此返回 -1
>
>
> 提示：
>
> 你可以假设 nums 中的所有元素是不重复的。
> n 将在 [1, 10000]之间。
> nums 的每个元素都将在 [-9999, 9999]之间。

```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length==0) return -1;
        if(nums.length==1) return target==nums[0]?0:-1;

        int l=0,r=nums.length-1;
        while (l<=r){
            int mid=(l+r)>>>1;
            if(nums[mid]==target) return  mid;
            if(target>nums[mid]) l=mid+1;
            else r=mid-1;
        }
        return -1;
    }
}
```

## [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

> 猜数字游戏的规则如下：
>
> 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
> 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
> 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：
>
> -1：我选出的数字比你猜的数字小 pick < num
> 1：我选出的数字比你猜的数字大 pick > num
> 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
> 返回我选出的数字。
>
> 
>
> 示例 1：
>
> 输入：n = 10, pick = 6
> 输出：6
> 示例 2：
>
> 输入：n = 1, pick = 1
> 输出：1
> 示例 3：
>
> 输入：n = 2, pick = 1
> 输出：1
> 示例 4：
>
> 输入：n = 2, pick = 2
> 输出：2
>
> ![image-20220411152407515](https://gitee.com/demon_night/images/raw/master/imgs/202204111524124.png)

```java
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int l=1,r=n;
        while(l<=r){
            int mid=(l+r)>>>1;
            int flag=guess(mid);
            if(flag==0) return mid;
            if(flag==-1) r=mid-1;
            else l=mid+1;
        }
        return -1;
    }
}
```

## [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 O(log n) 的算法。
>
> 
>
> 示例 1:
>
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> 示例 2:
>
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> 示例 3:
>
> 输入: nums = [1,3,5,6], target = 7
> 输出: 4
>
>
> 提示:
>
> ![image-20220412072643887](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220412072643887.png)

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l=0,r=nums.length-1;
        
        while (l<=r){
            int mid=(l+r)>>>1;
            if(target==nums[mid]) return mid;
            if(target>nums[mid]) l=mid+1;
            else r=mid-1;
        }
        
        return r+1;
    }
}
```

- 二分结束的判断是l>r因此目标值应该在的位置在r+1位置

## [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

> 符合下列属性的数组 arr 称为 山脉数组 ：
> arr.length >= 3
> 存在 i（0 < i < arr.length - 1）使得：
> arr[0] < arr[1] < ... arr[i-1] < arr[i]
> arr[i] > arr[i+1] > ... > arr[arr.length - 1]
> 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i 。
>
> 
>
> 示例 1：
>
> 输入：arr = [0,1,0]
> 输出：1
> 示例 2：
>
> 输入：arr = [0,2,1,0]
> 输出：1
> 示例 3：
>
> 输入：arr = [0,10,5,2]
> 输出：1
> 示例 4：
>
> 输入：arr = [3,4,5,1]
> 输出：2
> 示例 5：
>
> 输入：arr = [24,69,100,99,79,78,67,36,26,19]
> 输出：2
>
> ![image-20220412130036528](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220412130036528.png)

```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int l=0,r=arr.length-1;
        while (l<r){
            int mid=(l+r)>>>1;
            if(arr[mid]>arr[mid+1]&&arr[mid]>arr[mid-1]) return mid;
            if(arr[mid]>arr[mid-1]) l=mid;
            if(arr[mid]>arr[mid+1]) r=mid;
        }
        
        return -1;
    }
}
```

## [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

> 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。
>
> 进阶：不要 使用任何内置的库函数，如  sqrt 。
>
> 
>
> 示例 1：
>
> 输入：num = 16
> 输出：true
> 示例 2：
>
> 输入：num = 14
> 输出：false
>
> ![image-20220413084314840](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220413084314840.png)

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int l=1,r=num;
        while (l<=r){
            int mid=(l+r)>>>1;
            long temp=1L*mid*mid;
            if(temp==num) return true;
            if(temp>num) r=mid-1;
            else l=mid+1;
        }
        
        return false;
    }
}
```

1. 对于从一个递增范围内查找一个数一般都可以使用二分法
2. 对于只有一个数的情况我们可以使用l<=r

## [1385. 两个数组间的距离值](https://leetcode-cn.com/problems/find-the-distance-value-between-two-arrays/)

> 给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。
>
> 「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| <= d 。
>
> 
>
> 示例 1：
>
> 输入：arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
> 输出：2
> 解释：
> 对于 arr1[0]=4 我们有：
> |4-10|=6 > d=2 
> |4-9|=5 > d=2 
> |4-1|=3 > d=2 
> |4-8|=4 > d=2 
> 所以 arr1[0]=4 符合距离要求
>
> 对于 arr1[1]=5 我们有：
> |5-10|=5 > d=2 
> |5-9|=4 > d=2 
> |5-1|=4 > d=2 
> |5-8|=3 > d=2
> 所以 arr1[1]=5 也符合距离要求
>
> 对于 arr1[2]=8 我们有：
> |8-10|=2 <= d=2
> |8-9|=1 <= d=2
> |8-1|=7 > d=2
> |8-8|=0 <= d=2
> 存在距离小于等于 2 的情况，不符合距离要求 
>
> 故而只有 arr1[0]=4 和 arr1[1]=5 两个符合距离要求，距离值为 2
> 示例 2：
>
> 输入：arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
> 输出：2
> 示例 3：
>
> 输入：arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
> 输出：1
>
> ![image-20220413180842421](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220413180842421.png)

```java
class Solution {
    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {
        int ans=0;
        Arrays.sort(arr2);
        for(int i:arr1){
            int index=Arrays.binarySearch(arr2,i);
            if(index<0){
                index=-index-1;
                if(index==0){
                    int temp=arr2[0]-i;
                    if(temp>d) ans++;
                }
                if(index==arr2.length){
                    int temp=i-arr2[arr2.length-1];
                    if(temp>d) ans++;
                }
                if(index>0&&index<arr2.length){
                    int temp1=i-arr2[index-1];
                    int temp2=arr2[index]-i;
                    if(temp1>d&&temp2>d) ans++;
                }
            }
        }

        return ans;
    }
}
```

- `Arrays.binarySearch（int【】，num）` Java自带的库函数，要求数组是已经排序好的
  1. 如果num是数组中的元素，则返回目标元素的下标
  2. 如果num不是数组中的元素
     1. 如果num比数组中每一个元素都小，则返回-1；
     2. 如果num在数组所在区间的范围内，则返回应该存在的位置+134
     3. 如果num比数组中每一个元素都大，则返回数组长度+1的负数`-(数组.length+1)` ;

## [69. x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)

> 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
>
> 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
>
> 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
>
> 
>
> 示例 1：
>
> 输入：x = 4
> 输出：2
> 示例 2：
>
> 输入：x = 8
> 输出：2
> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
>
> ![image-20220414173308288](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220414173308288.png)

```java
class Solution {
    public int mySqrt(int x) {
        if(x==0) return 0;
        int l=1,r=x;
        while (r-l>1){
            int mid=(l+r)>>>1;
            long temp=1L*mid*mid;
            if(temp>x) r=mid;
            else l=mid;
        }

        return l;
    }
}
```

1. while里面的判断语句就是确定如何改变范围，因此最终的范围一定是最接近目标的范围，由于是向下取整，因此，取左侧的值

## [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

> 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。
>
> 在比较时，字母是依序循环出现的。举个例子：
>
> 如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'
>
>
> 示例 1：
>
> 输入: letters = ["c", "f", "j"]，target = "a"
> 输出: "c"
> 示例 2:
>
> 输入: letters = ["c","f","j"], target = "c"
> 输出: "f"
> 示例 3:
>
> 输入: letters = ["c","f","j"], target = "d"
> 输出: "f"
>
> ![image-20220414204953100](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220414204953100.png)

```java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int len=letters.length;
        if(target>=letters[len-1]) return letters[0];
        int l=0,r=letters.length-1;
        while (l<r){
            int mid=(l+r)>>>1;
            if(target<letters[mid]) r=mid;
            else l=mid+1;
        }

        return letters[l];
    }
}
```

- 向上取整，因此改变左侧范围时可以mid+1；改变右侧范围时，答案也有可能是mid，因此不能改成mid-1.因此写成r=mid

## [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

> 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
>
> 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
>
> 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
>
>
> 示例 1：
>
> 输入：n = 5, bad = 4
> 输出：4
> 解释：
> 调用 isBadVersion(3) -> false 
> 调用 isBadVersion(5) -> true 
> 调用 isBadVersion(4) -> true
> 所以，4 是第一个错误的版本。
> 示例 2：
>
> 输入：n = 1, bad = 1
> 输出：1
>
> ![image-20220415163113343](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220415163113343.png)

```java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        if(n==1) return 1;
        int l=1,r=n;
        while(l<=r){
            int mid=(l+r)>>>1;
            if(isBadVersion(mid)==true&&isBadVersion(mid-1)==false) return mid;
            if(isBadVersion(mid)==true) r=mid;
            else l=mid+1;
        }
        return l;
    }
}
```

1. 在确定左右范围时，对于本题，答案是向上取整，因此r=mid[答案可能在右边]
2. 当左侧为false右侧为true时。说明mid元素就是第一个出错的版本

## [441. 排列硬币](https://leetcode-cn.com/problems/arranging-coins/)

> 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。
>
> 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。
>
> 
>
> 示例 1：
>
>
> 输入：n = 5
> 输出：2
> 解释：因为第三行不完整，所以返回 2 。
> 示例 2：
>
>
> 输入：n = 8
> 输出：3
> 解释：因为第四行不完整，所以返回 3 。
>
> ![image-20220416183515465](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220416183515465.png)

```java
class Solution {
    public int arrangeCoins(int n) {
        int l=1,r=n;
        while (l<r){
            int mid=(l+r+1)>>>1;
            long temp=1L*mid*mid+mid;
            if(temp<=1L*2*n) l=mid;
            else r=mid-1;
        }

        return l;
    }
}
```

- 运用等差数列求和Sn=n*(a1+an)/2=n(a1+a1+d(n-1))/2;
- 从大到小进行去遍历，由于两数相加除2是向下取整，因此需要**int mid=(l+r+1)>>>1;**
- 当要求边缘时，要l<r,如果l<=r则截止条件时r<l:会破坏掉l的
- 如果有l=mid,会导致一直循环下去，左边动不了，因此+1导致了向上取整

## [1539. 第 k 个缺失的正整数[还是不会]](https://leetcode-cn.com/problems/kth-missing-positive-number/)

> 给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。
>
> 请你找到这个数组里第 k 个缺失的正整数。
>
> 
>
> 示例 1：
>
> 输入：arr = [2,3,4,7,11], k = 5
> 输出：9
> 解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。
> 示例 2：
>
> 输入：arr = [1,2,3,4], k = 2
> 输出：6
> 解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。
>
>
> 提示：
>
> 1 <= arr.length <= 1000
> 1 <= arr[i] <= 1000
> 1 <= k <= 1000
> 对于所有 1 <= i < j <= arr.length 的 i 和 j 满足 arr[i] < arr[j] 

```java
class Solution {
    public int findKthPositive(int[] arr, int k) {
        if (arr[0] > k) {
            return k;
        }

        int l = 0, r = arr.length;
        while (l < r) {
            int mid = (l + r) >> 1;
            int x = mid < arr.length ? arr[mid] : Integer.MAX_VALUE;
            if (x - mid - 1 >= k) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }

        return k - (arr[l - 1] - (l - 1) - 1) + arr[l - 1];
    }
}
```

## [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

> 给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。
>
> 以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。
>
> 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。
>
> 你所设计的解决方案必须只使用常量级的额外空间。
>
>
> 示例 1：
>
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
> 示例 2：
>
> 输入：numbers = [2,3,4], target = 6
> 输出：[1,3]
> 解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
> 示例 3：
>
> 输入：numbers = [-1,0], target = -1
> 输出：[1,2]
> 解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
>
> ![image-20220417133530010](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220417133530010.png)

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int l=0,r=numbers.length-1;
        while (l<r){
            if(numbers[l]+numbers[r]==target) return new int[]{l+1,r+1};
            if(numbers[l]+numbers[r]>target) r--;
            else l++;
        }
        return new int[]{l+1,r+1};
    }
}
```

1. 双指针，比二分法要快

## [1608. 特殊数组的特征值](https://leetcode-cn.com/problems/special-array-with-x-elements-greater-than-or-equal-x/)

> 给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。
>
> 注意： x 不必 是 nums 的中的元素。
>
> 如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。
>
> 
>
> 示例 1：
>
> 输入：nums = [3,5]
> 输出：2
> 解释：有 2 个元素（3 和 5）大于或等于 2 。
> 示例 2：
>
> 输入：nums = [0,0]
> 输出：-1
> 解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。
> 如果 x = 0，应该有 0 个元素 >= x，但实际有 2 个。
> 如果 x = 1，应该有 1 个元素 >= x，但实际有 0 个。
> 如果 x = 2，应该有 2 个元素 >= x，但实际有 0 个。
> x 不能取更大的值，因为 nums 中只有两个元素。
> 示例 3：
>
> 输入：nums = [0,4,3,0,4]
> 输出：3
> 解释：有 3 个元素大于或等于 3 。
> 示例 4：
>
> 输入：nums = [3,6,7,7,0]
> 输出：-1
>
>
> 提示：
>
> 1 <= nums.length <= 100
> 0 <= nums[i] <= 1000

```java
class Solution {
    public int specialArray(int[] nums) {
        Arrays.sort(nums);
        int l=0,r=nums[nums.length-1];
        while(l<=r){
            int mid=(l+r)>>>1;
            int temp=find_num(nums,mid);
            if(temp==mid) return mid;
            if(temp<mid) r=mid-1;
            else l=mid+1;
        }
        return -1;
    }
    private int find_num(int[] nums,int target){
        int l=0,r=nums.length-1;
        while (l<r){
            int mid=(l+r)>>>1;
            if(nums[mid]>=target) r=mid;
            else l=mid+1;
        }
        return nums.length-l;
    }
}
```

- 查找个数时使用二分，从0遍历到nums[nums.length-1]时也使用二分进行查找

## [1351. 统计有序矩阵中的负数](https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/)

> 给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 请你统计并返回 grid 中 负数 的数目。
>
> 
>
> 示例 1：
>
> 输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
> 输出：8
> 解释：矩阵中共有 8 个负数。
> 示例 2：
>
> 输入：grid = [[3,2],[1,0]]
> 输出：0
>
>
> 提示：
>
> m == grid.length
> n == grid[i].length
> 1 <= m, n <= 100
> -100 <= grid[i][j] <= 100

```java
class Solution {
    public int countNegatives(int[][] grid) {
        int len=grid.length;
        int ans=0;
        for(int i=0;i<len;i++){
            ans+=cnt(grid[i]);
        }
        return ans;
    }

    private int cnt(int[] grid){
        int l=0,r=grid.length-1,temp=grid.length;
        while(l<=r){
            int mid=(l+r)>>>1;
            if(grid[mid]<0) {
                r=mid-1;
                temp=mid;
            }
            else l=mid+1;
        }

        return grid.length-temp;
    }
}
```

## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

> 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
>
> 
>
> 示例 1：
>
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2,2]
> 示例 2:
>
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[4,9]
>
>
> 提示：
>
> 1 <= nums1.length, nums2.length <= 1000
> 0 <= nums1[i], nums2[i] <= 1000

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        HashMap<Integer,Integer> h=new HashMap<>();

        for (int i:nums1) h.put(i,h.getOrDefault(i,0)+1);
        List<Integer> ans=new ArrayList<>();
        for(int i:nums2){
            int num=0;
            if(h.containsKey(i)) num=h.get(i);
            if(num>0){
                ans.add(i);
                h.put(i,num-1);
            }
        }

        int[] ans1=new int[ans.size()];
        int temp1=-1;
        for(int i:ans) ans1[++temp1]=i;

        return ans1;
    }
}
```

1. 集合转换成数组可以采用`集合.toArray()`,但是只能转换成包装类型
2. `Arrays.copyOfRange`,对一个已有的数组进行`截取`复制，复制出一个左闭右开的数组

## [633. 平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

> 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。
>
> 
>
> 示例 1：
>
> 输入：c = 5
> 输出：true
> 解释：1 * 1 + 2 * 2 = 5
> 示例 2：
>
> 输入：c = 3
> 输出：false
>
> ![image-20220421231218503](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220421231218503.png)
>

1. 双指针

   ```java
   class Solution {
       public boolean judgeSquareSum(int c) {
           if(c==0) return true;
           int num=(int) Math.sqrt(c)+1;
   
           int l=0,r=num;
           while (l<=r){
               long temp=1L*l*l+1L*r*r;
               if(temp==c) return true;
               if(temp<c) l++;
               else r--;
           }
   
           return false;
       }
   }
   ```

2. 利用for循环控制一个，然后对另一个进行判断

   ```java
   class Solution {
       public boolean judgeSquareSum(int c) {
           for(long a=0;a*a<=c;a++){
               double b=Math.sqrt(c-a*a*1L);
               if(b==(int) b) return true;
           }
           
           return false; 
       }
   }
   ```


## [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
>
> 返回 滑动窗口中的最大值 。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值
> ---------------               -----
> [1  3  -1] -3  5  3  6  7       3
> 1 [3  -1  -3] 5  3  6  7       3
> 1  3 [-1  -3  5] 3  6  7       5
> 1  3  -1 [-3  5  3] 6  7       5
> 1  3  -1  -3 [5  3  6] 7       6
> 1  3  -1  -3  5 [3  6  7]      7
> 示例 2：
>
> 输入：nums = [1], k = 1
> 输出：[1]
>
>
> ![image-20220422210928532](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220422210928532.png)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n=nums.length;
        PriorityQueue<int[]> p=new PriorityQueue<>((o1,o2)->o2[0]-o1[0]);//降序插入

        for (int i=0;i<k;i++) p.offer(new int[]{nums[i],i});
        int[] ans=new int[n-k+1];
        ans[0]=p.peek()[0];

        for(int i=k;i<n;i++){
            p.offer(new int[]{nums[i],i});
            while (p.peek()[1]<=i-k) p.poll();
            ans[i-k+1]=p.peek()[0];
        }

        return ans;
    }
}
```

1. `PriorityQueue`优先队列
2. 排序规则可以采用Lambda表达式书写
3. 由于我们只关心最大值，因此，如果一个窗口里面的最大值元素的位置超过了窗口移动的长度，就将最大值元素从队列中移除

## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

> 给定一个含有 n 个正整数的数组和一个正整数 target 。
>
> 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
>
> 
>
> 示例 1：
>
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> 示例 2：
>
> 输入：target = 4, nums = [1,4,4]
> 输出：1
> 示例 3：
>
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0
>
> ![image-20220423181746383](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220423181746383.png)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n=nums.length;
        int sum=0,ans=Integer.MAX_VALUE;
        int l=0,r=0;

        while (r<n){
            sum+=nums[r];
            while (sum>=target){
                ans=Math.min(ans,r-l+1);
                sum-=nums[l];
                l++;
            }
            r++;
        }

        return ans==Integer.MAX_VALUE ? 0:ans;
    }
}
```

1. 使用滑动窗口求解
2. 也可以使用前缀和+二分函数求解
   1. 因为nums数组里面的值都>=1,因此前缀和一定是递增的

## [611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

> 给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。
>
> 
>
> 示例 1:
>
> 输入: nums = [2,2,3,4]
> 输出: 3
> 解释:有效的组合是: 
> 2,3,4 (使用第一个 2)
> 2,3,4 (使用第二个 2)
> 2,2,3
> 示例 2:
>
> 输入: nums = [4,2,3,4]
> 输出: 4
>
>
> 提示:
>
> 1 <= nums.length <= 1000
> 0 <= nums[i] <= 1000
> 通过次数63,346提交次数118

```java
class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int index=0;
        for(int i=0;i<n;i++){
            if(nums[i]!=0){
                index=i;
                break;
            }
        }
        int ans=0;

        for(int i=index;i<=n-3;i++){
            for(int j=i+1;j<=n-2;j++){
                int l=j+1,r=n-1,k=j;
                int a=nums[i];
                int b=nums[j];
                while (l<=r){
                    int mid=(l+r)>>>1;
                    if(nums[mid]<a+b) {
                        l=mid+1;
                        k=mid;
                    }
                    else r=mid-1;
                }
                int temp=k-j;
                ans+=temp;
            }
        }
        return ans;
    }
}
```

1. 二分
2. 时间复杂度：O(n^2logn)
3. 进行二分时可以正常采用+1、-1，对于要求的边界可以使用一个值进行记录，特别要注意吃实话，如果要记录l的值，就把l设置为l最初的位置-1，如果是记录r边界就设置为r+1

## [658. 找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)

> 给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。
>
> 整数 a 比整数 b 更接近 x 需要满足：
>
> |a - x| < |b - x| 或者
> |a - x| == |b - x| 且 a < b
>
>
> 示例 1：
>
> 输入：arr = [1,2,3,4,5], k = 4, x = 3
> 输出：[1,2,3,4]
> 示例 2：
>
> 输入：arr = [1,2,3,4,5], k = 4, x = -1
> 输出：[1,2,3,4]
>
> ![image-20220424075433437](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220424075433437.png)

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        List<Integer> l=Arrays.stream(arr).boxed().collect(Collectors.toList());
        Collections.sort(l,(o1,o2)->Math.abs(o1-x)-Math.abs(o2-x));
        l=l.subList(0,k);
        Collections.sort(l);
        return l;
    }
}
```

1. boxed:实现类型转换
2. collect是收集器
3. ![image-20220424075715815](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220424075715815.png)

## [1894. 找到需要补充粉笔的学生编号](https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/)

> 一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。
>
> 给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。
>
> 请你返回需要 补充 粉笔的学生 编号 。
>
> 
>
> 示例 1：
>
> 输入：chalk = [5,1,5], k = 22
> 输出：0
> 解释：学生消耗粉笔情况如下：
> - 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。
> - 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。
> - 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。
> - 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。
> - 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。
> - 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。
> 编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。
> 示例 2：
>
> 输入：chalk = [3,4,1,2], k = 25
> 输出：1
> 解释：学生消耗粉笔情况如下：
> - 编号为 0 的学生使用 3 支粉笔，然后 k = 22 。
> - 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。
> - 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。
> - 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。
> - 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。
> - 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。
> - 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。
> - 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。
> - 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。
> 编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。
>
> ![image-20220424191447599](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220424191447599.png)

```java
class Solution {
    public int chalkReplacer(int[] chalk, int k) {
        long ans=0;
        for(int i:chalk) ans+=i*1L;
        ans=k%ans;

        if (ans==0) return 0;
        for(int i=0;i<chalk.length;i++){
            ans-=chalk[i];
            if(ans<0) return i;
        }
        
        return 0;
    }
}
```

1. 考虑到溢出即可

## [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
>
> 示例 1：
>
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
> 示例 2：
>
> 输入：nums = [0,1,0,3,2,3]
> 输出：4
> 示例 3：
>
> 输入：nums = [7,7,7,7,7,7,7]
> 输出：1
>
> ![image-20220425114435882](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220425114435882.png)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        int[] dp=new int[n];
        Arrays.fill(dp,1);
        int ans=1;

        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]) {
                    dp[i]=Math.max(dp[i],dp[j]+1);
                    ans=Math.max(ans,dp[i]);
                }
            }
        }

        return ans;
    }
}
```

1. O(n^2)也可以解决
2. 就是比较前面的元素对当前元素的影响
   1. <img src="https://pic.leetcode-cn.com/7ae911e51d39c7007ad8d548566abe40a84e5deb3cd682fd071080cd307f71f5-Picture1.png" alt="img" style="zoom:50%;" />

## [1760. 袋子里最少数目的球](https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/)

> 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。
>
> 你可以进行如下操作至多 maxOperations 次：
>
> 选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。
> 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。
> 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。
>
> 请你返回进行上述操作后的最小开销。
>
> 
>
> 示例 1：
>
> 输入：nums = [9], maxOperations = 2
> 输出：3
> 解释：
> - 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -> [6,3] 。
> - 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -> [3,3,3] 。
> 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。
> 示例 2：
>
> 输入：nums = [2,4,8,2], maxOperations = 4
> 输出：2
> 解释：
> - 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -> [2,4,4,4,2] 。
> - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -> [2,2,2,4,4,2] 。
> - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -> [2,2,2,2,2,4,2] 。
> - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2] 。
> 装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。
> 示例 3：
>
> 输入：nums = [7,17], maxOperations = 2
> 输出：7
>
> ![image-20220425205857454](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220425205857454.png)

```java
class Solution {
    private boolean check(int[] nums,long cost,int maxOperations){
        long ans=0;
        for(int cur:nums){
            if(cur%cost==0){
                ans+=cur/cost-1;
            }else{
                ans+=cur/cost;
            }
        }
        return ans<=maxOperations;
    }

    public int minimumSize(int[] nums, int maxOperations) {
        long l=1,r=1000000000;
        long ret=0;
        while (l<=r){
            long mid=(l+r)>>>1;
            if(check(nums,mid,maxOperations)){
                r=mid-1;
                ret=mid;
            }else{
                l=mid+1;
            }
        }
        return (int) ret;
    }
}
```

1. 使用二分得到最小开销的取值
2. 对于num=17，cost=7；需要进行两次分割
   1. 对于num=10，cost=5，只需要进行1次分割
3. 如果ans较小，说明cost较大，因此需要目标值过大，因此让r=mid-1；

## [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)

> 珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。
>
> 珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  
>
> 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
>
> 返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。
>
> 
>
> 示例 1：
>
> 输入：piles = [3,6,7,11], h = 8
> 输出：4
> 示例 2：
>
> 输入：piles = [30,11,23,4,20], h = 5
> 输出：30
> 示例 3：
>
> 输入：piles = [30,11,23,4,20], h = 6
> 输出：23
>
> ![image-20220426073942474](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220426073942474.png)

```java
class Solution {
    private boolean check(int[] piles,int cost,int h){
        int ans=0;
        for(int i:piles){
            ans+=i%cost==0 ? i/cost:i/cost+1;
        }

        return ans<=h;
    }

    public int minEatingSpeed(int[] piles, int h) {
        int max=0;
        for(int i:piles) max=Math.max(i,max);

        int l=1,r=max;
        int ans=0;
        while (l<=r){
            int mid=(l+r)>>>1;
            if(check(piles,mid,h)){
                r=mid-1;
                ans=mid;
            }else{
                l=mid+1;
            }
        }

        return ans;
    }
}
```

1. 最大值化最小值、最小值化最大值都可以使用二分法
2. 对可能的结果进行二分查找

## [1552. 两球之间的磁力](https://leetcode-cn.com/problems/magnetic-force-between-two-balls/)

> 在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。
>
> 已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。
>
> 给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。
>
> 
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/16/q3v1.jpg)
>
> 输入：position = [1,2,3,4,7], m = 3
> 输出：3
> 解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。
> 示例 2：
>
> 输入：position = [5,4,3,2,1,1000000000], m = 2
> 输出：999999999
> 解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。
>
> ![image-20220426215511033](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220426215511033.png)

```java
class Solution {
    private boolean check(int[] position,int cost,int m){
        int ans=1;
        int pre=position[0];
        for(int i=1;i<position.length;i++){
            if(position[i]-pre>=cost){
                pre=position[i];
                ans++;
            }
        }

        return ans<m;
    }

    public int maxDistance(int[] position, int m) {
        Arrays.sort(position);
        int l=1,r=position[position.length-1];
        int ans=1;
        while(l<=r){
            int mid=(l+r)>>>1;
            if(check(position,mid,m)){
                r=mid-1;
            }else{
                l=mid+1;
                ans=mid;
            }
        }

        return ans;
    }
}
```

1. 对可能的取值可以使用二分法进行遍历

2. ```java
       int pre=position[0];
       for(int i=1;i<position.length;i++){
           if(position[i]-pre>=cost){
               pre=position[i];
               ans++;
           }
       }
   ```

	1. 可以得到相差某个距离数组中的个数
	1. 记得要把个数初始化为1
	1. 我们需要的结果是最小值，因此需要把ans放在l=mid+1程序段里面
	1. 如果得到值比目标值要小说明设定的区间较大，因此就要区间缩小，也就是r右移对于等于情况则不需要右移

## [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

> 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。
>
> 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
>
> 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,3,4,2,2]
> 输出：2
> 示例 2：
>
> 输入：nums = [3,1,3,4,2]
> 输出：3
>
> ![image-20220427125834095](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220427125834095.png)

1. > 解法1：哈希表

   ```java
   class Solution {
       public int findDuplicate(int[] nums) {
           HashSet<Integer> h=new HashSet<>();
           for(int i:nums){
               if(h.contains(i)) return i;
               h.add(i);
           }
           
           return 0;
       }
   }
   ```

   时间复杂度：O(n)

   空间复杂度：O(n)

2. > 解法2：二分法

   ```java
   class Solution {
       public int findDuplicate(int[] nums) {
           Arrays.sort(nums);
           int n=nums.length;
           int l=0,r=n-1;
           int ans=-1;
   
           while (l<=r){
               int mid=(l+r)>>>1;
               if(nums[mid]<mid+1){
                   ans=nums[mid];
                   r=mid-1;
               }else {
                   l=mid+1;
               }
           }
   
           return ans;
       }
   }
   ```

   1. 找到找到最后一个`nums[i]<i+1`
   2. 时间复杂度：O(logn)
   3. 空间复杂度：O(1)

## [1283. 使结果不超过阈值的最小除数](https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/)

> 给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。
>
> 请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。
>
> 每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。
>
> 题目保证一定有解。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,2,5,9], threshold = 6
> 输出：5
> 解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。
> 如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。
> 示例 2：
>
> 输入：nums = [2,3,5,7,11], threshold = 11
> 输出：3
> 示例 3：
>
> 输入：nums = [19], threshold = 5
> 输出：4
>
> ![image-20220427131650729](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220427131650729.png)

```java
class Solution {
    private boolean check(int[] nums,int cost,int threshold){
        int ans=0;
        for(int i:nums){
            ans+=i%cost==0 ? i/cost:i/cost+1;
        }

        return ans<=threshold;
    }

    public int smallestDivisor(int[] nums, int threshold) {
        Arrays.sort(nums);

        int l=1,r=nums[nums.length-1],ans=-1;
        while (l<=r){
            int mid=(l+r)>>>1;
            if(check(nums,mid,threshold)){
                r=mid-1;
                ans=mid;
            }else{
                l=mid+1;
            }
        }

        return ans;
    }
}
```

1. 对于取最大值或最小值时，一般使用二分法去查找可能的结果
2. 最小值一般时通过缩域右侧得到的；最大值一般是通过缩域左边得到
3. 使用二分法求最大、小值时，一般都可以通过这个模板去求

## [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

> 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：
>
> 每行的元素从左到右升序排列。
> 每列的元素从上到下升序排列。
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)
>
> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
> 输出：true
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)
>
>
> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
> 输出：false
>
> ![image-20220430120145028](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220430120145028.png)

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m=matrix.length,n=matrix[0].length;
        for(int[] i:matrix){
            int l=0,r=n-1;
            while (l<=r){
                int mid=(l+r)>>>1;
                if(i[mid]==target) return true;
                if(i[mid]>target) r=mid-1;
                else l=mid+1;
            }
        }
        
        return false;
    }
}
```

1. 时间复杂度：O(m*logn)

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m=matrix.length,n=matrix[0].length;

        int l=0,r=n-1;
        while (l<m&&r>=0){
            if(matrix[l][r]== target) return true;
            if(matrix[l][r]>target) r--;
            else l++;
        }

        return false;
    }
}
```

1. 时间复杂度：O(m+n)
2. 使用了从上到下、从左到右递增的性质
3. 如果从【0，0】开始，比当前值大的有两条路，比当前值小的有0条路
   1. 从右上角开始时，比当前值大的有一条路，比当前值小的有1条路
   2. 从左下角开始时，比当前值大的有一条路，比当前值小的有1条路
   3. 从右下角开始时，比当前值大的有0条路，比当前值小的有2条路
4. 因此我们要根据当前值判断大小，选择只有一种确定的情况，因此可以选择右上、左下都可以

## [275. H 指数 II](https://leetcode-cn.com/problems/h-index-ii/)

> 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数，citations 已经按照 升序排列 。计算并返回该研究者的 h 指数。
>
> h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。
>
> 提示：如果 h 有多种可能的值，h 指数 是其中最大的那个。
>
> 请你设计并实现对数时间复杂度的算法解决此问题。
>
> 
>
> 示例 1：
>
> 输入：citations = [0,1,3,5,6]
> 输出：3 
> 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
>   由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3 。
> 示例 2：
>
> 输入：citations = [1,2,100]
> 输出：2
>
> ![image-20220430213614615](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220430213614615.png)

```java
class Solution {
    public int hIndex(int[] citations) {
        int l=0,r=citations.length-1,ans=0;
        while (l<=r){
            int mid=(l+r)>>>1;
            int n=citations.length-mid;
            if(citations[mid]>=n){
                r=mid-1;
                ans=n;
            }else{
                l=mid+1;
            }
        }

        return ans;
    }
}
```

1. 目标：h篇论文至少被引用h次【所以答案尽量往左，只有这样，h才能足够大】
2. 因此ans存放的值应该是`判断过`的最右侧，只有缩域后才叫进行了判断

## [1838. 最高频元素的频数](https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/)

> 元素的 频数 是该元素在一个数组中出现的次数。
>
> 给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。
>
> 执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,2,4], k = 5
> 输出：3
> 解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。
> 4 是数组中最高频元素，频数是 3 。
> 示例 2：
>
> 输入：nums = [1,4,8,13], k = 5
> 输出：2
> 解释：存在多种最优解决方案：
> - 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。
> - 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。
> - 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。
> 示例 3：
>
> 输入：nums = [3,9,6], k = 2
> 输出：1
>
> ![image-20220501192330386](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220501192330386.png)

```java
class Solution {
    public int maxFrequency(int[] nums, int k) {
        Arrays.sort(nums);
        int n=nums.length;
        int left=0,right=1;
        int ans=1;
        while (right<n){
            k-=(nums[right]-nums[right-1])*(right-left);
            if(k>=0){
                ans=right-left+1;
            }else{
                left++;
                k+=nums[right]-nums[left-1];
            }
            right++;
        }

        return ans;
    }
}
```

1. 滑动窗口，确定窗口大小，然后右移
2. 如果要从右往左求，很难求差值；但是如果我们从左往右求时就可以当成把前面的坑填满所需要的`k`值;如果l往右移动时，需要把移除的那一列所填的坑全部去掉，也就是k加上

## [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

> 给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。
>
> 请你找出并返回只出现一次的那个数。
>
> 你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。
>
> 
>
> 示例 1:
>
> 输入: nums = [1,1,2,3,3,4,4,8,8]
> 输出: 2
> 示例 2:
>
> 输入: nums =  [3,3,7,7,10,11,11]
> 输出: 
>
> ![image-20220501213053288](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220501213053288.png)

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int n=nums.length;

        int l=0,r=n-1;
        while (l<r){
            int mid=(l+r)>>>1;
            if(nums[mid]==nums[mid^1]){
                l=mid+1;
            }else{
                r=mid;
            }
        }

        return nums[r];
    }
}
```



## [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

> 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
>
> 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
>
> 
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)
>
>
> 输入：root = [1,2,3,4,5,6]
> 输出：6
> 示例 2：
>
> 输入：root = []
> 输出：0
> 示例 3：
>
> 输入：root = [1]
> 输出：1
>
> ![image-20220502171322475](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220502171322475.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null) return 0;
        int ans=0;
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        ans++;

        while (!q.isEmpty()){
            TreeNode temp=q.poll();
            if(temp.left!=null) {
                q.add(temp.left);
                ans++;
            }
            if(temp.right!=null){
                q.add(temp.right);
                ans++;
            }
        }
        
        return ans;
    }
}
```

1. 直接遍历

## [436. 寻找右区间](https://leetcode-cn.com/problems/find-right-interval/)

> 给你一个区间数组 intervals ，其中 intervals[i] = [starti, endi] ，且每个 starti 都 不同 。
>
> 区间 i 的 右侧区间 可以记作区间 j ，并满足 startj >= endi ，且 startj 最小化 。
>
> 返回一个由每个区间 i 的 右侧区间 的最小起始位置组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1 。
>
>
> 示例 1：
>
> 输入：intervals = [[1,2]]
> 输出：[-1]
> 解释：集合中只有一个区间，所以输出-1。
> 示例 2：
>
> 输入：intervals = [[3,4],[2,3],[1,2]]
> 输出：[-1,0,1]
> 解释：对于 [3,4] ，没有满足条件的“右侧”区间。
> 对于 [2,3] ，区间[3,4]具有最小的“右”起点;
> 对于 [1,2] ，区间[2,3]具有最小的“右”起点。
> 示例 3：
>
> 输入：intervals = [[1,4],[2,3],[3,4]]
> 输出：[-1,2,-1]
> 解释：对于区间 [1,4] 和 [3,4] ，没有满足条件的“右侧”区间。
> 对于 [2,3] ，区间 [3,4] 有最小的“右”起点。
>
> ![image-20220506153826189](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220506153826189.png)

```java
class Solution {
    public int[] findRightInterval(int[][] intervals) {
        int[] ans=new int[intervals.length];
        for(int i=0;i<intervals.length;i++){
            int min=Integer.MAX_VALUE;
            int min_index=-1;
            for(int j=0;j<intervals.length;j++){
                if(intervals[j][0]>=intervals[i][1]&&intervals[j][0]<min){
                    min=intervals[j][0];
                    min_index=j;
                }
            }
            ans[i]=min_index;
        }

        return ans;
    }
}
```

1. 暴力

## [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

> 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
>
> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
>
> 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
>
> 你必须尽可能减少整个操作步骤。
>
> 
>
> 示例 1：
>
> 输入：nums = [2,5,6,0,0,1,2], target = 0
> 输出：true
> 示例 2：
>
> 输入：nums = [2,5,6,0,0,1,2], target = 3
> 输出：false
>
> ![image-20220506214841126](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220506214841126.png)

```java
class Solution {
    public boolean search(int[] nums, int target) {
        int l=0,r=nums.length-1;//定义左右边界

        while (l<=r){
            int mid=(l+r)>>>1;
            if(nums[mid]==target) return true;//如果恰好找到，直接返回true

            while (l<r&&nums[mid]==nums[l]) l++;//去除左侧与mid元素的重复元素

            mid=(l+r)>>>1;//重新更改mid
            if(nums[mid]==target) return true;//判断当前mid下标的值是否等于目标值

            if(nums[l]<=nums[mid]){//对于等于：如果对于左边的一个小区间只有一个值，也可以进行判断，右侧的值可以通过左边进行
                if(target>=nums[l]&&target<nums[mid]){
                    r=mid-1;
                }else{
                    l=mid+1;
                }
            }else{
                if(target>nums[mid]&&target<=nums[r]){
                    l=mid+1;
                }else {
                    r=mid-1;
                }
            }
        }

        return false;
    }
}
```

## [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

> 峰值元素是指其值严格大于左右相邻值的元素。
>
> 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
>
> 你可以假设 nums[-1] = nums[n] = -∞ 。
>
> 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,2,3,1]
> 输出：2
> 解释：3 是峰值元素，你的函数应该返回其索引 2。
> 示例 2：
>
> 输入：nums = [1,2,1,3,5,6,4]
> 输出：1 或 5 
> 解释：你的函数可以返回索引 1，其峰值元素为 2；
>   或者返回索引 5， 其峰值元素为 6。
>
> ![image-20220507072324992](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220507072324992.png)

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int l=0,r=nums.length-1,ans=0;

        while (l<r){
            int mid=(l+r)>>>1;
            if(nums[mid]<nums[mid+1]){
                l=mid+1;
                ans=l;
            }else{
                r=mid;
            }
        }

        return ans;
    }
}
```

1. 由于是寻找右边界，因此是将ans放进求l里面了，ans也默认为左边界

## [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

> 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
> 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
> 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
> 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
>
> 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
>
> 你必须尽可能减少整个过程的操作步骤。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,3,5]
> 输出：1
> 示例 2：
>
> 输入：nums = [2,2,2,0,1]
> 输出：0
>
> ![image-20220507164319530](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220507164319530.png)

```java
class Solution {
    public int findMin(int[] nums) {
        int l=0,r=nums.length-1;

        while (l<=r){//对于左右区间各一个值时进行特判
            int mid=(l+r)>>>1;
            if(nums[mid]<nums[r]){//如果中间值小于右边界值，说明中-右升序，最小值在左侧
                r=mid;
            }else if(nums[mid]>nums[r]){//如果中间值大于右边界值，说明左-中有序，最小值在右侧
                l=mid+1;
            }else{//c
                r--;
            }
        }

        return nums[l];
    }
}
```

## [1508. 子数组和排序后的区间和](https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/)

> 给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) / 2 个数字的数组。
>
> 请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,2,3,4], n = 4, left = 1, right = 5
> 输出：13 
> 解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。
> 示例 2：
>
> 输入：nums = [1,2,3,4], n = 4, left = 3, right = 4
> 输出：6
> 解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。
> 示例 3：
>
> 输入：nums = [1,2,3,4], n = 4, left = 1, right = 10
> 输出：50
>
> ![image-20220509223849191](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220509223849191.png)

```java
class Solution {
    public int rangeSum(int[] nums, int n, int left, int right) {
        int len=nums.length;
        int mod=(int) 1e9+7;
        ArrayList<Long> l=new ArrayList<>();

        long temp=0;
        for(int i=0;i<len;i++){
            temp=nums[i]%mod;
            l.add(temp);
            for(int j=i+1;j<len;j++){
                temp+=nums[j]%mod;
                l.add(temp);
            }
        }
        Collections.sort(l);

        long ans=0;
        for(int i=left-1;i<=right-1;i++){
            ans+=l.get(i);
            ans%=mod;
        }

        return (int) ans;
    }
}
```

1. 对结果进行取余运算，而不是对参加计算的每个值进行取余运算
   1. 并不是` ans+=l.get(i)%mod`

## [1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/)

> 给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。
>
> 请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。
>
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/e1.png)
>
> 输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
> 输出：2
> 解释：总和小于或等于 4 的正方形的最大边长为 2，如图所示。
> 示例 2：
>
> 输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
> 输出：0
>
> ![image-20220510221530037](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220510221530037.png)

```java
class Solution {
    public int maxSideLength(int[][] mat, int threshold) {
        int m = mat.length, n = mat[0].length;
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];
            }
        }
        int ans = 0;
        for (int k = 1; k <= Math.min(m, n); k++) {
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    if (i - k < 0 || j - k < 0) {
                        continue;
                    }
                    int temp = dp[i][j] - dp[i - k][j] - dp[i][j - k] + dp[i - k][j - k];
                    if (temp <= threshold) {
                        ans = Math.max(ans, k);
                    }
                }
            }
        }

        return ans;
    }
}
```

1. 前缀和

# 动态规划

## 单词分析

1. 简易哈希表来存储
2. 可以直接将结果计算出来，字母字典序中最小值为输入字母的最小值，因此我们可以将初值定义成a，遇到的第一个字母肯定是字典序中最小的值，遇不到比他大的就输出这个值

```java
package xiti;

import java.util.HashMap;
import java.util.Scanner;
// 1:无需package
// 2: 类名必须Main, 不可修改

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        String s=scan.nextLine();
        int max=0;
        int[] a=new int[26];
        for(int i=0;i<s.length();i++){
            a[s.charAt(i)-'a']++;
        }
        char ch='a';
        for(int i=0;i<26;i++){
            if(a[i]>max){
                max=a[i];
                ch=(char) (ch+i);
            }
        }
        System.out.println(ch);
        System.out.println(max);
        scan.close();
    }
}
```

## 110：平衡二叉树

> 解法：递归[从一颗小的二叉树--->总得二叉树]

1. 计算节点TreeNode的深度，遇到节点为空则返回0，否则运用递归继续深入，                           Math.max（root.right,root.left)+1【加一：例如四个节点，深度就为4，所以对于本节点如果没有子树，就返回1】

2. 本解题方法判断的是左子树与右子树之间的最大差值，所以还需要判断对于左子树的节点是不是符合要求

3. 根节点->进入左子树、进入右子树->找出左子树、右子树之间的差值，其中没有判断左子树的左子树….的差值，所以还需要用递归来判断左子树、右子树是否满足差值

4. 对于根节点为空则直接返回true

总结：1：找左子树、右子树最大差值。2：以每个节点为根节点，此时只需要把isBalance（root.right/left）带入进去判断即可，只能判断返回false类型

![class Solution {  public boolean isBa1anced(TreeNode root) {  return true;  if( ! isBa1anced(root . left) I I right)  return false;  return Math . left) -rootdeep(root. right) ? false: true;  private int rootdeep(TreeNode root){  null)  return e;  return Math . max( rootdeep(root . left) , rootdeep( root. right) )+1; ]()

## 187：重复的DNA序列

![1  2  3  4  5  6  7  8  9  le  11  12  13  14  class Solution {  public List<String> findRepeatedDnaSequences(String s) {  ArrayList<String> ans=new ArrayList<String>();  Map<String, Integer> map-new HashMap<String,  for(int i=e;i<=s.1ength()-10;i++){  String  map. put (temp , map. getOrDefau1t (temp , e) +1) ;  if(map.get(temp)==2){  ans . add (temp) ;  return ans; ](data:image/png;base64,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)

> 解法：滑动窗口

1. List、Set、Map都是接口，而对于接口都有对应的实现类

例：List：ArrayList、LinkedList

Set：HashSet、LinkedHashSet、TreeSet

Map：HashMap、LinkedHashMap、TreeMap

2：对于ArrayList实现的方法有add，可以直接添加数据

3：对于String类，substring（开始位置，结束位置的前一个）

4：对于滑动窗口，本身长度也算一个，因此滑动次数为（总长度-定长）+1

5：getOrDefault（key值，默认值），如果根据key值找不到对应的value就返回默认值

6：get（key）：根据key值查找对应的value

7：映射：多个key值可能对应同一个value

8：数组长度：length

 字符串长度：length()

##  爬楼梯

> 解法：哈希表+递归

```java
class Solution {
    HashMap<Integer,Integer> map=new HashMap();
    public int climbStairs(int n) {
        if(n==1)
        return 1;
        if(n==2)
        return 2;
        if(map.containsKey(n))
        return map.get(n);
        map.put(n,climbStairs(n-1)+climbStairs(n-2));
        return map.get(n);
    }
}
```

1. 递归之所以运算时间长是因为计算了大量相同的数值，因此我们可以把值放在一个哈希表的数组中，用containsKey来根据键值查找对应的存的结果
2. 用get方法获取到最后一个值

## 使用最小花费爬楼梯

> 解法：状态转移方程

```java

class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n=cost.length;
        int[] dp=new int[n+1];
        dp[0]=dp[1]=0;
        for(int i=2;i<=n;i++){
            dp[i]=Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        return dp[n];
    }
}
```

1. 爬到第i级的顶层需要i-1级的体力或者i-2级的体力同时加上到达该层所需的体力
2. 到达第一层与第二层所需体力都为零

## 198.打家劫舍

> 解法:找出状态转移方程

```java
/*
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
*/
class Solution {
    public int rob(int[] nums) {
        int length=nums.length;
        if(length==0) return 0;
        if(length==1) return nums[0];
        int[] dp=new int[length];
        dp[0]=nums[0];
        dp[1]=Math.max(dp[0],nums[1]);
        for(int i=2;i<length;i++){
            dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[length-1];
    }
}
```

1. 状态转移方程：dp[i]=Math.Max(dp[i],dp[i-2]+nums[i]);
2. 由1知循环从2开始，dp【i】中存放的永远是最优的
3. 无值时返回0，有一个值返回第一个值，有两个值时返回两者中最大的那个

## 213.打家劫舍II

> 解法：状态转移方程。
>

```java
/*你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。*/
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        if(n==1) return nums[0];
        if(n==0) return 0;
        if(n==2) return Math.max(nums[0],nums[1]);
        return Math.max(dp(nums,0,n-1),dp(nums,1,n));
    }
    public int dp(int[] nums,int start,int end){
        int[] dp=new int[nums.length];
        dp[start]=nums[start];
        dp[start+1]=Math.max(dp[start],nums[start+1]);
        for(int i=start+2;i<end;i++)
            dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);
        return dp[end-1];
    }
}
```

1. 与打家劫舍I的不同时，本题需要判断第一家是否偷，因此可以使用Math中的方法进行判断

2. 比较的是第一家到最后一家的前一家、第二家到最后一家

## 740：删除并获得点数

> 动态规划【哈希表+动态转移方程】

```java
/*给你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。*/
class Solution {
    public int deleteAndEarn(int[] nums) {
        int max=0;
        for(int i:nums)
            if(i>max) max=i;
        int[] num=new int[max+1];
        for(int i:nums)
            num[i]+=i;
        if(num.length==0) return 0;
        return dp(num);
    }
    public int dp(int[] num){
        int n=num.length;
        int[] dp=new int[n];
        dp[0]=num[0];
        dp[1]=Math.max(dp[0],num[1]);
        for(int i=2;i<n;i++){
            dp[i]=Math.max(dp[i-1],dp[i-2]+num[i]);
        }
        return dp[n-1];
    }
}
```

1. 用增强for循环遍历出最大值max，建立一个新数组，下标最大值为max，因此长度必须是max+1
2. 将相同值的加在一起，以元值代表下标
3. 将加起来的值看作金钱的值，相邻下表可以看作相邻房屋
4. 建立数组时没有找到的下标其中存的值默认为0

## 55.跳跃游戏

```java
/*
给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标
*/
class Solution {
    public boolean canJump(int[] nums) {
        int k=0;//k为当前能够到达的最大位置
        for(int i=0;i<nums.length;i++){
            if(i>k) return false;//【关键】遍历元素位置下标大于当前能够到达的最大位置下标，不能到达
            
            //能够到达当前位置，看是否更新能够到达的最大位置k
            k=Math.max(k,i+nums[i]);//当前位置+元素值
        }
        //跳出则表明能够到达最大位置
        return true;
    }
} 
```

> 解法：如果能到达当前位置，那么一定能够到达当前位置左边的所有位置

1. 挨个判断所能走的最远位置，如果i走到sum到达不了的地方就返回false。

## 45. 跳跃游戏||

```java
/*给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。*/
class Solution {
    public int jump(int[] nums) {
        int ans=0;
        int start=0;
        int end=1;
        while(end<nums.length){
            int max=nums[start];
            for(int i=start;i<end;i++){
                max=Math.max(max,i+nums[i]);
            }
            start=end;
            end=max+1;
            ans++;
        }
        return ans;
    }
}
```

> 解法：贪心+动态规划

![图片.png](https://gitee.com/demon_night/images/raw/master/imgs/202201291821178.png)

1. 跳一次就进入一个新的范围，只要这个范围包括到了最后一个值，就结束
2. 由于i是下标，i+nums[i]比实际长度少一，因此还需要再加1
3. 确定一个范围就跳一次

## 53. 最大子数组和

```java
/*
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和
*/
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int[] dp=new int[n];
        dp[0]=nums[0];//赋初始值
        int sum=dp[0];//找一个值用于存最大值
        for(int i=1;i<n;i++){
            dp[i]=Math.max(dp[i-1]+nums[i],nums[i]);//判断是否连接到该值形成一个新的子数组或者以该值为一个子数组
            if(dp[i]>sum) sum=dp[i];//始终保持sum存的子数组的最大值
        }
        return sum;
    }
}
```

> 解法：动态规划

1. 重点是找到状态转移方程：dp[i]=Math.max(dp[i-1]+nums[i],nums[i])
2. 可以加上一个比他小的，目的是连接到该值，以便寻找后面是否还有比目前最大值大的数【连接该值之前已经把遇见的最大值存起来了】
3. 当前值如果 < 当前值+前面子数组的值：那就连接
4. 当前值如果 < 当前值+前面子数组的值：那就以当前值为子数组的值

## 918. 环形子数组的最大和

```java
/*
给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。
在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 <= i < A.length 时 C[i] = A[i]，且当 i >= 0 时 C[i+A.length] = C[i]）
此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], ..., C[j]，不存在 i <= k1, k2 <= j 其中 k1 % A.length = k2 % A.length）
*/
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int n=nums.length;
        int[] dp1=new int[n];
        int[] dp2=new int[n];
        dp1[0]=nums[0];
        dp2[0]=nums[0];
        int max=dp1[0];
        int min=dp2[0];
        int sum=nums[0];
        for(int i=1;i<n;++i){
            sum+=nums[i];
            dp1[i]=Math.max(dp1[i-1]+nums[i],nums[i]);
            dp2[i]=Math.min(dp2[i-1]+nums[i],nums[i]);
            if(dp1[i]>max) max=dp1[i];
            if(dp2[i]<min) min=dp2[i];
        }
        if(sum-min==0){
            return max;
        }
        return Math.max(max,sum-min);
    } 
}
```

> 大佬解法：

```java
  public int maxSubarraySumCircular(int[] A) {
        int total = 0, maxSum = A[0], curMax = 0, minSum = A[0], curMin = 0;
        for (int a : A) {
            curMax = Math.max(curMax + a, a);
            maxSum = Math.max(maxSum, curMax);
            curMin = Math.min(curMin + a, a);
            minSum = Math.min(minSum, curMin);
            total += a;
        }
        return maxSum > 0 ? Math.max(maxSum, total - minSum) : maxSum;
    }
```

![image-20211215143012386](https://gitee.com/demon_night/images/raw/master/imgs/202201291822695.png)

> 解法：动态规划

1. 对于最大子数组在头尾连接处时可以采用  数组总和 - 数组中最小值

2. 对于最大子数组在数组中间可以直接把他当成一个不是头尾相接的数组来执行

3. 为什么除了最大子数组外，构成的连体一定是最小子数组

   因为如果最小子数组存在一个大于0子数组且紧挨着最大子数组时，一定会被最大子数组连接的

   小  大   小：如何大+小大于0，一定会被最大子数组吸收，既然没有被吸收，则 大 + 小 < 0  
   
4. 极端情况：如果说这数组的所有数都是负数，那么上面的公式还需要变一下，因为这种情况，对于上面的第一种情况sum会等于数组中的最大值，而对二种情况sum=0（最小的子数组就是本数组，total-total=0）。所以多加一个case，判断最大子数组和是否小于0，小于0，直接返回该maxSubArray

## 乘积最大子数组

```java
/*
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
*/
class Solution {
    public int maxProduct(int[] nums) {
        int n=nums.length;
        int[] dp1=new int[n];
        int[] dp2=new int[n];
        dp1[0]=nums[0];
        dp2[0]=nums[0];
        int max=dp1[0];
        for(int i=1;i<n;i++){
            dp1[i]=Math.max(dp1[i-1]*nums[i],Math.max(dp2[i-1]*nums[i],nums[i]));
            dp2[i]=Math.min(dp1[i-1]*nums[i],Math.min(dp2[i-1]*nums[i],nums[i]));
            if(max<dp1[i]) max=dp1[i];
        }
        return max;
    }
}
```

1. 这里的定义并不满足「最优子结构」, 当前位置的最优解未必是由前一个位置的最优解转移得到的. 用白话来解释就是: 两个负数相乘有可能会得到更大的结果, 当前的最大值并不一定是通过上个状态的最大值决定的, 也可能是上个状态的最小值决定的. 这都是因为加法和乘法的不同性质决定的.因此我们可以拿     前面最小值与当前数相乘、前面最大值与当前数相乘、当前值  进行比较，来找大最大值，用来解决前面最小值与当前值变大，而由于前面值较小而被省略的情况
2. 对于Math的max方法只能比较两个数，因此我们可以使用嵌套的形式来比较三个数中的最大值
3. 再维护一个·最大值变量，当遇到个最大值，就把最大值保存下来

## 1567. 乘积为正数的最长子数组长度

```java
/*
给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。
一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。
请你返回乘积为正数的最长子数组长度。
*/
class Solution {
    public int getMaxLen(int[] nums) {
        int n=nums.length;
        int ans=0;
        int z=0,f=-1,fs=0;
        for(int i=0;i<n;i++){
            if(nums[i]>0) z++;
            if(nums[i]<0) {fs++;
                if(f==-1) f=i;
            }
            if(nums[i]==0)  {z=0;f=-1;fs=0;}
            if(fs%2==0)
            ans=Math.max(ans,z+fs);
            if(fs%2!=0)
            ans=Math.max(ans,i-f);
        }
        return ans;
    }
}
```

1. 对于正数，不管有多少个，都是正数，因此只需要考虑负数是奇数个还是偶数个
2. 当遇见0时，就回到初始状态
3. 当遇见奇数个负数时，就判断是去除第一个负数后的子数组长还是去除最后一个子数组长
   1. 去除第一个负数后的长度：i-第一个负数的下标
   2. 去除最后一个负数的长度：也就是最大的长度遇见偶数个负数的ans结果

## 1014. 最佳观光组合

```java
/*
给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。

一对景点（i < j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。

返回一对观光景点能取得的最高分*/
class Solution {
    public int maxScoreSightseeingPair(int[] values) {
       int n=values.length;
       int ans=0;
       int pre_max=values[0];
       for(int i=1;i<n;i++){
            ans=Math.max(ans,pre_max+values[i]-i);
            pre_max=Math.max(pre_max,values[i]+i);
       } 
       return ans;
    }
}
```

1. 将values[i] + values[j] + i - j拆解成values[i] +  i+ values[j]  - j,即拆结成i和j
2. 始终保证pre_max是遍历中遇到的最大的
3. 由于j永远在i后面，所以当pre_max是最大值时，我们只需要遍历找到values【i】-i是最大就行

## 121. [买卖股票I](https://blog.csdn.net/baichoufei90/article/details/107245328)

```java
/*
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

*/
class Solution {
    public int maxProfit(int[] prices) {
        int n=prices.length;
        int pre_min=prices[0];
        int ans=0;
        for(int i=1;i<n;i++){
            ans=Math.max(ans,prices[i]-pre_min);
            pre_min=Math.min(pre_min,prices[i]);
        }
        return ans;
    }
}
```

> 解法:和观光组合一摸一样

## 122. 买卖股票II

```java
/*
给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
*/
class Solution {
    public int maxProfit(int[] prices) {
        int ans=0;
        int n=prices.length;
        for(int i=1;i<n;i++){
            ans=Math.max(ans,ans+prices[i]-prices[i-1]);
        }       
        return ans;
    }
}
```

> 解法：贪心算法

1. 由于没有限制买卖次数，因此，只要能相邻两天能获利就进行交易
2. 只要后项大于前项，则累加到结果中。
   想象连续两次涨，就累加了两次的差值，其实就等于 第三次卖 - 第一次买的差值

## 向字符串添加空格

```java
/*
给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces 。

数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 之前 。

例如，s = "EnjoyYourCoffee" 且 spaces = [5, 9] ，那么我们需要在 'Y' 和 'C' 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 "Enjoy Your Coffee" 。
请你添加空格，并返回修改后的字符串。*/
class Solution {
    public String addSpaces(String s, int[] spaces) {
        StringBuilder ss=new StringBuilder();
        int start=0;
        for(int space:spaces){
            ss.append(s.substring(start,space));
            start=space;
            ss.append(" ");
        }
        ss.append(s.substring(start,s.length()));
        return ss.toString();
    }
}
```

1. 根据给出空格的下标可以正好采用String类的substring方法来分割得到子字符串
2. toString方法是返回最原始的对象，StringBuilder类型对象可以被String类型接受

## 309. 最佳买卖股票时机含冷冻期

```java
/*
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。*/

class Solution {
    public int maxProfit(int[] prices) {
        int n=prices.length;
        int[][] dp=new int[n][4];
        dp[0][0]=0-prices[0];//持股
        dp[0][1]=0;//卖出
        dp[0][2]=0;//冷冻
        dp[0][3]=0;//不买不卖【不含有股票】
        for(int i=1;i<n;++i){
            dp[i][1]=dp[i-1][0]+prices[i];//卖出
            dp[i][2]=dp[i-1][1];//冷冻
            dp[i][3]=Math.max(dp[i-1][3],dp[i-1][2]);//不买
            dp[i][0]=Math.max(dp[i-1][0],Math.max(dp[i-1][2]-prices[i],dp[i-1][3]-prices[i]));//持股状态
        }
        return Math.max(dp[n-1][1],Math.max(dp[n-1][2],dp[n-1][3]));
    }
}
```

1. 首先明确买卖股票时有四种状态：持股、卖、不买不卖【不含有股票】、冷冻
2. 由于先定义了买入【i从1开始】，因此dp数组不能直接写买入了
3. 卖出状态：肯定是由持股状态转过来
4. 冷冻状态：由之前一天卖出状态转过来
5. 不买状态：由不买状态、冷冻状态转过来
6. 持股状态：由前一天冷冻状态转过来、持股状态、不买不卖【不含有股票】状态转过来

## 714 . 买卖股票的最佳时机含手续费

```java
/*
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。*/

class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n=prices.length;
        int[][] dp=new int[n][2];
        dp[0][0]=-prices[0];//持股
        dp[0][1]=0;//不持股
        for(int i=1;i<n;++i){
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices[i]-fee);//不持股
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);//持股
        }
        return dp[n-1][1];
    }
}
```

1. 两种状态：持股，不持股
2. 由于初始状态时持股状态，因此dp从不持股状态开始
3. 不持股状态：由前一天不持股状态、前一天持股今天卖股份转换而来
4. 持股状态：由前一天持股状态、前一天不持股今天买股份而来

## 413. 等差数列的划分

```java
/*
如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。
给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。

子数组 是数组中的一个连续序列。
*/
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        int n=nums.length;
        if(n<3) return 0;
        int[] dp=new int[n];
        dp[0]=dp[1]=0;
        int ans=0;
        for(int i=2;i<n;++i){
            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){
                dp[i]=dp[i-1]+1;
            }
            ans+=dp[i];
        }
        return ans;
    }
}
```

1. 首先明确开辟的dp数组，默认填入0

2. 比如【1，2，3】======123                                      dp[3]=1

   		【1，2，3，4】====234，1234                       dp[4]=dp[3]+1
		
   		【1，2，3，4，5】=345，12345，2345		dp[5]=dp[4]+1

3. 因此如果对于一个子数组如果能够连接到后面一个数，所产生的贡献值就比前一个连接数所产生地贡献值多1

4. 如果当前数连接不了前面的子数组，则贡献值dp又变成0了，如果下一个数，又能与前面那个连接起来，即三个数组成一个子数组，则dp加1

## 264. 丑数II

```java
/*
给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。
*/
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp=new int[n+1];
        int p2=1,p3=1,p5=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            int num2=dp[p2]*2;
            int num3=dp[p3]*3;
            int num5=dp[p5]*5;
            dp[i]=Math.min(num2,Math.min(num3,num5));
            if(dp[i]==num2) p2++;
            if(dp[i]==num3) p3++;
            if(dp[i]==num5) p5++;
        }
        return dp[n];
    }
}
```

<img src="https://gitee.com/demon_night/images/raw/master/imgs/202201291822162.png" alt="image-20211221135821510" style="zoom:25%;" />

1. 对于每个丑数都需要从1开始乘，因此被乘数从1开始
2. 1是丑数，因此dp【1】=1
3. 下一个数就要从1 * 2、1 * 3、1 * 5里面选个最小的出来
4. 抽过1 * 2后就要变成2*2加入待选项【待选项：2 * 2、1 * 3、1 * 5】
5. dp中存的是相乘的结果、p存的是递增i的大小
6. 如果三个预选项中有两个重复的，就都自增一下i但是dp中还是只存了一个丑数

## 96. [不同的二叉搜索树【不懂】](https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/)

```java
/*
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
*/
class Solution {
    public int numTrees(int n) {
        int[] dp=new int[n+1];
        dp[0]=dp[1]=1;
        for(int i=2;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
}
```

1. 左边有几种 * 右边有几种就等于以该 i 为根节点的的所有的取值
2. 遍历 i 【根节点】的所有可能取值，就是总的取值个数
3. 左子树、右子树【除掉该根节点】又分别可以看作一个二叉搜索树
4. dp【i】求的是总和、dp【j-1】*dp[i-j]求的是以 i 为跟节点的所有的二叉搜索树

## 118. 杨辉三角

```java
/*
给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。、
*/
class Solution {
    public List<List<Integer>> generate(int numRows) {
       List<List<Integer>> list=new ArrayList<List<Integer>>();
       List<Integer> row1=new ArrayList<Integer>();
       row1.add(1);
       list.add(row1);
       for(int i=1;i<numRows;i++){
           List<Integer> row=new ArrayList<Integer>();
           row.add(1);
           if(i>1){
                for(int j=1;j<i;j++){
                    row.add(list.get(i-1).get(j-1)+list.get(i-1).get(j));
                } 
           }
           row.add(1);
           list.add(row);
       }
        return list;
    }
}
```

1. 对于List接口的集合实现必须是arrayLsit等类，内层数组可以依旧写成List接口形式
2. 往外层数组添加时添加的是数组
3. 获取二维数组的值时可以先获取外层的数组，再根据数组找到里面的值
   1. list.get(i-1).get(j-1)

## 42. 接雨水

![img](https://gitee.com/demon_night/images/raw/master/imgs/202201291822914.png)

```java
/*
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
*/
class Solution {
    public int trap(int[] height) {
        int n=height.length;

        int[] max_left=new int[n];
        max_left[0]=height[0];
        for(int i=1;i<n;++i){
            max_left[i]=Math.max(max_left[i-1],height[i]);
        }

        int[] max_right=new int[n];
        max_right[n-1]=height[n-1];
        for(int i=n-2;i>=0;--i){
            max_right[i]=Math.max(max_right[i+1],height[i]);
        }

        int ans=0;
        for(int i=0;i<n;++i){
            ans+=Math.min(max_left[i],max_right[i])-height[i];
        }
        return ans;
    }
}
```

1. 该下标所能存储的最大水量为左边最高与右边最高中最矮的那个  减去当前下标的高度

2. 找到左边最高的就从左往右遍历，寻找最大值，保证当前下标时遍历所遇到的最大值

3. 找到右边最高的就从右往左遍历，寻找最大值，保证当前下标时遍历所遇到的最大值
   
   <img src="https://gitee.com/demon_night/images/raw/master/imgs/202201291822757.png" alt="image-20211223114348222" style="zoom:25%;" />

## 931. 下降路径最小和

```java
/*
给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。

下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。
*/
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int n=matrix.length;
        for(int i=n-2;i>=0;--i){
            for(int j=0;j<n;++j){
                int min_values=matrix[i+1][j];
                if(j>0) min_values=Math.min(min_values,matrix[i+1][j-1]);//不在边界时，在边界时
                if(j+1<n) min_values=Math.min(min_values,matrix[i+1][j+1]);//位于边界时、不在边界时
                matrix[i][j]+=min_values;
            }
        }
        int ans=matrix[0][0];
        for(int i:matrix[0]){
            ans=Math.min(ans,i);
        }
        return ans;
    }
}
```

1. <img src="https://gitee.com/demon_night/images/raw/master/imgs/202201291822539.png" alt="image-20211223114716344"  />

2. 对于选哪条路径，我们可以先从倒数第二行开始，然后比较该行下面的两个或三个数
3. 如果位于边界0处时，用该位置下面的和右面的值进行比较
4. 如果位于n-1处时就用该位置与前一个位置进行比较
5. 连续进行比较后最小值就存放在数组的第一行中
6. 重点：如何处理边界问题
   1. 中间的值：能与两边都进行比较
   2. 最左侧的值：只能与右侧的进行比较
   3. 最右侧的值：只能与左侧的值进行比较

## 120. 三角形最小路径和

```java
/*
给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
*/
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n=triangle.size();
        for(int i=n-2;i>=0;--i){
            for(int j=0;j<i+1;++j){
                int min_value=triangle.get(i+1).get(j);
                if(j+1<n) min_value=Math.min(min_value,triangle.get(i+1).get(j+1));
                triangle.get(i).set(j,triangle.get(i).get(j)+min_value);
            }
        }
        return triangle.get(0).get(0);
    }
}
```

1. 和931题一样，把最小值一直递增到最顶层
2. 但是不一样的是，每往上一层就减去1，因此遍历的界限不能是定值，应该与 i 扯上关系
3. 因为只比较左右两值，因此我们可以把它看成遇到右边界
4. 结合修改值用set（下标，值）

## 304. 二维区域和检索——矩阵不可变

```java
/*
给定一个二维矩阵 matrix，以下类型的多个请求：

计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。
实现 NumMatrix 类：

NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化
int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。*/
class NumMatrix {
    int[][] sum;
    public NumMatrix(int[][] matrix) {
        int n=matrix.length;
        if(n>0){
            int len=matrix[0].length;
            sum=new int[n][len+1];
            for(int i=0;i<n;++i){
                for(int j=0;j<len;j++){
                    sum[i][j+1]=sum[i][j]+matrix[i][j];
                }
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int ans=0;
        for(int i=row1;i<=row2;i++){
            ans+=sum[i][col2+1]-sum[i][col1];
        }
        return ans;
    }
}

```

1. 建立一个与之相同的矩阵求和数组【列多一条】
2. 创建求和数组时必须是求和数组的前一个+前一个数组【因为求和数组初始化为0，不能用当前列的求和数组+前一列的数据】
3. 将遍历当前行当前位置的所有和放在求和数组与之对应下标的下一列
4. 求和时只需要当前行最后一列 减去当前行头一列【头一列正好是头一列前面所有数的和】

## 62. 不同路径

```java
/*
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？
*/
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp=new int[m][n];
        for(int i=0;i<m;i++) dp[i][0]=1;
        for(int i=0;i<n;i++) dp[0][i]=1;
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

1. 由于机器人该位置的结果只与上方和左方有关，因此考虑使用动态规划求解
2. 使用动态规划首先初值进行初始化，所以第一行、第一列都初始化为1
3. 返回dp数组中的最后一个值

## 63. 不同路径II

```java
/*
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
*/
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m=obstacleGrid.length;//找行数
        int n=obstacleGrid[0].length;//找列数
        int[][] dp=new int[m][n];//创建dp数组
        for(int i=0;i<m;i++){
            dp[i][0]=1;//初始化 列 边界值
            if(obstacleGrid[i][0]==1) {dp[i][0]=0;break;};//如果遇到障碍物，该列该位置后面都变成0
        }
        for(int i=0;i<n;i++){
            dp[0][i]=1;//初始化 行 边界值
            if(obstacleGrid[0][i]==1) {dp[0][i]=0;break;}//如果遇到障碍物，该行该位置后面都变成0
        }    
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]==1) dp[i][j]=0;//如果是障碍物就将该位置置为0
                else dp[i][j]=dp[i-1][j]+dp[i][j-1];//否则就加上左方和上方的值
            }
        } 
        return dp[m-1][n-1];       
    }
}
```

1. 和62题不同的是添加了障碍物，即在初始化时发生了改变，初始化时如果遇到了障碍物其后面的就不再将其赋值为1
2. 如果该位置是障碍物，该位置dp值就置为0，否则该位置dp值为左方加上上方

## 64. 最小路径和

```java
/*
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。
*/
class Solution {
    public int minPathSum(int[][] grid) {
        int m=grid.length;
        int n=grid[0].length;
        int[][] dp=new int[m][n];
        dp[0][0]=grid[0][0];
        for(int i=1;i<m;i++) dp[i][0]=grid[i][0]+dp[i-1][0];
        for(int i=1;i<n;i++) dp[0][i]=grid[0][i]+dp[0][i-1];
        for(int i=1;i<m;++i){
            for(int j=1;j<n;++j){
                dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
}
```

1. 确定初始状态【此时每个位置采用累加的方式】
2. 进入dp状态转移时该位置只加上左方、右方中最小的

## 392. 判断子序列

```java
/*
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
*/
class Solution {
    public boolean isSubsequence(String s, String t) {
        int a=s.length();
        int b=t.length();
        if(b==0&&a==0) return true;
        if(b==0) return false;
        if(a==0&&b!=0) return true;
        for(int i=0,j=0;j<b;++j){
            if(s.charAt(i)==t.charAt(j)) i++;
            if(i==a) return true;
        }
        return false;
    }
}
```

1. 先找到两个字符串的长度
2. 对三种特殊情况进行判断
   1. 两个字符串都为空时，返回false
   2. 当大字符串为空时，返回false
   3. 当小字符串为空时，返回true【为的是把a==0的情况排除在外】
3. for循环，循环的截至条件是小字符串遍历完了【都找到了】、遍历完大字符串
4. 如果遍历完了大字符串还没返回，部分字符在大字符串中没有找到
5. 需要注意的是小字符串是找到之后才往后自增的

## 1143. 最长公共子序列

<img src="https://gitee.com/demon_night/images/raw/master/imgs/202201291823578.png" alt="image.png" style="zoom: 33%;" />

```java
/*
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

*/
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int a=text1.length();
        int b=text2.length();
        if(a==0||b==0) return 0;
        int[][] dp=new int[a+1][b+1];
        for(int i=0;i<=a;i++) dp[i][0]=0;
        for(int i=0;i<=b;i++) dp[0][i]=0;
        for(int i=1;i<=a;++i){
            for(int j=1;j<=b;++j){
                if(text1.charAt(i-1)==text2.charAt(j-1)) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
            }
        }          
        return dp[a][b];
    }
}
```

1. 由于是查找一个字符串的部分字符串与另一个字符串的部分字符串的最长重合序列
2. 对于dp数组需要先初始化第一行、列
3. 由于循环是从1开始的，而我们进行比较时时从第一个元素开始比较的，因此我们需要把前一个元素的比较结果存放在dp数组当前位置的下一个
4. 对于相等的就行+1.否则进行从左方、上方查找最大值

## 322. 零钱兑换

![image-20220109002619660](https://gitee.com/demon_night/images/raw/master/imgs/202201291823681.png)

```java
/*
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。
*/
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        for(int i=1;i<=amount;i++){
            for(int j=0;j<coins.length;j++){
                if(i>=coins[j]){
                    dp[i]=Math.min(dp[i],dp[i-coins[j]]+1);
                }
            }
        }
        return dp[amount]==amount+1 ? -1:dp[amount];
    }
}
```

1. 运用动态规划求解
2. 定义dp数组时，位置0的地方表示amount为0，则需要硬币数为0，对于其他地方则定义成最大值，即比拿1元的换的数目还要大：amount+1
3. 对于填充数组某个值可以采用Arrays.fill的方法
4. 比如说对于amount=2时，采用1元的硬币时dp[i]=2,采用2元的硬币时dp【i】=1，因此需要进行Math.min(dp[i],dp[i-coins[j]]+1);
5. 对于当前硬币数目大于acount时可以跳过，因此采用if语句
6. 由于返回值有两种：-1和数量，因此可以采用三目表达式，如果当前值还是之前的那个最大值，说明找不到合适的硬币去替换

## 518. 零钱兑换II

```java
/*
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。
*/
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp=new int[amount+1];
        dp[0]=1;
        for(int coin:coins){
            for(int i=coin;i<=amount;i++){
                dp[i]+=dp[i-coin];
            }
        }
        return dp[amount];
    }
}
```

1. 需要从中分解出amount=0，coins=0的情况
2. i从硬币的最小值开始，从而避免i-count小于0的情况出现，
3. 对于每个硬币，如果当前值-该硬币为0就+1，从而不断地更新dp【i】

## 343. 整数拆分

![image-20220108234842722](https://gitee.com/demon_night/images/raw/master/imgs/202201291823795.png)

```java
/*
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
*/
class Solution {
    public int integerBreak(int n) {
        int[] dp=new int[n+1];
        for(int i=2;i<=n;i++){
            for(int j=1;j<i;j++){
                dp[i]=Math.max(dp[i],Math.max(dp[i-j]*j,(i-j)*j));
            }
        }
        return dp[n];
    }
}
```

1. 对于一个数有两种走向
   1. 直接分解成两个数
   2. 分解成1个dp、1个数
2. 更新dp

## 279. 完全平方数

![ds_204](https://gitee.com/demon_night/images/raw/master/imgs/202201291823343.png)

```java
/*
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
*/
class Solution {
    public int numSquares(int n) {
        int[] dp=new int[n+1];
        for(int i=0;i<=n;i++){
            dp[i]=i;
            for(int j=1;j*j<=i;j++){
                dp[i]=Math.min(dp[i],dp[i-j*j]+1);
            }
        }
        return dp[n];
    }
}
```

1. 最坏的情况就是，该数的完全平方数全用1，因此dp【i】=i
2. dp【10】可以时dp【1】+完全平方数9===》dp【1】+1
3. 但是要保证`j`的平方大于`i`，因为dp【i-j*j】下标不能小于0

## [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        int[] dp=new int[n];
        int ans=1;
        Arrays.fill(dp,1);
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                    ans=Math.max(ans,dp[i]);
                }
            }
        }
        return ans;
    }
}
```

1. 挨个遍历数组nums中的值，相对于前面的能形成多长的子序列
2. 对于其子序列最短也是1，因此ans、dp初始值都为1，对于数组使用Arrays.fill()方法进行填充
3. 不断更新ans值
3. 

力扣刷题列表

# Array

### [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

> 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
>
> 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
>
> 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
>
>  
>
> 示例 1：
>
> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
> 输出：[1,2,2,3,5,6]
> 解释：需要合并 [1,2,3] 和 [2,5,6] 。
> 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
> 示例 2：
>
> 输入：nums1 = [1], m = 1, nums2 = [], n = 0
> 输出：[1]
> 解释：需要合并 [1] 和 [] 。
> 合并结果是 [1] 。
> 示例 3：
>
> 输入：nums1 = [0], m = 0, nums2 = [1], n = 1
> 输出：[1]
> 解释：需要合并的数组是 [] 和 [1] 。
> 合并结果是 [1] 。
> 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
>
> ![image-20220527213647768](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220527213647768.png)

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int temp=-1;
        for(int i=m;i<m+n;i++){
            nums1[i]=nums2[++temp];
        }
        Arrays.sort(nums1);
    }
}
```

1. 合并后排序

### [1260. 二维网格迁移](https://leetcode.cn/problems/shift-2d-grid/)

> 给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。
>
> 每次「迁移」操作将会引发下述活动：
>
> 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。
> 位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。
> 位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。
> 请你返回 k 次迁移操作后最终得到的 二维网格。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e1-1.png)
>
> 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
> 输出：[[9,1,2],[3,4,5],[6,7,8]]
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e2-1.png)
>
> 输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
> 输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
> 示例 3：
>
> 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
> 输出：[[1,2,3],[4,5,6],[7,8,9]]
>
>
> 提示：
>
> m == grid.length
> n == grid[i].length
> 1 <= m <= 50
> 1 <= n <= 50
> -1000 <= grid[i][j] <= 1000
> 0 <= k <= 100

```java
class Solution {
    public List<List<Integer>> shiftGrid(int[][] grid, int k) {
        int a=grid.length,b=grid[0].length;
        int[][] temp=new int[a][b];
        List<List<Integer>> ans=new ArrayList<>();
        for(int i=0;i<k;i++){

            for(int m=0;m<a;m++){
                for(int n=0;n<b-1;n++){
                    temp[m][n+1]=grid[m][n];
                }
            }
            for(int m=0;m<a-1;m++){
                temp[m+1][0]=grid[m][b-1];
            }
            temp[0][0]=grid[a-1][b-1];

            for(int m=0;m<a;m++){
                for(int n=0;n<b;n++){
                    grid[m][n]=temp[m][n];
                }
            }
        }

        for(int m=0;m<a;m++){
            List<Integer> temp1=new ArrayList<>();
            for(int n=0;n<b;n++){
                temp1.add(n,grid[m][n]);
            }
            ans.add(m,temp1);
        }

        return ans;
    }
}
```

1. 暴力求解

### [941. 有效的山脉数组](https://leetcode.cn/problems/valid-mountain-array/)

> 给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。
>
> 让我们回顾一下，如果 arr 满足下述条件，那么它是一个山脉数组：
>
> arr.length >= 3
> 在 0 < i < arr.length - 1 条件下，存在 i 使得：
> arr[0] < arr[1] < ... arr[i-1] < arr[i]
> arr[i] > arr[i+1] > ... > arr[arr.length - 1]
>
> 
>
> <img src="https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png" alt="img" style="zoom: 67%;" />
>
>
> 示例 1：
>
> 输入：arr = [2,1]
> 输出：false
> 示例 2：
>
> 输入：arr = [3,5,5]
> 输出：false
> 示例 3：
>
> 输入：arr = [0,3,2,1]
> 输出：true
>
> ![image-20220528215748246](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220528215748246.png)

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        if(arr.length==1) return false;
        if(arr[0]>arr[1]) return false;
        int i=1;
        while (i<arr.length){
            if(arr[i]<arr[i-1]) break;
            if(arr[i]==arr[i-1]) return false;
            i++;
        }

        if(i==arr.length) return false;

        while (i<arr.length){
            if(arr[i]>arr[i-1]) return false;
            if(arr[i]==arr[i-1]) return false;
            i++;
        }

        return true;
    }
}
```

**线性扫描**

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        int n=arr.length;
        int i=0;

        while (i+1<n&&arr[i]<arr[i+1]){
            i++;
        }

        if(i==0||i==n-1) return false;

        while (i+1<n&&arr[i]>arr[i+1]){
            i++;
        }

        return i==n-1;
    }
}
```

### [80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

> 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
>
>  
>
> 说明：
>
> 为什么返回数值是整数，但输出的答案是数组呢？
>
> 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
>
> 你可以想象内部操作如下:
>
> // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
> int len = removeDuplicates(nums);
>
> // 在函数里修改输入数组对于调用者是可见的。
> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
> for (int i = 0; i < len; i++) {
>     print(nums[i]);
> }
>
>
> 示例 1：
>
> 输入：nums = [1,1,1,2,2,3]
> 输出：5, nums = [1,1,2,2,3]
> 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
> 示例 2：
>
> 输入：nums = [0,0,1,1,1,1,2,3,3]
> 输出：7, nums = [0,0,1,1,2,3,3]
> 解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
>
> ![image-20220528230021978](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220528230021978.png)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length<=2) return nums.length;
        int l=2,r=2;
        while (r<nums.length){
            if(nums[r]!=nums[l-2]){
                nums[l]=nums[r];
                l++;
            }
            r++;
        }
        
        return l;
    }
}
```

1. 感觉像是贪心
2. 不判断r下标元素是否和l-1下标的元素，而是判断的是r下标与l-2下标的元素是否相等
3. l指向的是需要更改的位置

### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

> 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
>
>  
>
> 示例 1：
>
> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出：[[1,6],[8,10],[15,18]]
> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> 示例 2：
>
> 输入：intervals = [[1,4],[4,5]]
> 输出：[[1,5]]
> 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
>
> ![image-20220529224115251](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220529224115251.png)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(o1,o2)->o1[0]-o2[0]);

        List<int[]> ans=new ArrayList<>();
        for(int i=0;i<intervals.length;i++){
            int l=intervals[i][0],r=intervals[i][1];
            if(ans.size()==0||ans.get(ans.size()-1)[1]<l){
                ans.add(new int[]{l,r});
            }else{
                ans.get(ans.size()-1)[1]=Math.max(r,ans.get(ans.size()-1)[1]);
            }
        }

        return ans.toArray(new int[ans.size()][]);
    }
}
```

1. 贪心
2. 集合转数组：toArray（定义想要转换的对象）

### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

> 整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。
>
> 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
> 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
>
> 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
> 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
> 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
> 给你一个整数数组 nums ，找出 nums 的下一个排列。
>
> 必须 原地 修改，只允许使用额外常数空间。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,2,3]
> 输出：[1,3,2]
> 示例 2：
>
> 输入：nums = [3,2,1]
> 输出：[1,2,3]
> 示例 3：
>
> 输入：nums = [1,1,5]
> 输出：[1,5,1]
>
>
> 提示：
>
> 1 <= nums.length <= 100
> 0 <= nums[i] <= 100

```java
class Solution {
    public void nextPermutation(int[] nums) {
        for(int i=nums.length-1;i>0;i--){
            for(int j=nums.length-1;j>i;j--){
                if(nums[i]<nums[j]){
                    swap(nums,i,j);
                    Arrays.sort(nums,i+1,nums.length);
                    return;
                }
            }
        }
        Arrays.sort(nums);
    }

    public void swap(int[] nums,int a,int b){
        int temp=nums[a];
        nums[a]=nums[b];
        nums[b]=temp;
    }
}
```

双指针

```tex
12345
12354
12453-》特定位置排序后12435
12534
12543
13542-》特定位置排序后132
```

1. 特定位置排序，左闭右开：Arrays.sort(nums,i,j);

### [442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/)

> 给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。
>
> 你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。
>
>  
>
> 示例 1：
>
> 输入：nums = [4,3,2,7,8,2,3,1]
> 输出：[2,3]
> 示例 2：
>
> 输入：nums = [1,1,2]
> 输出：[1]
> 示例 3：
>
> 输入：nums = [1]
> 输出：[]
>
> ![image-20220530221935818](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220530221935818.png)

```java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        int[] a=new int[nums.length+1];
        Arrays.fill(a,0);

        for(int i:nums){
            a[i]++;
        }

        List<Integer> ans=new ArrayList<>();
        for(int i=0;i<nums.length+1;i++){
            if(a[i]==2) ans.add(i);
        }

        return ans;
    }
}
```

1. 数组哈希记录

### [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

> 给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
> 我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
>
> 必须在不使用库的sort函数的情况下解决这个问题。
>
>  
>
> 示例 1：
>
> 输入：nums = [2,0,2,1,1,0]
> 输出：[0,0,1,1,2,2]
> 示例 2：
>
> 输入：nums = [2,0,1]
> 输出：[0,1,2]
>
>
> 提示：
>
> n == nums.length
> 1 <= n <= 300
> nums[i] 为 0、1 或 2

**双指针**

```java
class Solution {
    public void sortColors(int[] nums) {
        int last0=-1,first2=nums.length;
        int current=0;
        while (current<first2){
            if(nums[current]==0){
                swap(nums,last0+1,current);
                last0++;
                current++;
            }else if(nums[current]==1){
                current++;
            }else {
                swap(nums,first2-1,current);
                first2--;
            }
        }
    }

    public void swap(int[] nums,int a,int b){
        int temp=nums[a];
        nums[a]=nums[b];
        nums[b]=temp;
    }
}
```

```tex   
  2 0 2 1 1 0
-1            n
```

1. 如果是对0进行交换，current需要+1，因为前面不可能有2或0
2. 但是如果是对2进行交换，则交换后current下标元素可能是1也可能是0，也可能是2，需要再次进行判断，因此current不能+1；
3. 如果当前位置元素是1，则继续判断下一位

### [57. 插入区间](https://leetcode.cn/problems/insert-interval/)

> 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。
>
> 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
>
>  
>
> 示例 1：
>
> 输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
> 输出：[[1,5],[6,9]]
> 示例 2：
>
> 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
> 输出：[[1,2],[3,10],[12,16]]
> 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
> 示例 3：
>
> 输入：intervals = [], newInterval = [5,7]
> 输出：[[5,7]]
> 示例 4：
>
> 输入：intervals = [[1,5]], newInterval = [2,3]
> 输出：[[1,5]]
> 示例 5：
>
> 输入：intervals = [[1,5]], newInterval = [2,7]
> 输出：[[1,7]]
>
> ![image-20220531205738890](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220531205738890.png)

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> ans=new ArrayList<>();
        Collections.addAll(ans,intervals);
        ans.add(newInterval);
        Collections.sort(ans,((o1, o2) -> o1[0]-o2[0]));

        List<int[]> temp=new ArrayList<>();
        for(int i=0;i<ans.size();i++){
            int l=ans.get(i)[0],r=ans.get(i)[1];
            if(temp.size()==0||temp.get(temp.size()-1)[1]<l){
                temp.add(new int[]{l,r});
            }else{
                temp.get(temp.size()-1)[1]=Math.max(r,temp.get(temp.size()-1)[1]);
            }
        }

        return temp.toArray(new int[temp.size()][]);
    }
}
```

1. 将新数组添加到集合中，然后进行排序，然后合并数组
2. Collections的addAll可以将数组添加到集合中

### [5229. 拼接数组的最大分数](https://leetcode.cn/problems/maximum-score-of-spliced-array/)

> 给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度都是 n 。
>
> 你可以选择两个整数 left 和 right ，其中 0 <= left <= right < n ，接着 交换 两个子数组 nums1[left...right] 和 nums2[left...right] 。
>
> 例如，设 nums1 = [1,2,3,4,5] 和 nums2 = [11,12,13,14,15] ，整数选择 left = 1 和 right = 2，那么 nums1 会变为 [1,12,13,4,5] 而 nums2 会变为 [11,2,3,14,15] 。
> 你可以选择执行上述操作 一次 或不执行任何操作。
>
> 数组的 分数 取 sum(nums1) 和 sum(nums2) 中的最大值，其中 sum(arr) 是数组 arr 中所有元素之和。
>
> 返回 可能的最大分数 。
>
> 子数组 是数组中连续的一个元素序列。arr[left...right] 表示子数组包含 nums 中下标 left 和 right 之间的元素（含 下标 left 和 right 对应元素）。
>
>  
>
> 示例 1：
>
> 输入：nums1 = [60,60,60], nums2 = [10,90,10]
> 输出：210
> 解释：选择 left = 1 和 right = 1 ，得到 nums1 = [60,90,60] 和 nums2 = [10,60,10] 。
> 分数为 max(sum(nums1), sum(nums2)) = max(210, 80) = 210 。
> 示例 2：
>
> 输入：nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]
> 输出：220
> 解释：选择 left = 3 和 right = 4 ，得到 nums1 = [20,40,20,40,20] 和 nums2 = [50,20,50,70,30] 。
> 分数为 max(sum(nums1), sum(nums2)) = max(140, 220) = 220 。
> 示例 3：
>
> 输入：nums1 = [7,11,13], nums2 = [1,1,1]
> 输出：31
> 解释：选择不交换任何子数组。
> 分数为 max(sum(nums1), sum(nums2)) = max(31, 3) = 31 。
>
> ![image-20220626215750177](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220626215750177.png)

```java
class Solution {
    public int maximumsSplicedArray(int[] nums1, int[] nums2) {
        return Math.max(solve(nums1,nums2),solve(nums2,nums1));
    }
    public int solve(int[] a,int[] b){
        int sum=0,max_temp=0,max_final_temp=0;
        for(int i=0;i<a.length;i++){
            sum+=a[i];
            max_temp=Math.max(max_temp+b[i]-a[i],0);
            max_final_temp=Math.max(max_final_temp,max_temp);
        }
        return sum+max_final_temp;
    }
}
```

1. 取最大连续子区间：

   ```java
   max_temp=Math.max(max_temp+b[i]-a[i],0);
   max_final_temp=Math.max(max_final_temp,max_temp);
   ```

   

# String

### [551. 学生出勤记录 I](https://leetcode.cn/problems/student-attendance-record-i/)

> 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
>
> 'A'：Absent，缺勤
> 'L'：Late，迟到
> 'P'：Present，到场
> 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
>
> 按 总出勤 计，学生缺勤（'A'）严格 少于两天。
> 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
> 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：s = "PPALLP"
> 输出：true
> 解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。
> 示例 2：
>
> 输入：s = "PPALLL"
> 输出：false
> 解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。
>
>
> 提示：
>
> 1 <= s.length <= 1000
> s[i] 为 'A'、'L' 或 'P'

```java
class Solution {
    public boolean checkRecord(String s) {
        int a=0,l=0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='A'){
                a++;
                l=0;
                if(a==2) return false;
            }else if(s.charAt(i)=='L'){
                l++;
                if(l==3) return false;
            }else{
                l=0;
            }
        }

        return true;
    }
}
```

**一行代码**

```java
class Solution {
    public boolean checkRecord(String s) {
        return s.indexOf('A')==s.lastIndexOf('A')&&!s.contains("LLL");
    }
}
```

1. 查询是否存在摸个字符串：s.contains("LLL")
2. 查询某个字符第一次出现的下标:s.indexOf('x')
3. 查询某个字符最后一次出现的下标：s.indexOf('X')

### [937. 重新排列日志文件](https://leetcode.cn/problems/reorder-data-in-log-files/)

> 给你一个日志数组 logs。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 标识符 。
>
> 有两种不同类型的日志：
>
> 字母日志：除标识符之外，所有字均由小写字母组成
> 数字日志：除标识符之外，所有字均由数字组成
> 请按下述规则将日志重新排序：
>
> 所有 字母日志 都排在 数字日志 之前。
> 字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。
> 数字日志 应该保留原来的相对顺序。
> 返回日志的最终顺序。
>
>  
>
> 示例 1：
>
> 输入：logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
> 输出：["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]
> 解释：
> 字母日志的内容都不同，所以顺序为 "art can", "art zero", "own kit dig" 。
> 数字日志保留原来的相对顺序 "dig1 8 1 5 1", "dig2 3 6" 。
> 示例 2：
>
> 输入：logs = ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
> 输出：["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
>
>
> 提示：
>
> 1 <= logs.length <= 100
> 3 <= logs[i].length <= 100
> logs[i] 中，字与字之间都用 单个 空格分隔
> 题目数据保证 logs[i] 都有一个标识符，并且在标识符之后至少存在一个字

```java
class Solution {
    public String[] reorderLogFiles(String[] logs) {
        List<String> ans=new ArrayList<>();
        for(String i:logs){
            int index=i.indexOf(' ')+1;
            if(i.charAt(index)>'9'){
                ans.add(i);
            }
        }
        Collections.sort(ans, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                if(o1.substring(o1.indexOf(' ')+1).equals(o2.substring(o2.indexOf(' ')+1))){
                    return o1.compareTo(o2);
                }else{
                    return o1.substring(o1.indexOf(' ')+1).compareTo(o2.substring(o2.indexOf(' ')+1));
                }
            }
        });

        for(String i:logs){
            int index=i.indexOf(' ')+1;
            if(i.charAt(index)>='0'&&i.charAt(index)<='9'){
                ans.add(i);
            }
        }

        return ans.toArray(new String[ans.size()]);
    }
}
```

1. 这题感觉就是掌握排序规则即可
2. 首先先将“**字母日志**”添加到集合中，然后按照“**字母日志** 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。”进行排序
3. 然后遍历数组将“**数字日志**”按照顺序添加进集合中去即可

### [824. 山羊拉丁文](https://leetcode.cn/problems/goat-latin/)

> 给你一个由若干单词组成的句子 sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。
>
> 请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。山羊拉丁文的规则如下：
>
> 如果单词以元音开头（'a', 'e', 'i', 'o', 'u'），在单词后添加"ma"。
> 例如，单词 "apple" 变为 "applema" 。
> 如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加"ma"。
> 例如，单词 "goat" 变为 "oatgma" 。
> 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从 1 开始。
> 例如，在第一个单词后添加 "a" ，在第二个单词后添加 "aa" ，以此类推。
> 返回将 sentence 转换为山羊拉丁文后的句子。
>
>  
>
> 示例 1：
>
> 输入：sentence = "I speak Goat Latin"
> 输出："Imaa peaksmaaa oatGmaaaa atinLmaaaaa"
> 示例 2：
>
> 输入：sentence = "The quick brown fox jumped over the lazy dog"
> 输出："heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"
>
>
> 提示：
>
> 1 <= sentence.length <= 150
> sentence 由英文字母和空格组成
> sentence 不含前导或尾随空格
> sentence 中的所有单词由单个空格分隔

```java
class Solution {
    public String toGoatLatin(String sentence) {
        String[] s=sentence.split(" ");
        HashSet<Character> h=new HashSet<>(Arrays.asList('A','E','I','O','U','a','e','i','o','u'));
        StringBuilder s1=new StringBuilder();
        StringBuilder ans=new StringBuilder();

        for(int i=0;i<s.length;i++){
            s1.append('a');
            StringBuilder temp=new StringBuilder(s[i]);
            if(h.contains(s[i].charAt(0))){
                temp.append("ma").append(s1);
            }else{
                char temp1=s[i].charAt(0);
                temp=new StringBuilder(temp.substring(1,s[i].length()));
                temp.append(temp1).append("ma").append(s1);
            }

            ans.append(temp).append(" ");
        }

        return ans.substring(0,ans.length()-1);
    }
}
```

1. 主要考察的字符串的拼接
2. set集合一次添加大量数据`HashSet<Character> h=new HashSet<>(Arrays.asList('A','E','I','O','U','a','e','i','o','u'));`
3. String转StringBuilder：new StringBuilder(String i)
4. StringBuilder转String:StringBuilder.toString();

### [415. 字符串相加](https://leetcode.cn/problems/add-strings/)

> 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。
>
> 你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。
>
>  
>
> 示例 1：
>
> 输入：num1 = "11", num2 = "123"
> 输出："134"
> 示例 2：
>
> 输入：num1 = "456", num2 = "77"
> 输出："533"
> 示例 3：
>
> 输入：num1 = "0", num2 = "0"
> 输出："0"
>
> ![image-20220602171920466](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220602171920466.png)

```java
class Solution {
    public String addStrings(String num1, String num2) {

        if(num1.length()<num2.length()){
            String temp=num1;
            num1=num2;
            num2=temp;
        }

        int m=num1.length(),n=num2.length();
        StringBuilder ans=new StringBuilder();
        int add=0;

        for(int i=0;i<n;i++){
            int tempa=num1.charAt(m-i-1)-'0';
            int tempb=num2.charAt(n-i-1)-'0';
            int num=(tempa+tempb+add)%10;
            ans.append(Integer.toString(num).charAt(0));
            add=(tempa+tempb+add)/10;
        }
        num1=num1.substring(0,m-n);
        for(int i=0;i<num1.length();i++){
            int temp=num1.charAt(num1.length()-i-1)-'0';
            int num=(temp+add)%10;
            ans.append(Integer.toString(num).charAt(0));
            add=(temp+add)/10;
        }
        if(add==1) ans.append('1');

        ans.reverse();

        return ans.toString();
    }
}
```

1. 将单个数字转成字符：`Integer.toString(num).charAt(0)`
2. 翻转字符串：ans.reverse()
3. 字符数组转字符串：`String newStr = new String(charArray, 0, charArray.length);`

**模拟**

```java
class Solution {
    public String addStrings(String num1, String num2) {
        int m=num1.length()-1,n=num2.length()-1,add=0;
        StringBuilder ans=new StringBuilder();
        while (m>=0||n>=0||add!=0){
            int a=m>=0 ? num1.charAt(m)-'0':0;
            int b=n>=0 ? num2.charAt(n)-'0':0;
            int num=a+b+add;
            ans.append(num%10);
            add=num/10;
            m--;
            n--;
        }

        ans.reverse();
        return ans.toString();
    }
}
```

### [443. 压缩字符串](https://leetcode.cn/problems/string-compression/)

> 给你一个字符数组 chars ，请使用下述算法压缩：
>
> 从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：
>
> 如果这一组长度为 1 ，则将字符追加到 s 中。
> 否则，需要向 s 追加字符，后跟这一组的长度。
> 压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。
>
> 请在 修改完输入数组后 ，返回该数组的新长度。
>
> 你必须设计并实现一个只使用常量额外空间的算法来解决此问题。
>
>  
>
> 示例 1：
>
> 输入：chars = ["a","a","b","b","c","c","c"]
> 输出：返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
> 解释："aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。
> 示例 2：
>
> 输入：chars = ["a"]
> 输出：返回 1 ，输入数组的前 1 个字符应该是：["a"]
> 解释：唯一的组是“a”，它保持未压缩，因为它是一个字符。
> 示例 3：
>
> 输入：chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
> 输出：返回 4 ，输入数组的前 4 个字符应该是：["a","b","1","2"]。
> 解释：由于字符 "a" 不重复，所以不会被压缩。"bbbbbbbbbbbb" 被 “b12” 替代。
>
>
> 提示：
>
> 1 <= chars.length <= 2000
> chars[i] 可以是小写英文字母、大写英文字母、数字或符号

```java
class Solution {
    public int compress(char[] chars) {
        int ans=0;
        if(chars.length==1) return 1;
        int l=0,r=1,count=1;
        while (r<=chars.length){
            if(r<chars.length&&chars[r]==chars[r-1]){
                count++;
                r++;
            }
            if(r==chars.length||chars[r]!=chars[r-1]){
                ans++;
                chars[l]=chars[r-1];
                if(count>1)ans+=Integer.toString(count).length();
                String temp=Integer.toString(count);
                for(int i=0;i<temp.length()&&count>1;i++){
                    chars[++l]=temp.charAt(i);
                }
                l++;
                r++;
                count=1;
            }
        }

        return ans;
    }
}
```

1.双指针

### [809. 情感丰富的文字](https://leetcode.cn/problems/expressive-words/)

> 有时候人们会用重复写一些字母来表示额外的感受，比如 "hello" -> "heeellooo", "hi" -> "hiii"。我们将相邻字母都相同的一串字符定义为相同字母组，例如："h", "eee", "ll", "ooo"。
>
> 对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。
>
> 例如，以 "hello" 为例，我们可以对字母组 "o" 扩张得到 "hellooo"，但是无法以同样的方法得到 "helloo" 因为字母组 "oo" 长度小于 3。此外，我们可以进行另一种扩张 "ll" -> "lllll" 以获得 "helllllooo"。如果 S = "helllllooo"，那么查询词 "hello" 是可扩张的，因为可以对它执行这两种扩张操作使得 query = "hello" -> "hellooo" -> "helllllooo" = S。
>
> 输入一组查询单词，输出其中可扩张的单词数量。
>
>  
>
> 示例：
>
> 输入： 
> S = "heeellooo"
> words = ["hello", "hi", "helo"]
> 输出：1
> 解释：
> 我们能通过扩张 "hello" 的 "e" 和 "o" 来得到 "heeellooo"。
> 我们不能通过扩张 "helo" 来得到 "heeellooo" 因为 "ll" 的长度小于 3 。
>
>
> 提示：
>
> 0 <= len(S) <= 100。
> 0 <= len(words) <= 100。
> 0 <= len(words[i]) <= 100。
> S 和所有在 words 中的单词都只由小写字母组成。

```java
class Solution {
    public int expressiveWords(String s, String[] words) {
        search a=new search(s);
        int ans=0;

        outer:for(String i:words){
            search b=new search(i);
            if(!a.key.equals(b.key)) continue ;
            for(int j=0;j<a.count.size();j++){
                int m=a.count.get(j);
                int n=b.count.get(j);
                if(m<3&&m!=n||m<n){
                    continue outer;
                }
            }
            ans++;
        }
        return ans;
    }
}
class search{
    public String key;
    public List<Integer> count;

    public search(String s){
        int pre=-1;
        StringBuilder s1=new StringBuilder();
        count=new ArrayList<>();
        for(int i=0;i<s.length();i++){
            if(i==s.length()-1||s.charAt(i)!=s.charAt(i+1)){
                s1.append(s.charAt(i));
                count.add(i-pre);
                pre=i;
            }
        }

        key=s1.toString();
    }
}
```

1. 遍历字符数组进行比较

### [848. 字母移位](https://leetcode.cn/problems/shifting-letters/)

> 有一个由小写字母组成的字符串 s，和一个长度相同的整数数组 shifts。
>
> 我们将字母表中的下一个字母称为原字母的 移位 shift() （由于字母表是环绕的， 'z' 将会变成 'a'）。
>
> 例如，shift('a') = 'b', shift('t') = 'u', 以及 shift('z') = 'a'。
> 对于每个 shifts[i] = x ， 我们会将 s 中的前 i + 1 个字母移位 x 次。
>
> 返回 将所有这些移位都应用到 s 后最终得到的字符串 。
>
>  
>
> 示例 1：
>
> 输入：s = "abc", shifts = [3,5,9]
> 输出："rpl"
> 解释： 
> 我们以 "abc" 开始。
> 将 S 中的第 1 个字母移位 3 次后，我们得到 "dbc"。
> 再将 S 中的前 2 个字母移位 5 次后，我们得到 "igc"。
> 最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 "rpl"。
> 示例 2:
>
> 输入: s = "aaa", shifts = [1,2,3]
> 输出: "gfd"
>
> ![image-20220604212822281](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220604212822281.png)

```java
class Solution {
    public String shiftingLetters(String s, int[] shifts) {
        StringBuilder ans=new StringBuilder();
        int sum=0;
        for(int i:shifts){
            sum+=i;
            sum%=26;
        }

        for(int i=0;i<s.length();i++){
            int num=s.charAt(i)-'a';
            ans.append((char) ((num+sum)%26+(int)'a'));
            sum=Math.floorMod(sum-shifts[i],26);
        }

        return ans.toString();
    }
}
```

1. ```tex
   a b c   1 2 3
   a移动6位
   b移动5位
   c移动3位
   。。。
   可以采用前缀和：
   a=a+6-0
   b=b+6-1
   c=c+6-2
   ```

2. Math.floorMod(x,y)

3. ![image-20220604213205667](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220604213205667.png)

### [1328. 破坏回文串](https://leetcode.cn/problems/break-a-palindrome/)

> 给你一个由小写英文字母组成的回文字符串 palindrome ，请你将其中 一个 字符用任意小写英文字母替换，使得结果字符串的 字典序最小 ，且 不是 回文串。
>
> 请你返回结果字符串。如果无法做到，则返回一个 空串 。
>
> 如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符严格小于 b 中的对应字符。例如，"abcc” 字典序比 "abcd" 小，因为不同的第一个位置是在第四个字符，显然 'c' 比 'd' 小。
>
>
> 示例 1：
>
> 输入：palindrome = "abccba"
> 输出："aaccba"
> 解释：存在多种方法可以使 "abccba" 不是回文，例如 "zbccba", "aaccba", 和 "abacba" 。
> 在所有方法中，"aaccba" 的字典序最小。
> 示例 2：
>
> 输入：palindrome = "a"
> 输出：""
> 解释：不存在替换一个字符使 "a" 变成非回文的方法，所以返回空字符串。
>
>
> 提示：
>
> 1 <= palindrome.length <= 1000
> palindrome 只包含小写英文字母。

```java
class Solution {
    public String breakPalindrome(String palindrome) {
        if(palindrome.length()==1) return "";

        char[] array=palindrome.toCharArray();
        int half_len=array.length/2;
        for(int i=0;i<half_len;i++){
            if(array[i]!='a'){
                array[i]='a';
                return new String(array);
            }
        }
        
        array[array.length-1]='b';
        return new String(array);
    }
}
```

1. 由于已经说明是回文字符串了，因此如果左边都是a【不能再变成a】的话，那么右边也就不能进行替换；
2. 因此只需将第一个非a字符替换成a，而这个替换发生在左边，如果该字符串是全a组成，那么只能将最后一个字符替换成b，总之尽可能的将非a替换成a
3. 字符串转换成字符数组：`char[] array=palindrome.toCharArray();`
4. 字符数组转换成字符串:`new String(array);`

# Linked List

### [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

> 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)
>
>
> 输入：head = [1,2,3,4,5], left = 2, right = 4
> 输出：[1,4,3,2,5]
> 示例 2：
>
> 输入：head = [5], left = 1, right = 1
> 输出：[5]
>
>
> 提示：
>
> 链表中节点数目为 n
> 1 <= n <= 500
> -500 <= Node.val <= 500
> 1 <= left <= right <= n

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ArrayList<Integer> list=new ArrayList<>();

        ListNode temp=head;
        while (temp!=null){
            list.add(temp.val);
            temp=temp.next;
        }

        Integer[] array=list.toArray(new Integer[list.size()]);
        int l=left-1,r=right-1,half_len=(l+r)/2;
        for(;l<=half_len;l++,r--){
            int a=array[l];
            array[l]=array[r];
            array[r]=a;
        }

        head=null;
        for (int i=array.length-1;i>=0;i--){
            head=new ListNode(array[i],head);
        }

        return head;
    }
}
```

1. 集合转换成数组时，集合中是对象，数组类型必须也是对象，但是没关系，因为我们可以将它作为基本数据类型进行处理，因为存在自动拆箱机制
2. 集合不能进行交换，但是数组可以，因此我们可以将集合转换成数组，然后反转后，再重新建立链表

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
>
>  
>
> 示例 1：
>
>
> 输入：head = [1,2,3,4]
> 输出：[2,1,4,3]
> 示例 2：
>
> 输入：head = []
> 输出：[]
> 示例 3：
>
> 输入：head = [1]
> 输出：[1]
>
>
> 提示：
>
> 链表中节点的数目在范围 [0, 100] 内
> 0 <= Node.val <= 100

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        List<Integer> list=new ArrayList<>();
        ListNode temp=head;
        while (temp!=null){
            list.add(temp.val);
            temp=temp.next;
        }

        if(list.size()==1) return new ListNode(list.get(0));

        int num=list.size()/2==0 ? list.size():list.size()-1;
        for(int i=0;i<num;i+=2){
            int a=list.get(i);
            list.set(i, list.get(i+1));
            list.set(i+1,a);
        }

        head=null;
        for(int i= list.size()-1;i>=0;i--){
            head=new ListNode(list.get(i),head);
        }

        return head;
    }
}
```

1. 修改集合中的元素：`list.set(int index,int num)`

**递归**

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null||head.next==null) return head;

        ListNode next=head.next;
        head.next=next.next;
        next.next=head;
        head.next=swapPairs(head.next);
        return next;
    }
}
```

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

> 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
>
> k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
>
> 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)
>
>
> 输入：head = [1,2,3,4,5], k = 2
> 输出：[2,1,4,3,5]
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)
>
> 输入：head = [1,2,3,4,5], k = 3
> 输出：[3,2,1,4,5]
>
> 提示：
> 链表中的节点数目为 n
> 1 <= k <= n <= 5000
> 0 <= Node.val <= 1000

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null||head.next==null) return head;
        ListNode first_head=head;
        ListNode first_tail=head;
        for(int i=0;i<k-1;i++){
            first_tail=first_tail.next;
            if(first_tail==null) return first_head;
        }
        ListNode second_head=first_tail.next;
        first_tail.next=null;

        reverse(first_head);
        first_head.next=reverseKGroup(second_head,k);
        return first_tail;
    }
    public ListNode reverse(ListNode head){
        if(head==null||head.next==null) return head;
        ListNode next=head.next;
        ListNode new_node=reverse(next);
        next.next=head;
        head.next=null;
        return new_node;
    }
}
```

**迭代**

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null||head.next==null) return head;
        ListNode first_head=head;
        ListNode first_tail=head;
        for(int i=0;i<k-1;i++){
            first_tail=first_tail.next;
            if(first_tail==null) return first_head;
        }
        ListNode second_head=first_tail.next;
        first_tail.next=null;
        reverse(first_head);
        first_head.next=reverseKGroup(second_head,k);
        return first_tail;
    }

    public ListNode reverse(ListNode head){
        ListNode pre=null;
        ListNode cur=head;
        while (cur!=null){
            ListNode temp=cur.next;
            cur.next=pre;
            pre=cur;
            cur=temp;
        }
        return pre;
    }
}
```



### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

> 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)
>
> 输入：head = [1,2,3,4,5]
> 输出：[5,4,3,2,1]
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)
>
>
> 输入：head = [1,2]
> 输出：[2,1]
> 示例 3：
>
> 输入：head = []
> 输出：[]
>
>
> 提示：
>
> 链表中节点的数目范围是 [0, 5000]
> -5000 <= Node.val <= 5000

**迭代法**

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        ListNode cur=head;
        while (cur!=null){
            ListNode temp=cur.next;
            cur.next=pre;
            pre=cur;
            cur=temp;
        }
        return pre;
    }
}
```

### [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

> 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)
>
> 输入：head = [1,2,3,3,4,4,5]
> 输出：[1,2,5]
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)
>
>
> 输入：head = [1,1,1,2,3]
> 输出：[2,3]
>
>
> 提示：
>
> 链表中节点数目在范围 [0, 300] 内
> -100 <= Node.val <= 100
> 题目数据保证链表已经按升序 排列

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null||head.next==null) return head;

        ListNode temp=new ListNode(0,head);

        ListNode cur=temp;
        while (cur.next!=null&&cur.next.next!=null){
            if(cur.next.val==cur.next.next.val){
                int x=cur.next.val;
                while (cur.next!=null&&cur.next.val==x){
                    cur.next=cur.next.next;
                }
            }else{
                cur=cur.next;
            }
        }

        return temp.next;
    }
}
```

1. 一次遍历
2. 有可能只有两个节点并且相等，因此我们可以采用一个哑节点先连接链表，然后逐个寻找不同的点
3. cur指针一定要先指向哑节点，因为cur下一个必须保证是不同节点

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

> 给你一个链表的头节点 head ，判断链表中是否有环。
>
> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
>
> 如果链表中存在环 ，则返回 true 。 否则，返回 false 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)
>
> 输入：head = [3,2,0,-4], pos = 1
> 输出：true
> 解释：链表中有一个环，其尾部连接到第二个节点。
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)
>
> 输入：head = [1,2], pos = 0
> 输出：true
> 解释：链表中有一个环，其尾部连接到第一个节点。
> 示例 3：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)
>
> 输入：head = [1], pos = -1
> 输出：false
> 解释：链表中没有环。
>
>
> 提示：
>
> 链表中节点的数目范围是 [0, 104]
> -105 <= Node.val <= 105
> pos 为 -1 或者链表中的一个 有效索引 。

```java
class Solution {
    public boolean hasCycle(ListNode head) {

        if(head==null||head.next==null) return false;

        ListNode l=head;
        ListNode r=head.next;
        while (l!=r){
            if(r.next==null||r.next.next==null) return false;
            l=l.next;
            r=r.next.next;
        }

        return true;
    }
}
```

1. 节点也是可以比较的，因为地址不同

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
>
> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
>
> 不允许修改 链表。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)
>
> 输入：head = [3,2,0,-4], pos = 1
> 输出：返回索引为 1 的链表节点
> 解释：链表中有一个环，其尾部连接到第二个节点。
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)
>
> 输入：head = [1,2], pos = 0
> 输出：返回索引为 0 的链表节点
> 解释：链表中有一个环，其尾部连接到第一个节点。
> 示例 3：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)
>
> 输入：head = [1], pos = -1
> 输出：返回 null
> 解释：链表中没有环。
>
>
> 提示：
>
> 链表中节点的数目范围在范围 [0, 104] 内
> -105 <= Node.val <= 105
> pos 的值为 -1 或者链表中的一个有效索引

**HashSet**

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        HashSet<ListNode> h=new HashSet<>();

        ListNode temp=head;
        while (temp!=null){
            if(h.contains(temp)) return temp;
            h.add(temp);
            temp=temp.next;
        }

        return null;
    }
}
```

**快慢指针**

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head==null||head.next==null) return null;

        ListNode l=head;
        ListNode r=head.next;
        while (l!=r){
            if(r==null||r.next==null) return null;
            l=l.next;
            r=r.next.next;
        }

        l=head;
        r=r.next;
        while (l!=r){
            l=l.next;
            r=r.next;
        }
        return l;
    }
}
```

### [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)

> 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。
>
>  
>
> 示例1：
>
> ![img](https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png)
>
> 输入：l1 = [7,2,4,3], l2 = [5,6,4]
> 输出：[7,8,0,7]
> 示例2：
>
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[8,0,7]
> 示例3：
>
> 输入：l1 = [0], l2 = [0]
> 输出：[0]
>
>
> 提示：
>
> 链表的长度范围为 [1, 100]
> 0 <= node.val <= 9
> 输入数据保证链表代表的数字无前导 0

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        l1=converse(l1);
        l2=converse(l2);

        int add=0;
        ListNode ans=null;
        while (l1!=null||l2!=null){
            int a= l1==null ? 0:l1.val;
            int b= l2==null ? 0:l2.val;
            int num=a+b;
            ans=new ListNode((num%10+add)%10,ans);
            add=(num+add)/10;
            if(l1!=null) l1=l1.next;
            if(l2!=null) l2=l2.next;
        }
        if(add>0) ans=new ListNode(add,ans);

        return ans;
    }

    public ListNode converse(ListNode l){
        ListNode pre=null,cur=l;
        while (cur!=null){
            ListNode temp=cur.next;
            cur.next=pre;
            pre=cur;
            cur=temp;
        }
        return pre;
    }
}
```

### [147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)

> 给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。
>
> 插入排序 算法的步骤:
>
> 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
> 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
> 重复直到所有输入数据插入完为止。
> 下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。
>
> 对链表进行插入排序。
>
> 
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg)
>
> 输入: head = [4,2,1,3]
> 输出: [1,2,3,4]
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg)
>
> 输入: head = [-1,5,3,4,0]
> 输出: [-1,0,3,4,5]
>
>
> 提示：
>
> 列表中的节点数在 [1, 5000]范围内
> -5000 <= Node.val <= 5000

```java
class Solution {
    public ListNode insertionSortList(ListNode head) {
        if(head==null||head.next==null) return head;

        ListNode dummy_head=new ListNode(0);
        dummy_head.next=head;
        ListNode last_tail=head;
        ListNode cur=head.next;

        while (cur!=null){
            if(last_tail.val<=cur.val){
                last_tail=cur;
                cur=last_tail.next;
            }else{
                ListNode pre=dummy_head;
                while (pre.next.val<=cur.val){
                    pre=pre.next;
                }
                last_tail.next=cur.next;
                cur.next=pre.next;
                pre.next=cur;

                cur=last_tail.next;
            }
        }

        return dummy_head.next;
    }
}
```

1. 快速排序：对前面已经排序好的部分寻找插入点

2. 哑元节点的设定使得元素可以插入在头节点的前面

3. 重要

   last_tail.next=cur.next;后面链表进行拼接

   cur.next=pre.next;防止丢失元素

   pre.next=cur;取代节点

### [725. 分隔链表](https://leetcode.cn/problems/split-linked-list-in-parts/)

> 给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。
>
> 每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。
>
> 这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。
>
> 返回一个由上述 k 部分组成的数组。
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg)
>
> 输入：head = [1,2,3], k = 5
> 输出：[[1],[2],[3],[],[]]
> 解释：
> 第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。
> 最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。
> 示例 2：
>
>
> 输入：head = [1,2,3,4,5,6,7,8,9,10], k = 3
> 输出：[[1,2,3,4],[5,6,7],[8,9,10]]
> 解释：
> 输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。
>
>
> 提示：
>
> 链表中节点的数目在范围 [0, 1000]
> 0 <= Node.val <= 1000
> 1 <= k <= 50

```java
class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        int size=0;
        ListNode temp=head;
        while (temp!=null){
            temp=temp.next;
            size++;
        }

        int num_a=size/k;
        int num_b=size%k;

        ListNode[] ans=new ListNode[k];
        ListNode cur=head;
        for(int i=0;i<k&&cur!=null;i++){
            ans[i]=cur;
            int part_size=num_a+(i<num_b ? 1:0);
            for(int j=1;j<part_size;j++){
                cur=cur.next;
            }
            ListNode next=cur.next;
            cur.next=null;
            cur=next;
        }

        return ans;
    }
}
```

1. 分割链表

   ```java
               ListNode next=cur.next;
               cur.next=null;
               cur=next;
   ```

2. n个节点，移动n-1次

### [1466. 重新规划路线](https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/)

> n 座城市，从 0 到 n-1 编号，其间共有 n-1 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。
>
> 路线用 connections 表示，其中 connections[i] = [a, b] 表示从城市 a 到 b 的一条有向路线。
>
> 今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。
>
> 请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。
>
> 题目数据 保证 每个城市在重新规划路线方向后都能到达城市 0 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1819.png)
>
> 输入：n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
> 输出：3
> 解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1819.png)
>
> 输入：n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
> 输出：2
> 解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。
> 示例 3：
>
> 输入：n = 3, connections = [[1,0],[2,0]]
> 输出：0
>
>
> 提示：
>
> 2 <= n <= 5 * 10^4
> connections.length == n-1
> connections[i].length == 2
> 0 <= connections[i][0], connections[i][1] <= n-1
> connections[i][0] != connections[i][1]

```java
class Solution {
    public int minReorder(int n, int[][] connections) {
        HashMap<Integer,HashSet<Integer>> h=new HashMap<>();
        for(int[] i:connections){
            HashSet<Integer> h1=h.containsKey(i[0]) ? h.get(i[0]):new HashSet<>();
            h1.add(i[1]);
            h.put(i[0],h1);
            HashSet<Integer> h2=h.containsKey(i[1]) ? h.get(i[1]):new HashSet<>();
            h2.add(i[0]*-1);
            h.put(i[1],h2);
        }
        return bfs(h,n);
    }

    public int bfs(HashMap<Integer,HashSet<Integer>> h,int n){
        boolean[] flag=new boolean[n];
        LinkedList<Integer> queue=new LinkedList<>();
        int ans=0;
        queue.offerLast(0);
        flag[0]=true;
        while (!queue.isEmpty()){
            for(Integer i:h.get(queue.pollFirst())){
                if(flag[Math.abs(i)]) continue;
                if(i>0) ans++;
                flag[Math.abs(i)]=true;
                queue.offerLast(Math.abs(i));
            }
        }
        return ans;
    }
}
```

第一步：构造图

索引为节点出发点序号，值为出发点所能到达的节点序号

第二步：查找

由于判断的都是相邻点，如果相邻点都过不去，更别提外边的了；由于1-2|2-1只能存在1中结果，要么是正要么是负，如果为正说明到达不了0点

注意：

这个题只有n-1条连线，说明如果一个点到另一个点之间的值为负数，说明只能进行反转，否则无法出去

### [2295. 替换数组中的元素](https://leetcode.cn/problems/replace-elements-in-an-array/)

> 给你一个下标从 0 开始的数组 nums ，它包含 n 个 互不相同 的正整数。请你对这个数组执行 m 个操作，在第 i 个操作中，你需要将数字 operations[i][0] 替换成 operations[i][1] 。
>
> 题目保证在第 i 个操作中：
>
> operations[i][0] 在 nums 中存在。
> operations[i][1] 在 nums 中不存在。
> 请你返回执行完所有操作后的数组。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]
> 输出：[3,2,7,1]
> 解释：我们对 nums 执行以下操作：
> - 将数字 1 替换为 3 。nums 变为 [3,2,4,6] 。
> - 将数字 4 替换为 7 。nums 变为 [3,2,7,6] 。
> - 将数字 6 替换为 1 。nums 变为 [3,2,7,1] 。
> 返回最终数组 [3,2,7,1] 。
> 示例 2：
>
> 输入：nums = [1,2], operations = [[1,3],[2,1],[3,2]]
> 输出：[2,1]
> 解释：我们对 nums 执行以下操作：
> - 将数字 1 替换为 3 。nums 变为 [3,2] 。
> - 将数字 2 替换为 1 。nums 变为 [3,1] 。
> - 将数字 3 替换为 2 。nums 变为 [2,1] 。
> 返回最终数组 [2,1] 。
>
>
> 提示：
>
> n == nums.length
> m == operations.length
> 1 <= n, m <= 105
> nums 中所有数字 互不相同 。
> operations[i].length == 2
> 1 <= nums[i], operations[i][0], operations[i][1] <= 106
> 在执行第 i 个操作时，operations[i][0] 在 nums 中存在。
> 在执行第 i 个操作时，operations[i][1] 在 nums 中不存在。

```java
class Solution {
    public int[] arrayChange(int[] nums, int[][] operations) {
        HashMap<Integer,Integer> h=new HashMap<>();
        for(int i=0;i<nums.length;i++) h.put(nums[i],i);
        for(int[] i:operations){
            if(h.containsKey(i[0])&&!h.containsKey(i[1])){
                int index=h.get(i[0]);
                nums[index]=i[1];
                h.remove(i[0]);
                h.put(i[1],index);
            }
        }
        return nums;
    }
}
```

# 队列

### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
>
> 实现 MyStack 类：
>
> void push(int x) 将元素 x 压入栈顶。
> int pop() 移除并返回栈顶元素。
> int top() 返回栈顶元素。
> boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
>
>
> 注意：
>
> 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
> 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
>
>
> 示例：
>
> 输入：
> ["MyStack", "push", "push", "top", "pop", "empty"]
> [[], [1], [2], [], [], []]
> 输出：
> [null, null, null, 2, 2, false]
>
> 解释：
> MyStack myStack = new MyStack();
> myStack.push(1);
> myStack.push(2);
> myStack.top(); // 返回 2
> myStack.pop(); // 返回 2
> myStack.empty(); // 返回 False
>
>
> 提示：
>
> 1 <= x <= 9
> 最多调用100 次 push、pop、top 和 empty
> 每次调用 pop 和 top 都保证栈不为空
>
>
> 进阶：你能否仅用一个队列来实现栈。
>

```java
class MyStack {
    Queue<Integer> q;
    int top_num;
    public MyStack() {
        q=new LinkedList<>();
        top_num=0;
    }

    public void push(int x) {
        q.offer(x);
        top_num=x;
    }

    public int pop() {
        int size= q.size();
        while (size>2){
            q.offer(q.poll());
            size--;
        }
        top_num=q.peek();
        q.offer(q.poll());
        return q.poll();
    }

    public int top() {
        return top_num;
    }

    public boolean empty() {
        return q.isEmpty();
    }
}
```

### [622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)

> 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。
>
> 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
>
> 你的实现应该支持如下操作：
>
> MyCircularQueue(k): 构造器，设置队列长度为 k 。
> Front: 从队首获取元素。如果队列为空，返回 -1 。
> Rear: 获取队尾元素。如果队列为空，返回 -1 。
> enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
> deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
> isEmpty(): 检查循环队列是否为空。
> isFull(): 检查循环队列是否已满。
>
>
> 示例：
>
> MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
> circularQueue.enQueue(1);  // 返回 true
> circularQueue.enQueue(2);  // 返回 true
> circularQueue.enQueue(3);  // 返回 true
> circularQueue.enQueue(4);  // 返回 false，队列已满
> circularQueue.Rear();  // 返回 3
> circularQueue.isFull();  // 返回 true
> circularQueue.deQueue();  // 返回 true
> circularQueue.enQueue(4);  // 返回 true
> circularQueue.Rear();  // 返回 4
>
>
> 提示：
>
> 所有的值都在 0 至 1000 的范围内；
> 操作数将在 1 至 1000 的范围内；
> 请不要使用内置的队列库。

**数组**

```java
class MyCircularQueue {
    int[] array;
    int head=0;
    int tail=-1;
    int size=0;

    public MyCircularQueue(int k) {
        array=new int[k];
    }

    public boolean enQueue(int value) {
        if(isFull()) return false;
        tail=(tail+1)%array.length;
        array[tail]=value;
        size++;
        return true;
    }

    public boolean deQueue() {
        if(isEmpty()) return false;
        head=(head+1)%array.length;
        size--;
        return true;
    }

    public int Front() {
        return isEmpty() ? -1:array[head];
    }

    public int Rear() {
        return isEmpty() ? -1:array[tail];
    }

    public boolean isEmpty() {
        return size==0;
    }

    public boolean isFull() {
        return size==array.length;
    }
}
```

**集合**

```java
class MyCircularQueue {

    List<Integer> l;
    int capity;

    public MyCircularQueue(int k) {
        l=new LinkedList<>();
        capity=k;
    }

    public boolean enQueue(int value) {
        if(isFull()) return false;
        l.add(value);
        return true;
    }

    public boolean deQueue() {
        if(isEmpty()) return false;
        l.remove(0);
        return true;
    }

    public int Front() {
        return isEmpty() ? -1:l.get(0);
    }

    public int Rear() {
        return isEmpty() ? -1:l.get(l.size()-1);
    }

    public boolean isEmpty() {
        return l.size()==0;
    }

    public boolean isFull() {
        return l.size()==capity;
    }
}
```

1. 对于链表集合能够实现删除第一个元素后，下一个元素的下标值自动成为1
2. 区间大小：capity

### [498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/)

> 给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)
>
>
> 输入：mat = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[1,2,4,7,5,3,6,8,9]
> 示例 2：
>
> 输入：mat = [[1,2],[3,4]]
> 输出：[1,2,3,4]
>
> ![image-20220610235617115](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220610235617115.png)

```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        if(mat.length==0||mat[0].length==0) return new int[0];
        int m=mat.length,n=mat[0].length;
        int	[] ans=new int[m*n];
        for(int i=0,index=0;i<m+n-1;i++){
            if(i%2==0){
                for(int x=Math.min(i,m-1);x>=Math.max(0,i-n+1);x--){
                    ans[index++]=mat[x][i-x];
                }
            }else{
                for(int x=Math.max(0,i-n+1);x<=Math.min(i,m-1);x++){
                    ans[index++]=mat[x][i-x];
                }
            }
        }
        
        return ans;
    }
}
```

### [778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/)

> 在一个 n x n 的整数矩阵 grid 中，每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。
>
> 当开始下雨时，在时间为 t 时，水池中的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。
>
> 你从坐标方格的左上平台 (0，0) 出发。返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间 。
>
>  
>
> 示例 1:
>
> ![img](https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg)
>
> 输入: grid = [[0,2],[1,3]]
> 输出: 3
> 解释:
> 时间为0时，你位于坐标方格的位置为 (0, 0)。
> 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。
> 等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置
> 示例 2:
>
> ![img](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)
>
> 输入: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
> 输出: 16
> 解释: 最终的路线用加粗进行了标记。
> 我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的
>
>
> 提示:
>
> n == grid.length
> n == grid[i].length
> 1 <= n <= 50
> 0 <= grid[i][j] < n^2
> grid[i][j] 中每个值 均无重复

```java
class Solution {
    int[] dx = new int[]{0, 1, 0, -1};
    int[] dy = new int[]{1, 0, -1, 0};

    public class node {
        int x, y, h;

        public node(int x, int y, int h) {
            this.x = x;
            this.y = y;
            this.h = h;
        }
    }

    public int swimInWater(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        boolean[][] flag = new boolean[m][n];
        PriorityQueue<node> priorityQueue = new PriorityQueue<>(new Comparator<node>() {
            @Override
            public int compare(node o1, node o2) {
                return o1.h - o2.h;
            }
        });

        priorityQueue.offer(new node(0, 0, grid[0][0]));
        flag[0][0]=true;
        int ans = 0;
        while (!priorityQueue.isEmpty()) {
            node node = priorityQueue.poll();

            //if (flag[node.x][node.y]) continue;

            ans = Math.max(ans, node.h);

            if (node.x == m - 1 && node.y == n - 1) return ans;
            for (int i = 0; i < 4; i++) {
                int x = node.x + dx[i];
                int y = node.y + dy[i];
                if (x >= 0 && x < m && y >= 0 && y < n && flag[x][y] == false) {
                    flag[x][y]=true;
                    priorityQueue.offer(new node(x, y, grid[x][y]));
                }
            }
        }

        return ans;
    }
}
```

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

> 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
>
> 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
>
>  
>
> 示例 1:
>
> 输入: [3,2,1,5,6,4], k = 2
> 输出: 5
> 示例 2:
>
> 输入: [3,2,3,1,2,4,5,5,6], k = 4
> 输出: 4
>
>
> 提示：
>
> 1 <= k <= nums.length <= 10^4
> -104 <= nums[i] <= 10^4

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> priorityQueue=new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        });
        for(int i:nums) priorityQueue.offer(i);

        for(int i=1;i<k;i++) priorityQueue.poll();

        return priorityQueue.poll();
    }
}
```



# 栈

1. 栈的最主要特点是后进先出。栈是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表。栈的所有插入和删除操作均在栈顶进行，而栈底不允许插入和删除。
2. 首节点是栈底

### [1249. 移除无效的括号](https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/)

> 给你一个由 '('、')' 和小写字母组成的字符串 s。
>
> 你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。
>
> 请返回任意一个合法字符串。
>
> 有效「括号字符串」应当符合以下 任意一条 要求：
>
> 空字符串或只包含小写字母的字符串
> 可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
> 可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」
>
>
> 示例 1：
>
> 输入：s = "lee(t(c)o)de)"
> 输出："lee(t(c)o)de"
> 解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。
> 示例 2：
>
> 输入：s = "a)b(c)d"
> 输出："ab(c)d"
> 示例 3：
>
> 输入：s = "))(("
> 输出：""
> 解释：空字符串也是有效的
>
> ![image-20220611211333344](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220611211333344.png)

```java
class Solution {
    public String minRemoveToMakeValid(String s) {
        StringBuilder ans=new StringBuilder();

        Stack<Integer> s1=new Stack<>();
        HashSet<Integer> h1=new HashSet<>();
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='(') s1.push(i);
            if(s.charAt(i)==')'){
                if(s1.isEmpty()) h1.add(i);
                else s1.pop();
            }
        }

        while (!s1.isEmpty()){
            h1.add(s1.pop());
        }
        
        for(int i=0;i<s.length();i++){
            if(h1.contains(i)) continue;
            else ans.append(s.charAt(i));
        }

        return ans.toString();
    }
}
```

### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

> nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。
>
> 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。
>
> 对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。
>
> 返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。
>
>  
>
> 示例 1：
>
> 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
> 输出：[-1,3,-1]
> 解释：nums1 中每个值的下一个更大元素如下所述：
> - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
> - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
> - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
> 示例 2：
>
> 输入：nums1 = [2,4], nums2 = [1,2,3,4].
> 输出：[3,-1]
> 解释：nums1 中每个值的下一个更大元素如下所述：
> - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
> - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
>
> ![image-20220611220218934](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220611220218934.png)

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        HashMap<Integer,Integer> h=new HashMap<>();
        for(int i=0;i<nums2.length;i++) h.put(nums2[i],i);
        int temp=-1;
        for(int i:nums1){
            int index=h.get(i);
            if(index==nums2.length) {
                nums1[++temp]=-1;
                continue;
            }
            index++;
            while (index<nums2.length){
                if(nums2[index]>i) {
                    nums1[++temp]=nums2[index];
                    break;
                }
                index++;
            }
            if(index==nums2.length) nums1[++temp]=-1;
        }
        return nums1;
    }
}
```

**单调栈**

![image-20220612091249190](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220612091249190.png)

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int n=nums1.length;
        Stack<Integer> s=new Stack<>();
        HashMap<Integer,Integer> h=new HashMap<>();

        for(int i=nums2.length-1;i>=0;i--){
            while (!s.isEmpty()&&nums2[i]>=s.peek()){
                s.pop();
            }
            h.put(nums2[i],s.isEmpty() ? -1:s.peek());
            s.push(nums2[i]);
        }

        for(int i=0;i<nums1.length;i++){
            nums1[i]=h.get(nums1[i]);
        }
        return nums1;
    }
}
```

### [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

> 给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。
>
> 数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。
>
>  
>
> 示例 1:
>
> 输入: nums = [1,2,1]
> 输出: [2,-1,2]
> 解释: 第一个 1 的下一个更大的数是 2；
> 数字 2 找不到下一个更大的数； 
> 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
> 示例 2:
>
> 输入: nums = [1,2,3,4,3]
> 输出: [2,3,4,-1,4]
>
> ![image-20220612204452679](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220612204452679.png)

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n=nums.length;
        int[] ans=new int[n];
        Arrays.fill(ans,-1);
        Stack<Integer> s=new Stack<>();
        for(int i=0;i<n*2-1;i++){
            while (!s.isEmpty()&&nums[i%n]>nums[s.peek()]){
                ans[s.pop()]=nums[i%n];
            }
            s.push(i%n);
        }

        return ans;
    }
}
```

### [886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/)

> 给定一组 n 人（编号为 1, 2, ..., n）， 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。
>
> 给定整数 n 和数组 dislikes ，其中 dislikes[i] = [ai, bi] ，表示不允许将编号为 ai 和  bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。
>
>  
>
> 示例 1：
>
> 输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]
> 输出：true
> 解释：group1 [1,4], group2 [2,3]
> 示例 2：
>
> 输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]
> 输出：false
> 示例 3：
>
> 输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
> 输出：false
>
> ![image-20220612214805494](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220612214805494.png)

```java
class Solution {
    boolean visited[];
    boolean color[];
    boolean flag=true;
    public boolean possibleBipartition(int n, int[][] dislikes) {
        visited=new boolean[n+1];
        color=new boolean[n+1];
        List<Integer>[] graph=new ArrayList[n+1];

        for(int i=1;i<=n;i++){
            graph[i]=new ArrayList<>();
        }

        for(int[] i:dislikes){
            graph[i[0]].add(i[1]);
            graph[i[1]].add(i[0]);
        }

        for(int i=1;i<=n;i++){
            if(!visited[i]){
                find(graph,i);
            }
        }

        return flag;
    }

    public void find(List<Integer>[] graph,int i){
        Queue<Integer> q=new LinkedList<>();
        visited[i]=true;
        q.offer(i);
        while (!q.isEmpty()){
            int cur=q.poll();
            for(int j:graph[cur]){
                if(!visited[j]){
                    color[j]=!color[cur];
                    visited[j]=true;
                    q.offer(j);
                }else{
                    if(color[j]==color[cur]){
                        flag=false;
                        return;
                    }
                }
            }
        }
    }
}
```

### [1021. 删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/)

>有效括号字符串为空 ""、"(" + A + ")" 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。
>
>例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。
>如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。
>
>给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。
>
>对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。
>
> 
>
>示例 1：
>
>输入：s = "(()())(())"
>输出："()()()"
>解释：
>输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
>删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
>示例 2：
>
>输入：s = "(()())(())(()(()))"
>输出："()()()()(())"
>解释：
>输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
>删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
>示例 3：
>
>输入：s = "()()"
>输出：""
>解释：
>输入字符串为 "()()"，原语化分解得到 "()" + "()"，
>删除每个部分中的最外层括号后得到 "" + "" = ""。
>
>
>提示：
>
>1 <= s.length <= 105
>s[i] 为 '(' 或 ')'
>s 是一个有效括号字符串

```java
class Solution {
    public String removeOuterParentheses(String s) {
        Stack<Character> s1=new Stack<>();
        StringBuilder s2=new StringBuilder();

        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('){
                s1.push('(');
            }
            if(s1.size()>1)s2.append(s.charAt(i));
            if(s.charAt(i)==')'){
                s1.pop();
            }
        }

        return s2.toString();
    }
}
```

1. 如果长度为1，不进行拼接：保证了第一份`()`不会被拼接

### [173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/)

> 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
> BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
> boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。
> int next()将指针向右移动，然后返回指针处的数字。
> 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
>
> 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。
>
>  
>
> 示例：
>
>
> 输入
> ["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
> [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
> 输出
> [null, 3, 7, true, 9, true, 15, true, 20, false]
>
> 解释
> BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
> bSTIterator.next();    // 返回 3
> bSTIterator.next();    // 返回 7
> bSTIterator.hasNext(); // 返回 True
> bSTIterator.next();    // 返回 9
> bSTIterator.hasNext(); // 返回 True
> bSTIterator.next();    // 返回 15
> bSTIterator.hasNext(); // 返回 True
> bSTIterator.next();    // 返回 20
> bSTIterator.hasNext(); // 返回 False
>

```java
class BSTIterator {

    Stack<Integer> s=new Stack<>();
    int i=0;

    public BSTIterator(TreeNode root) {
        dfs(root);
    }

    public void dfs(TreeNode root){
        if(root==null) return;
        dfs(root.right);
        s.add(root.val);
        dfs(root.left);
    }

    public int next() {
        return s.pop();
    }

    public boolean hasNext() {
        return s.size()!=0;
    }
}
```

### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

> 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
>
>  
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/yzk_image/raw/master/img/spiraln.jpg)
>
>
> 输入：n = 3
> 输出：[[1,2,3],[8,9,4],[7,6,5]]
> 示例 2：
>
> 输入：n = 1
> 输出：[[1]]
>
>
> 提示：
>
> 1 <= n <= 20

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int x_l=0,x_r=n-1;
        int y_l=0,y_r=n-1;

        int[][] ans=new int[n][n];
        int temp=1;
        while (temp<=n*n){
            for(int i=x_l;i<=x_r;i++){
                ans[y_l][i]=temp++;
            }
            if(++y_l>y_r) break;

            for(int i=y_l;i<=y_r;i++){
                ans[i][x_r]=temp++;
            }
            if(--x_r<x_l) break;

            for(int i=x_r;i>=x_l;i--){
                ans[y_r][i]=temp++;
            }
            if(--y_r<y_l) break;

            for(int i=y_r;i>=y_l;i--){
                ans[i][x_l]=temp++;
            }
            if(++x_l>x_r) break;
        }
        
        return ans;
    }
}
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

> 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
>
>  
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/yzk_image/raw/master/img/spiral1.jpg)
>
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[1,2,3,6,9,8,7,4,5]
> 示例 2：
>
> ![img](https://gitee.com/demon_night/yzk_image/raw/master/img/spiral.jpg)
>
>
> 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
> 输出：[1,2,3,4,8,12,11,10,9,5,6,7]
>
>
> 提示：
>
> m == matrix.length
> n == matrix[i].length
> 1 <= m, n <= 10
> -100 <= matrix[i][j] <= 100
>

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int x_l=0,x_r=matrix[0].length-1;
        int y_l=0,y_r=matrix.length-1;

        List<Integer> ans=new ArrayList<>();
        int temp=1;
        while (true){
            for(int i=x_l;i<=x_r;i++){
                ans.add(matrix[y_l][i]);
            }
            if(++y_l>y_r) break;

            for(int i=y_l;i<=y_r;i++){
                ans.add(matrix[i][x_r]);
            }
            if(--x_r<x_l) break;

            for(int i=x_r;i>=x_l;i--){
                ans.add(matrix[y_r][i]);
            }
            if(--y_r<y_l) break;

            for(int i=y_r;i>=y_l;i--){
                ans.add(matrix[i][x_l]);
            }
            if(++x_l>x_r) break;
        }

        return ans;
    }
}
```

### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
>
> 实现 MyQueue 类：
>
> void push(int x) 将元素 x 推到队列的末尾
> int pop() 从队列的开头移除并返回元素
> int peek() 返回队列开头的元素
> boolean empty() 如果队列为空，返回 true ；否则，返回 false
> 说明：
>
> 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
> 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
>
>
> 示例 1：
>
> 输入：
> ["MyQueue", "push", "push", "peek", "pop", "empty"]
> [[], [1], [2], [], [], []]
> 输出：
> [null, null, null, 1, 1, false]
>
> 解释：
> MyQueue myQueue = new MyQueue();
> myQueue.push(1); // queue is: [1]
> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
> myQueue.peek(); // return 1
> myQueue.pop(); // return 1, queue is [2]
> myQueue.empty(); // return false
>
>
> 提示：
>
> 1 <= x <= 9
> 最多调用 100 次 push、pop、peek 和 empty
> 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）
>
>
> 进阶：
>
> 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。
>

```java
class MyQueue {

    Stack<Integer> s1,s2;

    public MyQueue() {
        s1=new Stack<>();
        s2=new Stack<>();
    }

    public void reverse(){
        while (s2.isEmpty()){
            while (!s1.isEmpty()){
                s2.push(s1.pop());   
            }
        }
    }

    public void push(int x) {
        s1.push(x);
    }

    public int pop() {
        reverse();
        return s2.pop();
    }

    public int peek() {
        reverse();
        return s2.peek();
    }

    public boolean empty() {
        return s2.size()==0&&s1.size()==0;
    }
}
```

1. reverse:保证输出队列不为空即还没有使用
2. 栈反转后就是队列
3. 由于可能会发生不反转情况，因此判断empty时，要验证s1、s2是否都为空
4. 栈的最主要特点是后进先出。栈是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表。栈的所有插入和删除操作均在栈顶进行，而栈底不允许插入和删除。

### [682. 棒球比赛](https://leetcode.cn/problems/baseball-game/)

> 你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。
>
> 比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：
>
> 整数 x - 表示本回合新获得分数 x
> "+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
> "D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
> "C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。
> 请你返回记录中所有得分的总和。
>
>  
>
> 示例 1：
>
> 输入：ops = ["5","2","C","D","+"]
> 输出：30
> 解释：
> "5" - 记录加 5 ，记录现在是 [5]
> "2" - 记录加 2 ，记录现在是 [5, 2]
> "C" - 使前一次得分的记录无效并将其移除，记录现在是 [5].
> "D" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].
> "+" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].
> 所有得分的总和 5 + 10 + 15 = 30
> 示例 2：
>
> 输入：ops = ["5","-2","4","C","D","9","+","+"]
> 输出：27
> 解释：
> "5" - 记录加 5 ，记录现在是 [5]
> "-2" - 记录加 -2 ，记录现在是 [5, -2]
> "4" - 记录加 4 ，记录现在是 [5, -2, 4]
> "C" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]
> "D" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]
> "9" - 记录加 9 ，记录现在是 [5, -2, -4, 9]
> "+" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]
> "+" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]
> 所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27
> 示例 3：
>
> 输入：ops = ["1"]
> 输出：1
>
>
> 提示：
>
> 1 <= ops.length <= 1000
> ops[i] 为 "C"、"D"、"+"，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]
> 对于 "+" 操作，题目数据保证记录此操作时前面总是存在两个有效的分数
> 对于 "C" 和 "D" 操作，题目数据保证记录此操作时前面总是存在一个有效的分数

```java
class Solution {
    public int calPoints(String[] ops) {
        Stack<Integer> s=new Stack<>();

        for(String i:ops){
            if(i.equals("C")) s.pop();
            else if(i.equals("D")) {
                int num=s.peek()*2;
                s.push(num);
            }else if(i.equals("+")){
                int next=s.pop();
                int pre=s.peek();
                s.push(next);

                int num=next+pre;
                s.push(num);
            }else{
                int num=Integer.parseInt(i);
                s.push(num);   
            }
        }

        int sum=0;
        while (!s.isEmpty()) sum+=s.pop();

        return sum;
    }
}
```

### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

> 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。
>
>  
>
> 示例 1:
>
> 输入: temperatures = [73,74,75,71,69,72,76,73]
> 输出: [1,1,4,2,1,1,0,0]
> 示例 2:
>
> 输入: temperatures = [30,40,50,60]
> 输出: [1,1,1,0]
> 示例 3:
>
> 输入: temperatures = [30,60,90]
> 输出: [1,1,0]
>
> ![image-20220618231246498](https://gitee.com/demon_night/yzk_image/raw/master/img/image-20220618231246498.png)

**单调栈**

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> s=new Stack<>();
        int n=temperatures.length;
        int[] ans=new int[n];

        for(int i=0;i<n;i++){
            while (!s.isEmpty()&&temperatures[i]>temperatures[s.peek()]){
                ans[s.peek()]=i-s.pop();
            }
            s.push(i);
        }

        return ans;
    }
}
```

### [636. 函数的独占时间](https://leetcode.cn/problems/exclusive-time-of-functions/)

> 有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于  0 和 n-1 之间的唯一标识符。
>
> 函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。
>
> 给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 "{function_id}:{"start" | "end"}:{timestamp}" 进行格式化的字符串。例如，"0:start:3" 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 "1:end:2" 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。
>
> 函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。
>
> 以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/yzk_image/raw/master/img/diag1b.png)
>
>
> 输入：n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
> 输出：[3,4]
> 解释：
> 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 
> 函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 
> 函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 
> 所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 
> 示例 2：
>
> 输入：n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]
> 输出：[8]
> 解释：
> 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
> 函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
> 函数 0（初始调用）恢复执行，并立刻再次调用它自身。
> 函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。
> 函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。
> 所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。
> 示例 3：
>
> 输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]
> 输出：[7,1]
> 解释：
> 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
> 函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
> 函数 0（初始调用）恢复执行，并立刻调用函数 1 。
> 函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。
> 函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。
> 所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 
> 示例 4：
>
> 输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:7","1:end:7","0:end:8"]
> 输出：[8,1]
> 示例 5：
>
> 输入：n = 1, logs = ["0:start:0","0:end:0"]
> 输出：[1]
>
> ![image-20220619222733383](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220619222733383.png)

```java
class Solution {
    public int[] exclusiveTime(int n, List<String> logs) {
        Stack<Integer> s=new Stack<>();
        int[] ans=new int[n];
        String[] s1=logs.get(0).split(":");
        s.push(Integer.parseInt(s1[0]));
        int i=1,pre=Integer.parseInt(s1[2]);
        while (i<logs.size()){
            s1=logs.get(i).split(":");
            if(s1[1].equals("start")){
                if(!s.isEmpty()){
                    ans[s.peek()]+=Integer.parseInt(s1[2])-pre;
                }
                s.push(Integer.parseInt(s1[0]));
                pre=Integer.parseInt(s1[2]);
            }else{
                ans[s.peek()]+=Integer.parseInt(s1[2])-pre+1;
                s.pop();
                pre=Integer.parseInt(s1[2])+1;
            }
            i++;
        }
        
        return ans;
    }
}
```

**错误记录**

我一直想着去减中间的几个去求外层集合的大小，没想到可以直接直接加上外层集合的部分集合

### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

> 根据 逆波兰表示法，求表达式的值。
>
> 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
>
> 注意 两个整数之间的除法只保留整数部分。
>
> 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
>
>  
>
> 示例 1：
>
> 输入：tokens = ["2","1","+","3","*"]
> 输出：9
> 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
> 示例 2：
>
> 输入：tokens = ["4","13","5","/","+"]
> 输出：6
> 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
> 示例 3：
>
> 输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
> 输出：22
> 解释：该算式转化为常见的中缀算术表达式为：
>   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
> = ((10 * (6 / (12 * -11))) + 17) + 5
> = ((10 * (6 / -132)) + 17) + 5
> = ((10 * 0) + 17) + 5
> = (0 + 17) + 5
> = 17 + 5
> = 22
>
> ![image-20220702174709472](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220702174709472.png)

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> s=new Stack<>();
        for(String i:tokens){
            if("+-*/".contains(i)){
                int a=s.pop(),b=s.pop();
                switch (i){
                    case "+":
                        s.push(b+a);
                        break;
                    case "-":
                        s.push(b-a);
                        break;
                    case "*":
                        s.push(b*a);
                        break;
                    case "/":
                        s.push(b/a);
                        break;
                }
            }else{
                s.push(Integer.parseInt(i));
            }
        }

        return s.pop();
    }
}
```

### [735. 行星碰撞](https://leetcode.cn/problems/asteroid-collision/)

> 给定一个整数数组 asteroids，表示在同一行的行星。
>
> 对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。
>
> 找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。
>
>  
>
> 示例 1：
>
> 输入：asteroids = [5,10,-5]
> 输出：[5,10]
> 解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。
> 示例 2：
>
> 输入：asteroids = [8,-8]
> 输出：[]
> 解释：8 和 -8 碰撞后，两者都发生爆炸。
> 示例 3：
>
> 输入：asteroids = [10,2,-5]
> 输出：[10]
> 解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。
>
> ![image-20220703233955659](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220703233955659.png)

```java
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> s=new Stack<>();
        for(int i:asteroids){
            outer:
            {
                while (!s.isEmpty() && i < 0 && s.peek() > 0) {
                    if (s.peek() < -i) {
                        s.pop();
                        continue;
                    } else if (-i== s.peek()) {
                        s.pop();
                    }
                    break outer;
                }
                s.push(i);
            }
        }

        int[] ans=new int[s.size()];
        int temp=s.size();
        while (!s.isEmpty()){
            ans[--temp]=s.pop();
        }

        return ans;
    }
}
```

**主要**

```java
for(int i:asteroids){
    outer:
    {
        while (!s.isEmpty() && i < 0 && s.peek() > 0) {
            if (s.peek() < -i) {
                s.pop();
                continue;
            } else if (-i== s.peek()) {
                s.pop();
            }
            break outer;
        }
        s.push(i);
    }
}
```

如果当前质量大，就从while中结束，添加当前字符；如果当前字符小或者当前字符遇到了相等的，则不添加该字符，直接跳出outer

### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

> 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
>
>  
>
> 示例 1：
>
> 输入：s = "(()"
> 输出：2
> 解释：最长有效括号子串是 "()"
> 示例 2：
>
> 输入：s = ")()())"
> 输出：4
> 解释：最长有效括号子串是 "()()"
> 示例 3：
>
> 输入：s = ""
> 输出：0
>
>
> 提示：
>
> 0 <= s.length <= 3 * 104
> s[i] 为 '(' 或 ')'
>
> ![image-20220706190541936](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220706190541936.png)

```java
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> s1=new Stack<>();
        int ans=0;
        s1.push(-1);
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('){
                s1.push(i);
            }else{
                s1.pop();
                if(s1.isEmpty()){
                    s1.push(i);
                }else{
                    ans=Math.max(i-s1.peek(),ans);
                }
            }
        }

        return ans;
    }
}
```

1. 栈中存放的是`)`的下标，因为多向前一位正好等于连续匹配的长度
2. 保证栈中首个元素永远是连续匹配下标的前一个

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

> 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
>
> 求在该柱状图中，能够勾勒出来的矩形的最大面积。
>
>  
>
> 示例 1:
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)
>
> 
>
> 输入：heights = [2,1,5,6,2,3]
> 输出：10
> 解释：最大的矩形为图中红色区域，面积为 10
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)
>
> 输入： heights = [2,4]
> 输出： 4
>
> ![image-20220707073507093](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220707073507093.png)

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Deque<Integer> stack = new ArrayDeque<>();//deque比stack更灵活
        int[] temp = new int[heights.length + 2];//加入哨兵，最左边的哨兵可以防止栈为空；最后一个哨兵可以不用对最后一个单独进行判断
        System.arraycopy(heights, 0, temp, 1, heights.length);
        int ans = 0;

        for (int i = 0; i < temp.length; i++) {
            while (!stack.isEmpty() && temp[i] < temp[stack.peek()]) {//寻找卡口左边且大于卡口元素
                int h = temp[stack.poll()];//记录卡口前面的高度
                ans = Math.max(ans, h * (i - stack.peek()-1));//由于卡口前面的可能已poll掉了，因此需要找最前面的
            }
            stack.push(i);
        }

        return ans;
    }
}
```

1. 栈里面存放的是单调递增的，因此`h * (i - stack.peek()-1)`才可以不用考虑h的值比后面的大，h只会更小

### [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

> 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)
>
>
> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
> 输出：6
> 解释：最大矩形如上图所示。
> 示例 2：
>
> 输入：matrix = []
> 输出：0
> 示例 3：
>
> 输入：matrix = [["0"]]
> 输出：0
> 示例 4：
>
> 输入：matrix = [["1"]]
> 输出：1
> 示例 5：
>
> 输入：matrix = [["0","0"]]
> 输出：0
>
>
> 提示：
>
> rows == matrix.length
> cols == matrix[0].length
> 1 <= row, cols <= 200
> matrix[i][j] 为 '0' 或 '1'

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int[][] temp = new int[matrix.length][matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            if (i == 0) {
                for (int j = 0; j < matrix[0].length; j++) {
                    temp[i][j] = Integer.parseInt(matrix[i][j] + "");
                }
            } else {
                for (int j = 0; j < matrix[0].length; j++) {
                    if (matrix[i][j] == '1') {
                        temp[i][j] = temp[i - 1][j] + 1;
                    } else {
                        temp[i][j] = 0;
                    }
                }
            }
        }

        int ans = 0;
        for (int[] i : temp) {
            ans = Math.max(ans, ddz(i));
        }

        return ans;
    }

    public int ddz(int[] array) {
        int[] temp = new int[array.length + 2];
        System.arraycopy(array, 0, temp, 1, array.length);

        Deque<Integer> stack = new ArrayDeque<>();
        int ans = 0;
        for (int i = 0; i < temp.length; i++) {
            while (!stack.isEmpty() && temp[i] < temp[stack.peek()]) {
                int h = temp[stack.poll()];
                ans = Math.max(ans, h * (i - stack.peek() - 1));
            }
            stack.push(i);
        }

        return ans;
    }
}
```

![image-20220707105403484](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220707105403484.png)

按行进行寻找

1 0 1 0 0【1】

2 0 2 1 1【3】

3 1 3 2 2【6】

4 0 0 3 0【4】

### [895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/)

> 设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。
>
> 实现 FreqStack 类:
>
> FreqStack() 构造一个空的堆栈。
> void push(int val) 将一个整数 val 压入栈顶。
> int pop() 删除并返回堆栈中出现频率最高的元素。
> 如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。
>
>
> 示例 1：
>
> 输入：
> ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
> [[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
> 输出：[null,null,null,null,null,null,null,5,7,5,4]
> 解释：
> FreqStack = new FreqStack();
> freqStack.push (5);//堆栈为 [5]
> freqStack.push (7);//堆栈是 [5,7]
> freqStack.push (5);//堆栈是 [5,7,5]
> freqStack.push (7);//堆栈是 [5,7,5,7]
> freqStack.push (4);//堆栈是 [5,7,5,7,4]
> freqStack.push (5);//堆栈是 [5,7,5,7,4,5]
> freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。
> freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。
> freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。
> freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。
>
> ![image-20220707153316500](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220707153316500.png)

```java
class FreqStack {

    Map<Integer,Integer> fre;
    Map<Integer,Stack<Integer>> group;
    int max_fre;

    public FreqStack() {
        fre=new HashMap<>();
        group=new HashMap<>();
        max_fre=0;
    }

    public void push(int val) {
        int f=fre.getOrDefault(val,0)+1;
        fre.put(val,f);
        if(f>max_fre){
            max_fre=f;
        }
        Stack<Integer> temp=group.computeIfAbsent(f,key->new Stack<>());
        temp.push(val);

    }

    public int pop() {
        int x=group.get(max_fre).pop();
        fre.put(x,fre.get(x)-1);
        if(group.get(max_fre).size()==0){
            max_fre--;
        }
        return x;
    }
}
```

1. 对频率相同的元素，需要找到谁先进的，需要用到栈
2. 元素还需要与频率进行映射
3. 出现相同频率的元素放进同一个栈中
4. `computeIfAbsent`如果 key 对应的 value 不存在，则使用获取 remappingFunction 重新计算后的值，并保存为该 key 的 value，否则返回 value。`key->new Stack<>()`中的`key`是必须要写的

# HashSet / HashTable

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。
>
>  
>
> 示例 1：
>
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> 示例 2：
>
> 输入：nums = []
> 输出：[]
> 示例 3：
>
> 输入：nums = [0]
> 输出：[]
>
>
> 提示：
>
> 0 <= nums.length <= 3000
> -10^5 <= nums[i] <= 10^5

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);//排序+双指针确定两个数
        List<List<Integer>> ans = new ArrayList<>();
        int n = nums.length;//长度

        for (int i = 0; i < n; i++) {//确定第一个数
            if (i > 0 && nums[i] == nums[i - 1]) continue;//如果当前数和前一个相同，就不再计算
            for (int j = i + 1; j < n; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;//如果当前数用过一次，就不再用了，需要保证j>i+1;因为如果为-1 -1 2，而第一个-1没用过
                int r = nums.length - 1, num = -(nums[i] + nums[j]);//找到第三个数的大小

                while (j < r && nums[r] >= num) {//循环找到最后一个与num相等的数的下标
                    r--;
                }

                r++;//由于当前可能j==r或者nums[r]<num,因此前一个数是相等或者大于的数

                if (r<n&&nums[r] == num) {//由于+1可能会导致r==n，因此要保证不会越界，再去判断
                    ans.add(Arrays.asList(nums[i], nums[j], nums[r]));//元素可以通过数组转换成集合
                }
            }
        }

        return ans;
    }
}
```



### [18. 四数之和](https://leetcode.cn/problems/4sum/)

> 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
>
> 0 <= a, b, c, d < n
> a、b、c 和 d 互不相同
> nums[a] + nums[b] + nums[c] + nums[d] == target
> 你可以按 任意顺序 返回答案 。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,0,-1,0,-2,2], target = 0
> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
> 示例 2：
>
> 输入：nums = [2,2,2,2,2], target = 8
> 输出：[[2,2,2,2]]
>
> ![image-20220709141311463](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220709141311463.png)

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new LinkedList<>();
        if (nums.length < 4) return ans;

        for (int i = 0; i < nums.length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < nums.length - 2; j++) {
                if (j > i+1 && nums[j] == nums[j - 1]) continue;
                int l = j + 1, r = nums.length - 1;
                while (l < r) {
                    
                    Long sum = nums[i]*1l + nums[j] + nums[l] + nums[r];//注意要用long，否则相加后会溢出，由于相加时底层是用临时变量存储中间值得，因此一个数乘1L，临时变量的类型会默认为long类型
                    
                    int left = nums[l], right = nums[r];
                    if (sum < target) {
                        while (l < r && nums[l] == left) {//去重
                            l++;
                        }
                    } else if (sum > target) {
                        while (l < r && nums[r] == right) {//去重
                            r--;
                        }
                    } else {
                        ans.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));
                        while (l < r && nums[l] == left) l++;
                        while (l < r && nums[r] == right) r--;
                    }
                }
            }
        }

        return ans;
    }
}
```

1. 两个for循环确定两个数+双指针确定另外两个数
2. 特别要注意溢出问题
2. ` ans.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));`能够将元素转换成数组，数组可以通过**asList**转换成集合

### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

> 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。
>
>  
>
> 示例 1：
>
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2]
> 示例 2：
>
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[9,4]
> 解释：[4,9] 也是可通过的
>
>
> 提示：
>
> 1 <= nums1.length, nums2.length <= 1000
> 0 <= nums1[i], nums2[i] <= 1000

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        HashSet<Integer> h=new HashSet<>();
        Set<Integer> ans=new HashSet<>();

        for(int i:nums1) h.add(i);
        for(int i:nums2)
            if(h.contains(i))
                ans.add(i);

        int[] temp=new int[ans.size()];
        int temp1=-1;
        for(int i:ans) temp[++temp1]=i;

        return temp;
    }
}
```

1. Set去重

### [953. 验证外星语词典](https://leetcode.cn/problems/verifying-an-alien-dictionary/)

> 某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。
>
> 给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。
>
>  
>
> 示例 1：
>
> 输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
> 输出：true
> 解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。
> 示例 2：
>
> 输入：words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
> 输出：false
> 解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。
> 示例 3：
>
> 输入：words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
> 输出：false
> 解释：当前三个字符 "app" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 "apple" > "app"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。
>
>
> 提示：
>
> 1 <= words.length <= 100
> 1 <= words[i].length <= 20
> order.length == 26
> 在 words[i] 和 order 中的所有字符都是英文小写字母。

```java
class Solution {
    public boolean isAlienSorted(String[] words, String order) {
        int[] temp = new int[26];
        int temp_num = 0;
        for (int i = 0; i < order.length(); i++) temp[order.charAt(i) - 'a'] = temp_num++;
        for (int i = 1; i < words.length; i++) {
            if (temp[words[i - 1].charAt(0) - 'a'] > temp[words[i].charAt(0) - 'a']) {
                return false;
            } else if (temp[words[i - 1].charAt(0) - 'a'] == temp[words[i].charAt(0) - 'a']) {
                int len = words[i - 1].length() < words[i].length() ? words[i - 1].length() : words[i].length();
                if(len==1){
                    if(temp[words[i-1].charAt(0) - 'a'] == temp[words[i].charAt(0) - 'a']){
                        if(words[i-1].length()>words[i].length()) return false;
                    }else if(temp[words[i-1].charAt(0) - 'a'] > temp[words[i].charAt(0) - 'a']){
                        return false;
                    }
                }
                boolean flag = true;
                for (int j = 1; j < len; j++) {
                    if (temp[words[i - 1].charAt(j) - 'a'] > temp[words[i].charAt(j) - 'a']) return false;
                    flag=temp[words[i - 1].charAt(j) - 'a'] < temp[words[i].charAt(j) - 'a'] ? false:true;
                    if (flag && j == len - 1 && words[i - 1].length() > words[i].length()) return false;
                }
            }
        }

        return true;
    }
}
```

简化后

```java
class Solution {
    public boolean isAlienSorted(String[] words, String order) {
        int[] temp = new int[26];
        for (int i = 0; i < order.length(); i++) temp[order.charAt(i) - 'a'] = i;
        for (int i=1;i<words.length;i++){
            boolean flag=false;
            for(int j=0;j<words[i-1].length()&&j<words[i].length();j++) {
                int pre = temp[words[i - 1].charAt(j) - 'a'];
                int cur = temp[words[i].charAt(j) - 'a'];
                if (pre < cur) {
                    flag = true;
                    break;
                } else if (pre > cur) {
                    return false;
                }
            }
            if(!flag){
                if(words[i-1].length()>words[i].length()){
                    return false;
                }
            }
        }

        return true;
    }
}
```

1. 如果出现pre<cur,j就不需要再进行判断了
2. 只有pre=cur才继续往后进行判断
3. 只有遇到的全部相等时才进行判断长度

### [2261. 含最多 K 个可整除元素的子数组](https://leetcode.cn/problems/k-divisible-elements-subarrays/)

> 给你一个整数数组 nums 和两个整数 k 和 p ，找出并返回满足要求的不同的子数组数，要求子数组中最多 k 个可被 p 整除的元素。
>
> 如果满足下述条件之一，则认为数组 nums1 和 nums2 是 不同 数组：
>
> 两数组长度 不同 ，或者
> 存在 至少 一个下标 i 满足 nums1[i] != nums2[i] 。
> 子数组 定义为：数组中的连续元素组成的一个 非空 序列。
>
>  
>
> 示例 1：
>
> 输入：nums = [2,3,3,2,2], k = 2, p = 2
> 输出：11
> 解释：
> 位于下标 0、3 和 4 的元素都可以被 p = 2 整除。
> 共计 11 个不同子数组都满足最多含 k = 2 个可以被 2 整除的元素：
> [2]、[2,3]、[2,3,3]、[2,3,3,2]、[3]、[3,3]、[3,3,2]、[3,3,2,2]、[3,2]、[3,2,2] 和 [2,2] 。
> 注意，尽管子数组 [2] 和 [3] 在 nums 中出现不止一次，但统计时只计数一次。
> 子数组 [2,3,3,2,2] 不满足条件，因为其中有 3 个元素可以被 2 整除。
> 示例 2：
>
> 输入：nums = [1,2,3,4], k = 4, p = 1
> 输出：10
> 解释：
> nums 中的所有元素都可以被 p = 1 整除。
> 此外，nums 中的每个子数组都满足最多 4 个元素可以被 1 整除。
> 因为所有子数组互不相同，因此满足所有限制条件的子数组总数为 10 。
>
>
> 提示：
>
> 1 <= nums.length <= 200
> 1 <= nums[i], p <= 200
> 1 <= k <= nums.length

```java
class Solution {
    public int countDistinct(int[] nums, int k, int p) {
        Set<String> ans = new HashSet<>();
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            int num = k;
            StringBuilder temp=new StringBuilder();

            for (int j = i; j < n; j++) {
                temp.append(nums[j]+" ");
                if (nums[j] % p == 0) num--;

                if (num>=0&&!ans.contains(temp)){
                    ans.add(temp.toString());
                }
            }
        }

        return ans.size();
    }
}
```



# BFS

### [310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

> 树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。
>
> 给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。
>
> 可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。
>
> 请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。
>
> 树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/09/01/e1.jpg)
>
> 输入：n = 4, edges = [[1,0],[1,2],[1,3]]
> 输出：[1]
> 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2020/09/01/e2.jpg)
>
> 输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
> 输出：[3,4]
>
> ![image-20220707211504712](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220707211504712.png)

```java
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> ans = new ArrayList<>();
        if (n == 1) {
            ans.add(0);
            return ans;
        }

        int[] degree = new int[n];
        List<List<Integer>> list = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            list.add(new LinkedList<>());
        }

        for (int[] i : edges) {
            degree[i[0]]++;
            degree[i[1]]++;
            list.get(i[0]).add(i[1]);
            list.get(i[1]).add(i[0]);
        }

        Queue<Integer> q = new ArrayDeque<>();
        for (int i=0;i<degree.length;i++) {
            if (degree[i] == 1) q.offer(i);
        }

        while (!q.isEmpty()) {
            ans=new ArrayList<>();
            int size = q.size();

            for (int i = 0; i < size; i++) {
                int cur = q.poll();
                ans.add(cur);
                List<Integer> temp = list.get(cur);
                for (int j : temp) {
                    degree[j]--;
                    if (degree[j] == 1) {
                        q.offer(j);
                    }
                }
            }
        }

        return ans;
    }
}
```

1. 是我们看图（题目介绍里面的图）分析一下，发现，越是靠里面的节点越有可能是最小高度树。
2. 我们从边缘开始，先找到所有出度为1的节点，然后把所有出度为1的节点进队列，然后不断地bfs，最后找到的就是两边同时向中间靠近的节点，那么这个中间节点就相当于把整个距离二分了，那么它当然就是到两边距离最小的点啦，也就是到其他叶子节点最近的节点了。

### [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)

> 给你一个 m x n 的网格图 grid 。 grid 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况：
>
> 1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1]
> 2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1]
> 3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j]
> 4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j]
> 注意网格图中可能会有 无效数字 ，因为它们可能指向 grid 以外的区域。
>
> 一开始，你会从最左上角的格子 (0,0) 出发。我们定义一条 有效路径 为从格子 (0,0) 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 (m - 1, n - 1) 结束的路径。有效路径 不需要是最短路径 。
>
> 你可以花费 cost = 1 的代价修改一个格子中的数字，但每个格子中的数字 只能修改一次 。
>
> 请你返回让网格图至少有一条有效路径的最小代价。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png)
>
> 输入：grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
> 输出：3
> 解释：你将从点 (0, 0) 出发。
> 到达 (3, 3) 的路径为： (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) 花费代价 cost = 1 使方向向下 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) 花费代价 cost = 1 使方向向下 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) 花费代价 cost = 1 使方向向下 --> (3, 3)
> 总花费为 cost = 3.
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid2.png)
>
> 输入：grid = [[1,1,3],[3,2,2],[1,1,4]]
> 输出：0
> 解释：不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。
> 示例 3：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid3.png)
>
> 输入：grid = [[1,2],[4,3]]
> 输出：1
> 示例 4：
>
> 输入：grid = [[2,2,2],[2,2,2]]
> 输出：3
> 示例 5：
>
> 输入：grid = [[4]]
> 输出：0
>
> ![image-20220708111128655](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220708111128655.png)

```java
class Node {
    int r;//行
    int c;//列

    Node() {
    }

    ;

    Node(int r, int c) {
        this.r = r;
        this.c = c;
    }
}

class Solution {
    public int minCost(int[][] grid) {
        int inf = (int) (Integer.MAX_VALUE);//最大值
        int[] dx = new int[]{0, 0, 1, -1};//行变化
        int[] dy = new int[]{1, -1, 0, 0};//列变化
        int row = grid.length;//行数
        int col = grid[0].length;//列数

        int[][] dist = new int[row][col];//存放
        boolean[][] visited = new boolean[row][col];
        for (int i = 0; i < row; i++) {
            Arrays.fill(dist[i], inf);//不可达性
        }

        Deque<Node> stack = new LinkedList<>();
        stack.addLast(new Node(0, 0));//测试
        dist[0][0] = 0;//第一个节点可以到达

        while (!stack.isEmpty()) {
            Node temp = stack.poll();
            int r = temp.r, c = temp.c;
            if (visited[r][c] == true) continue;
            visited[r][c] = true;
            for (int i = 0; i < 4; i++) {
                int x = r + dx[i];
                int y = c + dy[i];
                int cost = (i + 1) == grid[r][c] ? 0 : 1;//判断是否转向正确
                if (x >= 0 && x < row && y >= 0 && y < col && dist[r][c] + cost < dist[x][y]) {
                    dist[x][y] = dist[r][c] + cost;//从0出发的，因此最终元素值就是结果
                    if (cost == 0) {//如果距离是较近的，就加入队首
                        stack.addFirst(new Node(x, y));
                    } else {//如果是较远的，就加入队尾‘保证了队列的递增性，总是先出出来最小的
                        stack.addLast(new Node(x, y));
                    }
                }
            }
        }
        return dist[row - 1][col - 1];
    }
}
```

1. 保证广度优先搜索正确性的基础在于：对于源点 ss 以及任意两个节点 uu 和 vv，如果 \textit{dist}(s, u) < \textit{dist}(s, v)dist(s,u)<dist(s,v)（其中 \textit{dist}(x, y)dist(x,y) 表示从节点 xx 到节点 yy 的最短路长度），那么节点 uu 一定会比节点 vv 先被取出队列。在常规的广度优先搜索中，我们使用队列作为维护节点的数据结构，就保证了从队列中取出的节点，它们与源点之间的距离是单调递增的。然而如果边权可能为 00，就会出现如下的情况:
   - 源点 s*s* 被取出队列；
   - 源点 s*s* 到节点 v_1*v*1 有一条权值为 11 的边，将节点 v_1*v*1 加入队列；
   - 源点 s*s* 到节点 v_2*v*2 有一条权值为 00 的边，将节点 v_2*v*2 加入队列；
2. 此时节点 v_2一定会在节点 v_1之后被取出队列，但节点 v_2与源点之间的距离反而较小，这样就破坏了广度优先搜索正确性的基础。
3. 那么我们如何修改广度优先搜索的算法框架呢？我们可以使用双端队列（double-ended queue, deque）代替普通的队列作为维护节点的数据结构。当任一节点 u 被取出队列时，如果它到某节点 v_iv i有一条权值为 00 的边，那么就将节点 v_iv i加入双端队列的「队首」。如果它到某节点 v_j  有一条权值为 11 的边，那么和常规的广度优先搜索相同，我们将节点 v_j加入双端队列的「队尾」。这样以来，我们保证了任意时刻从队首到队尾的所有节点，它们与源点之间的距离是单调递增的，即从队列中取出的节点与源点之间的距离同样是单调递增的。
4. - 四个方向
   - 距离数组
   - 是否被访问数组
   - BFS

### Bellman_Ford算法【贝尔曼-福特算法】

![image-20220708232650365](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220708232650365.png)

![image-20220708232935264](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220708232935264.png)

![image-20220708232949441](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220708232949441.png)

![image-20220708233038486](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220708233038486.png)

### [1129. 颜色交替的最短路径](https://leetcode.cn/problems/shortest-path-with-alternating-colors/)

> 在一个有向图中，节点分别标记为 0, 1, ..., n-1。图中每条边为红色或者蓝色，且存在自环或平行边。
>
> red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。
>
> 返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 answer[x] = -1。
>
>  
>
> 示例 1：
>
> 输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = []
> 输出：[0,1,-1]
> 示例 2：
>
> 输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]
> 输出：[0,1,-1]
> 示例 3：
>
> 输入：n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]
> 输出：[0,-1,-1]
> 示例 4：
>
> 输入：n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]
> 输出：[0,1,2]
> 示例 5：
>
> 输入：n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]
> 输出：[0,1,1]
>
>
> 提示：
>
> 1 <= n <= 100
> red_edges.length <= 400
> blue_edges.length <= 400
> red_edges[i].length == blue_edges[i].length == 2
> 0 <= red_edges[i][j], blue_edges[i][j] < n

```java
class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        int[][] path = new int[n][2];
        for (int i = 1; i < n; i++) {
            path[i][0] = path[i][1] = 160010;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < redEdges.length; j++) {
                if (path[redEdges[j][1]][0] > path[redEdges[j][0]][1] + 1) {
                    path[redEdges[j][1]][0]=path[redEdges[j][0]][1]+1;
                }
            }
            for(int j=0;j<blueEdges.length;j++){
                if(path[blueEdges[j][1]][1]>path[blueEdges[j][0]][0]+1){
                    path[blueEdges[j][1]][1]=path[blueEdges[j][0]][0]+1;
                }
            }
        }

        int[] ans=new int[n];
        for(int i=0;i<path.length;i++){
            ans[i]=path[i][0]<path[i][1]?path[i][0]:path[i][1];
            if(ans[i]==160010){
                ans[i]=-1;
            }
        }
        
        return ans;
    }
}
```

1. 贝尔曼_福特算法

### [289. 生命游戏](https://leetcode.cn/problems/game-of-life/)

> 根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。
>
> 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
>
> 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
> 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
> 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
> 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
> 下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg)
>
> 输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
> 输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg)
>
>
> 输入：board = [[1,1],[1,0]]
> 输出：[[1,1],[1,1]]
>
>
> 提示：
>
> m == board.length
> n == board[i].length
> 1 <= m, n <= 25
> board[i][j] 为 0 或 1
>
>
> 进阶：
>
> 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
> 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？

```java
class Solution {
    int m, n;

    public void gameOfLife(int[][] board) {
        m = board.length;
        n = board[0].length;
        int[][] temp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 0) {
                    int new_num = pd(board, i, j);
                    if (new_num == 3) temp[i][j] = 1;
                } else if (board[i][j] == 1) {
                    int new_num = pd(board, i, j);
                    if (new_num < 2||new_num > 3) temp[i][j] = 0;
                    else temp[i][j]=1;//对于新集合默认为0，因此不能和原数组一样，认为原元素为
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i][j] = temp[i][j];
            }
        }
    }

    public int pd(int[][] board, int x, int y) {
        int ans = 0;
        if (x - 1 >= 0 && y - 1 >= 0) ans += board[x - 1][y - 1] == 1 ? 1 : 0;
        if (x - 1 >= 0) ans += board[x - 1][y] == 1 ? 1 : 0;
        if (x - 1 >= 0 && y + 1 < n) ans += board[x - 1][y + 1] == 1 ? 1 : 0;
        if (y + 1 < n) ans += board[x][y + 1] == 1 ? 1 : 0;
        if (x + 1 < m && y + 1 < n) ans += board[x + 1][y + 1] == 1 ? 1 : 0;
        if (x + 1 < m) ans += board[x + 1][y] == 1 ? 1 : 0;
        if (x + 1 < m && y - 1 >= 0) ans += board[x + 1][y - 1] == 1 ? 1 : 0;
        if (y - 1 >= 0) ans += board[x][y - 1] == 1 ? 1 : 0;
        return ans;
    }
}
```

# 多路归并

![image-20220829230526372](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220829230526372.png)



## [263. 丑数](https://leetcode.cn/problems/ugly-number/)

> 丑数 就是只包含质因数 2、3 和 5 的正整数。
>
> 给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：n = 6
> 输出：true
> 解释：6 = 2 × 3
> 示例 2：
>
> 输入：n = 1
> 输出：true
> 解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。
> 示例 3：
>
> 输入：n = 14
> 输出：false
> 解释：14 不是丑数，因为它包含了另外一个质因数 7 。
>
>
> 提示：
>
> -2^31 <= n <= 2^31 - 1

```java
class Solution {
    public boolean isUgly(int n) {
        int[] temp=new int[]{2,3,5};
        for(int i=0;i<3;i++){
            while (n>0&&n%temp[i]==0) n/=temp[i];
        }

        return n==1 ? true:false;
    }
}
```

![image-20220712155053649](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220712155053649.png)

## \62. 丑数

> 我们把只包含质因子 2、32、3 和 55 的数称作丑数（Ugly Number）。
>
> 例如 6、86、8 都是丑数，但 1414 不是，因为它包含质因子 77。
>
> 求第 nn 个丑数的值。
>
> #### 数据范围
>
> 1≤n≤10001≤n≤1000
>
> #### 样例
>
> ```
> 输入：5
> 
> 输出：5
> ```
>
> **注意**：习惯上我们把 11 当做第一个丑数。

质因子：能整除给定正整数的**质数**

<img src="C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220712185922752.png" alt="image-20220712185922752" style="zoom:50%;" />

```java
class Solution {
    public int getUglyNumber(int n) {
        List<Integer> l=new ArrayList<>();
        l.add(1);
        int i=0,j=0,k=0;
        while (--n!=0){//循环n-1次
            int temp=Math.min(l.get(i)*2,Math.min(l.get(j)*3,l.get(k)*5));
            l.add(temp);
            if(temp==l.get(i)*2) i++;
            if(temp==l.get(j)*3) j++;
            if(temp==l.get(k)*5) k++;
        }

        return l.get(l.size()-1);
    }
}
```

## [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

> 给你一个整数 n ，请你找出并返回第 n 个 丑数 。
>
> 丑数 就是只包含质因数 2、3 和/或 5 的正整数。
>
>  
>
> 示例 1：
>
> 输入：n = 10
> 输出：12
> 解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
> 示例 2：
>
> 输入：n = 1
> 输出：1
> 解释：1 通常被视为丑数。
>
>
> 提示：
>
> 1 <= n <= 1690
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/ugly-number-ii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] ans=new int[n+1];
        ans[1]=1;
        for(int a2=1,a3=1,a5=1,index=2;index<=n;index++){
            int a=ans[a2]*2,b=ans[a3]*3,c=ans[a5]*5;
            int min=Math.min(a,Math.min(b,c));
            ans[index]=min;
            if(min==a) a2++;
            if(min==b) a3++;
            if(min==c) a5++;
        }

        return ans[n];
    }
}
```

1. 往后产生的丑数都是基于已有丑数而来的
2. 

## [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)

> 给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。
>
> 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。
>
> 请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。
>
>  
>
> 示例 1:
>
> 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
> 输出: [1,2],[1,4],[1,6]
> 解释: 返回序列中的前 3 对数：
>      [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
> 示例 2:
>
> 输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
> 输出: [1,1],[1,1]
> 解释: 返回序列中的前 2 对数：
>      [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
> 示例 3:
>
> 输入: nums1 = [1,2], nums2 = [3], k = 3 
> 输出: [1,3],[2,3]
> 解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]
>
>
> 提示:
>
> 1 <= nums1.length, nums2.length <= 105
> -109 <= nums1[i], nums2[i] <= 109
> nums1 和 nums2 均为升序排列
> 1 <= k <= 1000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/find-k-pairs-with-smallest-sums
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    boolean flag = true;

    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        int n = nums1.length, m = nums2.length;
        if (n > m) {
            flag = false;
            return kSmallestPairs(nums2, nums1, k);
        }

        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((o1, o2) -> nums1[o1[0]] + nums2[o1[1]] - (nums1[o2[0]] + nums2[o2[1]]));
        for (int i = 0; i < Math.min(k, n); i++) priorityQueue.offer(new int[]{i, 0});
        List<List<Integer>> ans = new ArrayList<>();
        while (ans.size() < k && !priorityQueue.isEmpty()) {
            int x = priorityQueue.peek()[0], y = priorityQueue.poll()[1];
            ans.add(new ArrayList<>() {
                {
                    add(flag ? nums1[x] : nums2[y]);
                    add(flag ? nums2[y] : nums1[x]);
                }
            });
            if (y + 1 < m) priorityQueue.add(new int[]{x, y + 1});
        }

        return ans;
    }
}
```



# Kruskal【克鲁斯卡尔算法】

![image-20220913091900226](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220913091900226.png)

模板

```java
int minimumCost(int n, int[][] edges) {
    // 编号为 0...n
    UF uf = new UF(n + 1);
    // 对所有边按照权重从小到大排序
    Arrays.sort(edges, (a, b) -> (a[2] - b[2]));
    // 记录最小生成树的权重之和
    int mst = 0;
    for (int[] edge : edges) {
        int u = edge[0];
        int v = edge[1];
        int weight = edge[2];
        // 若这条边会产生环，则不能加入 mst
        if (uf.connected(u, v)) {
            continue;
        }
        // 若这条边不会产生环，则属于最小生成树
        mst += weight;
        uf.union(u, v);
    }
    // 保证所有节点都被连通
    // uf.count() == 1 说明所有节点被连通
    return uf.count() == 1 ? mst : -1;
}

class UF {
    // 见 并查集总结 的实现
}
```



## [1584. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

> 给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。
>
> 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。
>
> 请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。
>
> 
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/08/26/d.png)
>
> 输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
> 输出：20
> 解释：
>
> ![img](https://assets.leetcode.com/uploads/2020/08/26/c.png)
>
> 我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。
> 注意到任意两个点之间只有唯一一条路径互相到达。
> 示例 2：
>
> 输入：points = [[3,12],[-2,5],[-4,1]]
> 输出：18
> 示例 3：
>
> 输入：points = [[0,0],[1,1],[1,0],[-1,1]]
> 输出：4
> 示例 4：
>
> 输入：points = [[-1000000,-1000000],[1000000,1000000]]
> 输出：4000000
> 示例 5：
>
> 输入：points = [[0,0]]
> 输出：0
>
>
> 提示：
>
> 1 <= points.length <= 1000
> -106 <= xi, yi <= 10^6
> 所有点 (xi, yi) 两两不同。



```java
class Solution {
    private int n;
    private int[][] points;
    private boolean[] flag;
    private Queue<int[]> pq;
    public int minCostConnectPoints(int[][] points) {
        n=points.length;
        this.points=points;
        this.flag=new boolean[n];
        this.pq=new PriorityQueue<>((a,b)->a[2]-b[2]);

        flag[0]=true;
        cut(0);
        int weightSum=0;
        while (!pq.isEmpty()){
            int[] cur=pq.poll();
            if(flag[cur[1]]) continue;
            flag[cur[1]]=true;
            weightSum+=cur[2];
            cut(cur[1]);
        }

        return weightSum;
    }

    public void cut(int x){
        for(int i=0;i<n;i++){
            if(i==x||flag[i]) continue;
            int d=Math.abs(points[x][0]-points[i][0])+Math.abs(points[x][1]-points[i][1]);
            pq.offer(new int[]{x,i,d});
        }
    }
}
```

### \859. Kruskal算法求最小生成树

> 给定一个 nn 个点 mm 条边的无向图，图中可能存在重边和自环，边权可能为负数。
>
> 求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。
>
> 给定一张边带权的无向图 G=(V,E)G=(V,E)，其中 VV 表示图中点的集合，EE 表示图中边的集合，n=|V|n=|V|，m=|E|m=|E|。
>
> 由 VV 中的全部 nn 个顶点和 EE 中 n−1n−1 条边构成的无向连通子图被称为 GG 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 GG 的最小生成树。
>
> #### 输入格式
>
> 第一行包含两个整数 nn 和 mm。
>
> 接下来 mm 行，每行包含三个整数 u,v,wu,v,w，表示点 uu 和点 vv 之间存在一条权值为 ww 的边。
>
> #### 输出格式
>
> 共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。
>
> #### 数据范围
>
> 1≤n≤1051≤n≤105,
> 1≤m≤2∗1051≤m≤2∗105,
> 图中涉及边的边权的绝对值均不超过 10001000。
>
> #### 输入样例：
>
> ```
> 4 5
> 1 2 1
> 1 3 2
> 1 4 3
> 2 3 2
> 3 4 4
> ```
>
> #### 输出样例：
>
> ```
> 6
> ```

```java
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.Collectors;

public class Main {
    public static int N=100010;//定义节点的最大数量
    static List<Node> list=new ArrayList<>();//存放每条边的信息
    public static int n,m;//节点数和边数
    public static int[] f=new int[N];//并查集用的祖宗数组

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n=sc.nextInt();
        m=sc.nextInt();
        
        for(int i=0;i<m;i++){//存储每条边的信息
            int a=sc.nextInt();
            int b=sc.nextInt();
            int w=sc.nextInt();
            list.add(new Node(a,b,w));
        }

        list.sort(((o1, o2) -> o1.w-o2.w));//对每条边进行排序
        init();//并查集初始化

        int ans=0;//存储结果
        int cnt=0;//路过的边数，用于判断是否能遍历所有节点
        for(int i=0;i<m;i++){
            int a=list.get(i).a;
            int b=list.get(i).b;
            int w=list.get(i).w;
            a=find(a);//获得当前节点的祖先节点
            b=find(b);//获得当前节点的祖先节点
            if(a!=b){//如果这两个节点的祖先不是同一个，就进行合并，同时加上权值
                f[a]=b;
                ans+=w;
                cnt++;
            }
        }

        if(cnt<n-1) System.out.println("impossible");//如果存在多个集合，就说明不能遍历每一节点
        else System.out.println(ans);//否则输出结果
    }

    public static int find(int x){
        if(f[x]!=x) return f[x]=find(f[x]);
        return f[x];
    }

    public static void init(){
        for(int i=0;i<n;i++)
            f[i]=i;
    }
}

class Node{
    int a,b,w;//左节点、右节点、边的权重
    public Node(int a,int b,int w){
        this.a=a;
        this.b=b;
        this.w=w;
    }
}
```



















# 并查集

![](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220823142207301.png)

![](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220823142605033.png)

> 并查集模板

```java
public static int[] p;

//初始化
for(int i=0;i<n;++i) p[i]=i;

//返回x的祖宗节点+路径压缩
public static int find(int x){
    if(p[x]!=x) p[x]=find(p[x]);
    //一定要返回祖宗节点，如果返回x，返回的就是传入的参数值
    return p[x];
}

//合并
p[find(a)] = find(b);
```

### \836. 合并集合

> 一共有 nn 个数，编号是 1∼n1∼n，最开始每个数各自在一个集合中。
>
> 现在要进行 mm 个操作，操作共有两种：
>
> 1. `M a b`，将编号为 aa 和 bb 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
> 2. `Q a b`，询问编号为 aa 和 bb 的两个数是否在同一个集合中；
>
> #### 输入格式
>
> 第一行输入整数 nn 和 mm。
>
> 接下来 mm 行，每行包含一个操作指令，指令为 `M a b` 或 `Q a b` 中的一种。
>
> #### 输出格式
>
> 对于每个询问指令 `Q a b`，都要输出一个结果，如果 aa 和 bb 在同一集合内，则输出 `Yes`，否则输出 `No`。
>
> 每个结果占一行。
>
> #### 数据范围
>
> 1≤n,m≤1051≤n,m≤105
>
> #### 输入样例：
>
> ```
> 4 5
> M 1 2
> M 3 4
> Q 1 2
> Q 1 3
> Q 3 4
> ```
>
> #### 输出样例：
>
> ```
> Yes
> No
> Yes
> ```

```java
package acwing;

import org.junit.Test;

import java.io.*;
import java.math.BigInteger;
import java.util.*;

class Main {
    static int N = 100010;
    static int[] p=new int[N];
    static int n,m;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        String[] str;

        str=br.readLine().split(" ");
        n=Integer.parseInt(str[0]);m=Integer.parseInt(str[1]);
        
        //初始化
        for(int i=0;i<n;++i) p[i]=i;

        while (m--!=0){
            str=br.readLine().split(" ");
            int a=Integer.parseInt(str[1]),b=Integer.parseInt(str[2]);
            if(str[0].equals("M")){
                //a连接到b集合里面
                p[find(a)]=find(b);
            }else{
                if(find(a)==find(b)) {
                    bw.write("Yes");
                    bw.newLine();
                } else {
                    bw.write("No");
                    bw.newLine();
                }
            }
        }


        bw.flush();
        bw.close();
        br.close();
    }

    //返回x的祖宗节点+路径压缩
    public static int find(int x){
        if(p[x]!=x) p[x]=find(p[x]);
        //一定要返回祖宗节点，如果返回x，返回的就是传入的参数值
        return p[x];
    }

}
```

### \837. 连通块中点的数量

> 给定一个包含 nn 个点（编号为 1∼n1∼n）的无向图，初始时图中没有边。
>
> 现在要进行 mm 个操作，操作共有三种：
>
> 1. `C a b`，在点 aa 和点 bb 之间连一条边，aa 和 bb 可能相等；
> 2. `Q1 a b`，询问点 aa 和点 bb 是否在同一个连通块中，aa 和 bb 可能相等；
> 3. `Q2 a`，询问点 aa 所在连通块中点的数量；
>
> #### 输入格式
>
> 第一行输入整数 nn 和 mm。
>
> 接下来 mm 行，每行包含一个操作指令，指令为 `C a b`，`Q1 a b` 或 `Q2 a` 中的一种。
>
> #### 输出格式
>
> 对于每个询问指令 `Q1 a b`，如果 aa 和 bb 在同一个连通块中，则输出 `Yes`，否则输出 `No`。
>
> 对于每个询问指令 `Q2 a`，输出一个整数表示点 aa 所在连通块中点的数量
>
> 每个结果占一行。
>
> #### 数据范围
>
> 1≤n,m≤1051≤n,m≤105
>
> #### 输入样例：
>
> ```
> 5 5
> C 1 2
> Q1 1 2
> Q2 1
> C 2 5
> Q2 5
> ```
>
> #### 输出样例：
>
> ```
> Yes
> 2
> 3
> ```

```java
import java.io.*;
import java.math.BigInteger;
import java.util.*;

class Main {
    static int N = 100010;
    static int[] p = new int[N];
    static int[] size = new int[N];
    static int n, m;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        String[] str;

        str = br.readLine().split(" ");
        n = Integer.parseInt(str[0]);
        m = Integer.parseInt(str[1]);

        //初始化
        for (int i = 0; i < n; ++i) {
            p[i] = i;
            size[i] = 1;
        }

        while (m-- != 0) {
            str = br.readLine().split(" ");
            int a = Integer.parseInt(str[1]);

            if (str[0].equals("C")) {
                int b = Integer.parseInt(str[2]);
                //a连接到b集合里面
                if (find(a) == find(b)) continue;
                size[find(b)] += size[find(a)];
                p[find(a)] = find(b);
            } else if (str[0].equals("Q1")) {
                int b = Integer.parseInt(str[2]);
                if (find(a) == find(b)) {
                    bw.write("Yes");
                    bw.newLine();
                } else {
                    bw.write("No");
                    bw.newLine();
                }
            } else {
                bw.write(size[find(a)]+"");
                bw.newLine();
            }
        }

        bw.flush();
        bw.close();
        br.close();
    }

    //返回x的祖宗节点+路径压缩
    public static int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        //一定要返回祖宗节点，如果返回x，返回的就是传入的参数值
        return p[x];
    }

}

```

## 





# 拓扑排序



## [207. 课程表](https://leetcode.cn/problems/course-schedule/)

> 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
>
> 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。
>
> 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
> 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：true
> 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
> 示例 2：
>
> 输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
> 输出：false
> 解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
>
>
> 提示：
>
> 1 <= numCourses <= 105
> 0 <= prerequisites.length <= 5000
> prerequisites[i].length == 2
> 0 <= ai, bi < numCourses
> prerequisites[i] 中的所有课程对 互不相同
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/course-schedule
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        HashMap<Integer,List<Integer>> graph=new HashMap<>();
        int[] indegree=new int[numCourses];
        for(int[] i:prerequisites){
            int start=i[0],end=i[1];
            graph.computeIfAbsent(start,key->new ArrayList<>()).add(end);
            indegree[end]++;
        }
        Queue<Integer> q=new LinkedList<>();
        for(int i=0;i<numCourses;i++){
            if(indegree[i]==0) q.offer(i);
        }
        int count=0;
        while (!q.isEmpty()){
            int cur=q.poll();
            count++;
            for(int nei:graph.getOrDefault(cur,new ArrayList<>())){
                if(--indegree[nei]==0) q.offer(nei);
            }
        }

        return numCourses==count;
    }
}
```

## [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

> 现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。
>
> 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
> 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。
>
>  
>
> 示例 1：
>
> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：[0,1]
> 解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
> 示例 2：
>
> 输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
> 输出：[0,2,1,3]
> 解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
> 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
> 示例 3：
>
> 输入：numCourses = 1, prerequisites = []
> 输出：[0]
>
>
> 提示：
> 1 <= numCourses <= 2000
> 0 <= prerequisites.length <= numCourses * (numCourses - 1)
> prerequisites[i].length == 2
> 0 <= ai, bi < numCourses
> ai != bi
> 所有[ai, bi] 互不相同
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/course-schedule-ii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        HashMap<Integer,List<Integer>> graph=new HashMap<>();
        int[] in_degree=new int[numCourses];
        for(int[] i:prerequisites){
            int start=i[0],end=i[1];
            graph.computeIfAbsent(start,key->new ArrayList<>()).add(end);
            in_degree[end]++;
        }
        Queue<Integer> q=new LinkedList<>();
        int[] ans=new int[numCourses];
        int temp=numCourses;
        int count=0;
        for(int i=0;i<numCourses;i++)
            if(in_degree[i]==0) q.offer(i);
        while (!q.isEmpty()){
            int cur=q.poll();

            ans[--temp]=cur;
            count++;

            for(int nei: graph.getOrDefault(cur,new ArrayList<>())){
                if(--in_degree[nei]==0) q.offer(nei);
            }
        }

        if(count!=numCourses) return new int[]{};
        else return ans;
    }
}
```

# 最短路径[Dijkstra]



![image-20220731234307762](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220731234307762.png)

![image-20220731234512929](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220731234512929.png)

![image-20220731234523879](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220731234523879.png)

```java
public int Dijkstra(int k){
        Array.Fill(distance, int.MaxValue/2); //搜索最短路径前以inf来代替未记录的两节点间距
        distance[k] = 0; //k代表，出发点，从k到它自己的距离为0

        for(int i = 1; i <= n; i++){
            int t = -1; //两者不相邻，先初始-1
            for(int j = 1; j <= n; j++){
                //t == -1为true，第一次可执行，后面被j赋值
                if(!visited[j] && (t == -1 || distance[t] > distance[j])) //找还未访问的节点
                    t = j;
            }
            visited[t] = true; //表示为已访问元素

            for(int j = 1; j <= n; j++)
                distance[j] = Math.Min(distance[j], distance[t] + nodes[t][j]); //比较最短距离
        }
        return distance[n];
    }
```



![image-20220801003630765](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220801003630765.png)

![image-20220801193003530](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220801193003530.png)



# Dijkstra

```java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] i : times) {
            int start = i[0], end = i[1], weight = i[2];
            graph.computeIfAbsent(start, key -> new ArrayList<>()).add(new int[]{end, weight});
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
        pq.offer(new int[]{k, 0});
        Map<Integer, Integer> dist = new HashMap<>();//把visit[]和dist[]合并了
        int ans = 0;
        /**
         * 由于是加入优先队列中，因此对于同一个点，距离进的优先到达
         * 如： A->B->D  1  2
         *     A->C->D  1  1
         *     此时B和C都进入队列中，然后对B和C进行扩散，会将1和2对加入到队列中，由于会进行排序因此会先走C->D
         *     再访问到D点,就会报“被访问过”；
         */
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int node = cur[0], distance = cur[1];
            if (dist.containsKey(node)) continue;
            dist.put(node, distance);
            ans = Math.max(ans, distance);
            for (int[] edge : graph.getOrDefault(node, new ArrayList<>())) {
                int nei = edge[0], distance2 = edge[1];
                if (!dist.containsKey(nei)) {
                    pq.offer(new int[]{nei, distance + distance2});
                }
            }
        }
        return dist.size() == n ? ans : -1;
    }
}
```

1. dijkstra不能处理带负边的值
   1. 例子：假如一张图里有一个总长为负数的环，那么Dijkstra算法有可能会沿着这个环一直绕下去，绕到地老天荒。。。

## [787. K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)

> 有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。
>
> 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。
>
>  
>
> 示例 1：
>
> ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)
>
> 输入: 
> n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
> src = 0, dst = 2, k = 1
> 输出: 200
> 解释: 
> 城市航班图如下
>
> 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。
> 示例 2：
>
> ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)
>
> 输入: 
> n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
> src = 0, dst = 2, k = 0
> 输出: 500
> 解释: 
> 城市航班图如下
>
>
> 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。
>
>
> 提示：
>
> 1 <= n <= 100
> 0 <= flights.length <= (n * (n - 1) / 2)
> flights[i].length == 3
> 0 <= fromi, toi < n
> fromi != toi
> 1 <= pricei <= 104
> 航班没有重复，且不存在自环
> 0 <= src, dst, k < n
> src != dst
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/cheapest-flights-within-k-stops
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        Map<Integer,List<int[]>> graph=new HashMap<>();
        Map<Integer,Integer> visit=new HashMap<>();
        for (int[] i:flights){
            int start=i[0],end=i[1],price=i[2];
            graph.computeIfAbsent(start,key->new ArrayList<>()).add(new int[]{end,price});
        }
        PriorityQueue<int[]> pq=new PriorityQueue<>((o1,o2)->o1[0]-o2[0]);

        pq.offer(new int[]{0,src,k+1});
        while (!pq.isEmpty()){
            int[] cur=pq.poll();
            int cost=cur[0],city=cur[1],stop=cur[2];
            visit.put(city,stop);
            if(city==dst) return cost;
            if(stop>0){
                for(int[] i:graph.getOrDefault(city,new ArrayList<>())){
                    int temp_end=i[0],temp_price=i[1];
                    if(!visit.containsKey(temp_end)||stop>visit.get(temp_end)){
                        pq.offer(new int[]{cost+temp_price,temp_end,stop-1});
                    }
                }
            }
        }

        return -1;
    }
}
```

## \849. Dijkstra求最短路 I、

> 给定一个 nn 个点 mm 条边的有向图，图中可能存在重边和自环，所有边权均为正值。
>
> 请你求出 11 号点到 nn 号点的最短距离，如果无法从 11 号点走到 nn 号点，则输出 −1−1。
>
> #### 输入格式
>
> 第一行包含整数 nn 和 mm。
>
> 接下来 mm 行每行包含三个整数 x,y,zx,y,z，表示存在一条从点 xx 到点 yy 的有向边，边长为 zz。
>
> #### 输出格式
>
> 输出一个整数，表示 11 号点到 nn 号点的最短距离。
>
> 如果路径不存在，则输出 −1−1。
>
> #### 数据范围
>
> 1≤n≤5001≤n≤500,
> 1≤m≤1051≤m≤105,
> 图中涉及边长均不超过10000。
>
> #### 输入样例：
>
> ```
> 3 3
> 1 2 2
> 2 3 1
> 1 3 4
> ```
>
> #### 输出样例：
>
> ```
> 3
> ```

```java
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.Collectors;

class Node {
    int x, y, z;

    public Node(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        HashMap<Integer, List<int[]>> hashMap = new HashMap<>();
        for (int i = 0; i < m; i++) {
            int x = sc.nextInt(), y = sc.nextInt(), z = sc.nextInt();
            hashMap.computeIfAbsent(x, key -> new ArrayList<>()).add(new int[]{y, z});
        }

        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
        pq.offer(new int[]{1, 0});
        Set<Integer> visit = new HashSet<>();
        visit.add(1);
        int[] dist = new int[n + 1];
        Arrays.fill(dist, 0x3f3f3f);
        dist[1] = 0;

        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int cur_node = cur[0], cur_dist = cur[1];
            for (int[] i : hashMap.getOrDefault(cur_node, new ArrayList<>())) {
                int next_node = i[0], next_dist = i[1];
                if (!visit.contains(next_node) || dist[cur_node] + next_dist < dist[next_node]) {
                    dist[next_node] = dist[cur_node] + next_dist;
                    pq.offer(new int[]{next_node, next_dist});
                    visit.add(next_node);
                }
            }
        }
        if (dist[n] == 0x3f3f3f) {
            System.out.println(-1);
        } else System.out.println(dist[n]);
    }
}
```

## \850. Dijkstra求最短路 II

> 给定一个 nn 个点 mm 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。
>
> 请你求出 11 号点到 nn 号点的最短距离，如果无法从 11 号点走到 nn 号点，则输出 −1−1。
>
> #### 输入格式
>
> 第一行包含整数 nn 和 mm。
>
> 接下来 mm 行每行包含三个整数 x,y,zx,y,z，表示存在一条从点 xx 到点 yy 的有向边，边长为 zz。
>
> #### 输出格式
>
> 输出一个整数，表示 11 号点到 nn 号点的最短距离。
>
> 如果路径不存在，则输出 −1−1。
>
> #### 数据范围
>
> 1≤n,m≤1.5×1051≤n,m≤1.5×105,
> 图中涉及边长均不小于 00，且不超过 1000010000。
> 数据保证：如果最短路存在，则最短路的长度不超过 109109。
>
> #### 输入样例：
>
> ```
> 3 3
> 1 2 2
> 2 3 1
> 1 3 4
> ```
>
> #### 输出样例：
>
> ```
> 3
> ```

堆优化版本

```java
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.Collectors;


public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        HashMap<Integer, List<int[]>> hashMap = new HashMap<>();
        for (int i = 0; i < m; i++) {
            int x = sc.nextInt(), y = sc.nextInt(), z = sc.nextInt();
            hashMap.computeIfAbsent(x, key -> new ArrayList<>()).add(new int[]{y, z});
        }

        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
        pq.offer(new int[]{1, 0});
        Set<Integer> visit = new HashSet<>();
        int[] dist = new int[n + 1];
        Arrays.fill(dist, 0x3f3f3f3f);
        dist[1] = 0;

        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int cur_node = cur[0], cur_dist = cur[1];
            if(visit.contains(cur_node)) continue;
            visit.add(cur_node);

            for (int[] i : hashMap.getOrDefault(cur_node, new ArrayList<>())) {
                int next_node = i[0], next_dist = i[1];
                if (dist[cur_node] + next_dist < dist[next_node]) {
                    dist[next_node] = cur_dist + next_dist;
                    pq.offer(new int[]{next_node, dist[next_node]});
                }
            }
        }

        if (dist[n] == 0x3f3f3f3f) System.out.println(-1);
        else System.out.println(dist[n]);
    }
}
```

1. 注意要使用0x3f3f3f3f
2. 两个位置存储距离。deque、dist数组

# bellman-ford

## \853. 有边数限制的最短路

> 给定一个 nn 个点 mm 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。
>
> 请你求出从 11 号点到 nn 号点的最多经过 kk 条边的最短距离，如果无法从 11 号点走到 nn 号点，输出 `impossible`。
>
> 注意：图中可能 **存在负权回路** 。
>
> #### 输入格式
>
> 第一行包含三个整数 n,m,kn,m,k。
>
> 接下来 mm 行，每行包含三个整数 x,y,zx,y,z，表示存在一条从点 xx 到点 yy 的有向边，边长为 zz。
>
> 点的编号为 1∼n1∼n。
>
> #### 输出格式
>
> 输出一个整数，表示从 11 号点到 nn 号点的最多经过 kk 条边的最短距离。
>
> 如果不存在满足条件的路径，则输出 `impossible`。
>
> #### 数据范围
>
> 1≤n,k≤5001≤n,k≤500,
> 1≤m≤100001≤m≤10000,
> 1≤x,y≤n1≤x,y≤n，
> 任意边长的绝对值不超过 1000010000。
>
> #### 输入样例：
>
> ```
> 3 3 1
> 1 2 1
> 2 3 1
> 1 3 3
> ```
>
> #### 输出样例：
>
> ```
> 3
> ```

```java
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.Collectors;

public class Main {
    public static int N=510,M=10010;
    public static int n,m,k;//节点个数、边数、限制边数
    public static int[] dist=new int[N];//存放起点到某节点的距离    
    public static int[] backup=new int[N];//备份上一次更新的地图，防止发生串联
    public static int[][] edges=new int[M][3];//地图
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        n=sc.nextInt();
        m=sc.nextInt();
        k=sc.nextInt();
        for(int i=0;i<m;i++){
            int a=sc.nextInt();
            int b=sc.nextInt();
            int value=sc.nextInt();
            edges[i]=new int[]{a,b,value};
        }
        int t=bellman_ford();

        System.out.println(t==0x3f3f3f3f?"impossible":t);
    }

    public static int bellman_ford(){
        Arrays.fill(dist,0x3f3f3f3f);//将所有结点都置为不可到达
        dist[1]=0;//到达起点的距离置为0
        for(int i=0;i<k;i++){
            backup=Arrays.copyOf(dist,dist.length);//   
            for(int j=0;j<m;j++){
                int a=edges[j][0],b=edges[j][1],value=edges[j][2];
                dist[b]=Math.min(dist[b],backup[a]+value);
            }
        }

        if(dist[n]>0x3f3f3f3f/2) return 0x3f3f3f3f;
        return dist[n];
    }
}
```

1. backup保证了每次都更新1步
1. 串联是在一次迭代中更新更多条边，备份是解决串联的（题目限制k次访问边的次数），备份能然更新是保证只用上次迭代的结果
1. bellman_ford是每次更新所有边；时间复杂度：O（N*M）

# spfa

## \851. spfa求最短路

> 给定一个 nn 个点 mm 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。
>
> 请你求出 11 号点到 nn 号点的最短距离，如果无法从 11 号点走到 nn 号点，则输出 `impossible`。
>
> 数据保证不存在负权回路。
>
> #### 输入格式
>
> 第一行包含整数 nn 和 mm。
>
> 接下来 mm 行每行包含三个整数 x,y,zx,y,z，表示存在一条从点 xx 到点 yy 的有向边，边长为 zz。
>
> #### 输出格式
>
> 输出一个整数，表示 11 号点到 nn 号点的最短距离。
>
> 如果路径不存在，则输出 `impossible`。
>
> #### 数据范围
>
> 1≤n,m≤1051≤n,m≤105,
> 图中涉及边长绝对值均不超过 1000010000。
>
> #### 输入样例：
>
> ```
> 3 3
> 1 2 5
> 2 3 -3
> 1 3 4
> ```
>
> #### 输出样例：
>
> ```
> 2
> ```

```java
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.Collectors;


public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        HashMap<Integer, List<int[]>> hashMap = new HashMap<>();
        for (int i = 0; i < m; i++) {
            int x = sc.nextInt(), y = sc.nextInt(), z = sc.nextInt();
            hashMap.computeIfAbsent(x, key -> new ArrayList<>()).add(new int[]{y, z});
        }

        Queue<Integer> queue = new ArrayDeque<>();
        queue.offer(1);

        int[] dist = new int[n + 1];
        Arrays.fill(dist, 0x3f3f3f3f);
        dist[1] = 0;

        while (!queue.isEmpty()) {
            int size=queue.size();
            for(int i=0;i<size;i++){
                int cur=queue.poll();
                for(int[] j:hashMap.getOrDefault(cur,new ArrayList<>())){
                    int next=j[0],val=j[1];
                    if(dist[next]>dist[cur]+val){//如果当前节点更新了，就把该节点加入到队列中，也就意味着后面的点也能更新
                        queue.offer(next);
                        dist[next]=dist[cur]+val;
                    }
                }
            }
        }

        if (dist[n] == 0x3f3f3f3f) System.out.println("impossible");
        else System.out.println(dist[n]);
    }
}
```

## \852. spfa判断负环

> 给定一个 nn 个点 mm 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。
>
> 请你判断图中是否存在负权回路。
>
> #### 输入格式
>
> 第一行包含整数 nn 和 mm。
>
> 接下来 mm 行每行包含三个整数 x,y,zx,y,z，表示存在一条从点 xx 到点 yy 的有向边，边长为 zz。
>
> #### 输出格式
>
> 如果图中**存在**负权回路，则输出 `Yes`，否则输出 `No`。
>
> #### 数据范围
>
> 1≤n≤20001≤n≤2000,
> 1≤m≤100001≤m≤10000,
> 图中涉及边长绝对值均不超过 1000010000。
>
> #### 输入样例：
>
> ```
> 3 3
> 1 2 -1
> 2 3 4
> 3 1 -4
> ```
>
> #### 输出样例：
>
> ```
> Yes
> ```

```java
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.Collectors;


public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        HashMap<Integer, List<int[]>> hashMap = new HashMap<>();
        for (int i = 0; i < m; i++) {
            int x = sc.nextInt(), y = sc.nextInt(), z = sc.nextInt();
            hashMap.computeIfAbsent(x, key -> new ArrayList<>()).add(new int[]{y, z});
        }

        Queue<Integer> queue = new ArrayDeque<>();
        queue.offer(1);
        int[] dist = new int[n + 1];
        int[] cnt = new int[n + 1];

        for(int i=1;i<=n;i++)//只是证名存在负环，并没有要求是从1开始得负环，因此可以把全部点加到队列中
            queue.offer(i);

        boolean flag=false;
        outer:while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int cur = queue.poll();
                for (int[] j : hashMap.getOrDefault(cur, new ArrayList<>())) {
                    int next = j[0], val = j[1];
                    if (dist[next] > dist[cur] + val) {
                        cnt[next]=cnt[cur]+1;//如果存在负环，就必然会转圈；因此从1~n+1是n条边
                        if(cnt[next]>=n) {
                            flag=true;
                            break outer;
                        }
                        queue.offer(next);
                        dist[next] = dist[cur] + val;
                    }
                }
            }
        }

        if (flag) System.out.println("Yes");
        else System.out.println("No");
    }
}
```

# Floyd算法

## \854. Floyd求最短路

> 给定一个 nn 个点 mm 条边的有向图，图中可能存在重边和自环，边权可能为负数。
>
> 再给定 kk 个询问，每个询问包含两个整数 xx 和 yy，表示查询从点 xx 到点 yy 的最短距离，如果路径不存在，则输出 `impossible`。
>
> 数据保证图中不存在负权回路。
>
> #### 输入格式
>
> 第一行包含三个整数 n,m,kn,m,k。
>
> 接下来 mm 行，每行包含三个整数 x,y,zx,y,z，表示存在一条从点 xx 到点 yy 的有向边，边长为 zz。
>
> 接下来 kk 行，每行包含两个整数 x,yx,y，表示询问点 xx 到点 yy 的最短距离。
>
> #### 输出格式
>
> 共 kk 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 `impossible`。
>
> #### 数据范围
>
> 1≤n≤2001≤n≤200,
> 1≤k≤n21≤k≤n2
> 1≤m≤200001≤m≤20000,
> 图中涉及边长绝对值均不超过 1000010000。
>
> #### 输入样例：
>
> ```
> 3 3 2
> 1 2 1
> 2 3 2
> 1 3 1
> 2 1
> 1 3
> ```
>
> #### 输出样例：
>
> ```
> impossible
> 1
> ```

```
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.Collectors;


public class Main {
    public static int N=210,M=20010,INF=(int) 0x3f3f3f3f;
    public static int n,m,k;
    public static int[][] d=new int[N][N];
    public static void main(String[] args) throws Exception {
        Scanner sc=new Scanner(System.in);
        n=sc.nextInt();
        m=sc.nextInt();
        k=sc.nextInt();

        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(i==j){
                    d[i][j]=0;
                }else d[i][j]=INF;
            }
        }

        while (m-->0){
            int x=sc.nextInt(),y=sc.nextInt(),z=sc.nextInt();
            d[x][y]=Math.min(d[x][y],z);
        }

        floyd();

        while (k-->0){
            int x=sc.nextInt(),y=sc.nextInt();
            if(d[x][y]>INF/2)
                System.out.println("impossible");
            else
                System.out.println(d[x][y]);
        }

    }

    public static void floyd(){
        for(int l=1;l<=n;l++){
            for(int i=1;i<=n;i++){
                for(int j=1;j<=n;j++){
                    d[i][j]=Math.min(d[i][j],d[i][l]+d[l][j]);
                }
            }
        }
    }
}
```

为什么是INF/2呀，万一最短路本来就大于INF/2呢，这不科学呀。。

INF最好取得远大于最短路长度。一般判断无解可以写dist[n] == INF，但由于有负权边存在，就算1和n不连通，dist[n]也可能被更新，所以不能判是否相等，改成判断是否很大就可以了。

# Prim

![](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220908225258218.png)

## \858. Prim算法求最小生成树

> 给定一个 nn 个点 mm 条边的无向图，图中可能存在重边和自环，边权可能为负数。
>
> 求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。
>
> 给定一张边带权的无向图 G=(V,E)G=(V,E)，其中 VV 表示图中点的集合，EE 表示图中边的集合，n=|V|n=|V|，m=|E|m=|E|。
>
> 由 VV 中的全部 nn 个顶点和 EE 中 n−1n−1 条边构成的无向连通子图被称为 GG 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 GG 的最小生成树。
>
> #### 输入格式
>
> 第一行包含两个整数 nn 和 mm。
>
> 接下来 mm 行，每行包含三个整数 u,v,wu,v,w，表示点 uu 和点 vv 之间存在一条权值为 ww 的边。
>
> #### 输出格式
>
> 共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。
>
> #### 数据范围
>
> 1≤n≤5001≤n≤500,
> 1≤m≤1051≤m≤105,
> 图中涉及边的边权的绝对值均不超过 1000010000。
>
> #### 输入样例：
>
> ```
> 4 5
> 1 2 1
> 1 3 2
> 1 4 3
> 2 3 2
> 3 4 4
> ```
>
> #### 输出样例：
>
> ```
> 6
> ```

```java
//对于稠密图使用邻接矩阵
//对于稀疏矩阵使用邻接表


import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.Collectors;

public class Main {
    static int N = 510, INF = 0x3f3f3f3f;//节点个数，最大值
    static int[][] g = new int[N][N];//定义地图
    static int[] dist = new int[N];//存放最小距离
    static boolean[] visit = new boolean[N];//判断是否被访问过
    static int n, m;//节点个数，边数

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();

        for (int i = 1; i <= n; i++)
            Arrays.fill(g[i], INF);//将图设置为最大值
        Arrays.fill(dist, INF);//将到某个节点的距离设置为最大值

        while (m-- > 0) {
            int u = sc.nextInt(), v = sc.nextInt(), w = sc.nextInt();
            g[u][v] = Math.min(g[u][v], w);//对于无向图可以将其看做双向图
            g[v][u] = Math.min(g[v][u], w);
        }

        int t = prim();//进行prim运算

        if (t == INF)//如果到达当前的还是最大值，说明走不到
            System.out.println("impossible");
        else
            System.out.println(t);
    }

    public static int prim() {
        //将遇到过的点置为false，也就相当于将其放进一个集合里面去了
        int ans = 0;//存放最终结果
        for (int i = 0; i < n; i++) {
            int t = -1;//设置个哨兵
            for (int j = 1; j <= n; j++) {
                if (!visit[j] && (t == -1 || dist[t] > dist[j])) {//寻找集合周围最短的边的节点
                    t = j;
                }
            }
            if (i > 0 && dist[t] == INF) {//如果最短边还是INF，就说明到达截止了，
                return INF;
            }
            if (i > 0) {//将结果进行更新
                ans += dist[t];
            }
            for (int j = 1; j <= n; j++) {//到达某个节点的距离进行更新
                dist[j] = Math.min(dist[j], g[t][j]);
            }
            visit[t] = true;
        }
        return ans;
    }
}
```





# 最小生成

![image-20220804215045816](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220804215045816.png)

![image-20220804215343385](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220804215343385.png)

![image-20220804215730093](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220804215730093.png)

![image-20220805215413239](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220805215413239.png)

# 递归

### 快速幂

```java
    public long qmi(long basic, long n) {
        long ans = 1;
        while (n != 0) {
            if ((n & 1) == 1) ans = 1l*ans * basic % mod;
            n = n >> 1;
            basic = 1l* basic * basic % mod;
        }

        return ans;
    }
```

### [1922. 统计好数字的数目](https://leetcode.cn/problems/count-good-numbers/)

> 我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。
>
> 比方说，"2582" 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。但 "3245" 不是 好数字，因为 3 在偶数下标处但不是偶数。
> 给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对 109 + 7 取余后返回 。
>
> 一个 数字字符串 是每一位都由 0 到 9 组成的字符串，且可能包含前导 0 。
>
>  
>
> 示例 1：
>
> 输入：n = 1
> 输出：5
> 解释：长度为 1 的好数字包括 "0"，"2"，"4"，"6"，"8" 。
> 示例 2：
>
> 输入：n = 4
> 输出：400
> 示例 3：
>
> 输入：n = 50
> 输出：564908303
>
>
> 提示：
>
> 1 <= n <= 1015
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/count-good-numbers
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int mod = (int) 1e9 + 7;

    public int countGoodNumbers(long n) {
        long n1 = n >> 1;
        long n2 = n1;
        if ((n & 1) == 1) n2++;
        return (int) (qmi(4, n1) * qmi(5, n2) % mod);
    }

    public long qmi(long basic, long n) {
        long ans = 1;
        while (n != 0) {
            if ((n & 1) == 1) ans = 1l*ans * basic % mod;
            n = n >> 1;
            basic = 1l* basic * basic % mod;
        }

        return ans;
    }
}
```

### [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

> 实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。
>
>  
>
> 示例 1：
>
> 输入：x = 2.00000, n = 10
> 输出：1024.00000
> 示例 2：
>
> 输入：x = 2.10000, n = 3
> 输出：9.26100
> 示例 3：
>
> 输入：x = 2.00000, n = -2
> 输出：0.25000
> 解释：2-2 = 1/22 = 1/4 = 0.25
>
>
> 提示：
>
> -100.0 < x < 100.0
> -231 <= n <= 231-1
> -104 <= xn <= 104
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/powx-n
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public double myPow(double x, int n) {
        if(x==0.0f) return 0.0d;
        long b=n;
        double ans=1.0;
        if(b<0){
            x=1/x;
            b=-b;
        }
        while (b!=0){
            if((b&1)==1) ans*=x;
            x*=x;
            b>>=1;
        }

        return ans;
    }
}
```

1. 幂必须要换成long类型

# 括号匹配

### [1541. 平衡括号字符串的最少插入次数](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/)

> 给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足：
>
> 任何左括号 '(' 必须对应两个连续的右括号 '))' 。
> 左括号 '(' 必须在对应的连续两个右括号 '))' 之前。
> 比方说 "())"， "())(())))" 和 "(())())))" 都是平衡的， ")()"， "()))" 和 "(()))" 都是不平衡的。
>
> 你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。
>
> 请你返回让 s 平衡的最少插入次数。
>
> 
>
> 示例 1：
>
> 输入：s = "(()))"
> 输出：1
> 解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 "(())))" 。
> 示例 2：
>
> 输入：s = "())"
> 输出：0
> 解释：字符串已经平衡了。
> 示例 3：
>
> 输入：s = "))())("
> 输出：3
> 解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。
> 示例 4：
>
> 输入：s = "(((((("
> 输出：12
> 解释：添加 12 个 ')' 得到平衡字符串。
> 示例 5：
>
> 输入：s = ")))))))"
> 输出：5
> 解释：在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 "(((())))))))" 。
>
>
> 提示：
>
> 1 <= s.length <= 10^5
> s 只包含 '(' 和 ')' 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int minInsertions(String s) {
        int ans=0,need=0,n=s.length();
        for(int i=0;i<n;i++){
            char c=s.charAt(i);
            if(c=='('){
                need+=2;
                if(need%2==1){
                    ans++;
                    need--;
                }
            }else {
                need--;
                if(need==-1){
                    ans++;
                    need=1;
                }
            }
        }

        return ans+need;
    }
}
```

1. 基本思路

   遍历字符串，通过一个 `need` 变量记录对右括号的需求数，根据 `need` 的变化来判断是否需要插入。

   类似 [921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid)，当 `need == -1` 时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号。

   另外，当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号，因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数，这一点也是本题的难点。

   **详细题解：[如何解决括号相关的问题](https://labuladong.github.io/article/fname.html?fname=括号插入)**

### [921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)

> 只有满足下面几点之一，括号字符串才是有效的：
>
> 它是一个空字符串，或者
> 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
> 它可以被写作 (A)，其中 A 是有效字符串。
> 给定一个括号字符串 s ，移动N次，你就可以在字符串的任何位置插入一个括号。
>
> 例如，如果 s = "()))" ，你可以插入一个开始括号为 "(()))" 或结束括号为 "())))" 。
> 返回 为使结果字符串 s 有效而必须添加的最少括号数。
>
> 
>
> 示例 1：
>
> 输入：s = "())"
> 输出：1
> 示例 2：
>
> 输入：s = "((("
> 输出：3
>
>
> 提示：
>
> 1 <= s.length <= 1000
> s 只包含 '(' 和 ')' 字符。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int minAddToMakeValid(String s) {
        int ans=0,need=0,n=s.length();
        for(int i=0;i<n;i++){
            char c=s.charAt(i);
            if(c=='('){
                need++;
            }else {
                need--;
                if(need==-1){
                    ans++;
                    need=0;
                }
            }
        }
        
        return ans+need;
    }
}
```

# 线段树

```java

class segment_tree {
    class Node {
        int start, end, sum;
        Node left, right;

        public Node(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    int[] nums;
    Node root;

    public segment_tree(int[] nums) {
        this.nums = nums;
        this.root = build_tree(nums, 0, nums.length - 1);
    }

    public Node build_tree(int[] nums, int start, int end) {
        if (start > end) return null;
        Node node = new Node(start, end);
        if (start == end) node.sum = nums[start];
        else {
            int mid = start + (end - start) / 2;
            node.left = build_tree(nums, start, mid);
            node.right = build_tree(nums, mid + 1, end);
            node.sum = node.left.sum + node.right.sum;
        }

        return node;
    }

    public void update(Node node, int i, int val) {
        if (node.start == node.end) {
            node.sum = val;
            return;
        }
        int mid = node.start + (node.end - node.start) / 2;
        if (i <= mid) update(node.left, i, val);
        else if (i > mid) update(node.right, i, val);
        node.sum = node.left.sum + node.right.sum;
    }

    public int sum_range(Node node, int start, int end) {
        if (start > end) return 0;
        if (node.start == start && node.end == end) return node.sum;
        int mid = node.start + (node.end - node.start) / 2;
        if (end <= mid) return sum_range(node.left, start, end);
        else if (start > mid) return sum_range(node.right, start, end);
        else return sum_range(node.left, start, end) + sum_range(node.right, start, end);
    }

}

class NumArray {
    segment_tree segment_tree;

    public NumArray(int[] nums) {
        segment_tree = new segment_tree(nums);
    }

    public void update(int index, int val) {
        segment_tree.update(segment_tree.root, index, val);
    }

    public int sumRange(int left, int right) {
        return segment_tree.sum_range(segment_tree.root, left, right);
    }
}
```

新知识

> 最终测试代码
>
> 单点更新

```java
class Solution {
    public static void main(String[] args) {
        int left=0;
        int right=5;
        int[] a=new int[20];
        tree_insert(a,0,left,right,3);
        tree_insert(a,0,left,right,5);
        tree_insert(a,0,left,right,2);

        tree_print(a,0,left,right);

        for(int i=0;i<=5;i++)
            if(tree_search(a,0,left,right,i)>0)
                System.out.println(i);

        return;
    }

    //线段树的查找
    public static int tree_search(int[] a,int pos,int left,int right,int num){
        if(num==left&&num==right)
            return a[pos];
        int mid=(left+right)/2;
        int left_child=pos*2+1;
        int right_child=pos*2+2;
        if(num<=mid)
            return tree_search(a,left_child,left,mid,num);
        else
            return tree_search(a,right_child,mid+1,right,num);
    }


    //线段树的插入
    public static void tree_insert(int[] a,int pos,int left,int right,int num){
        a[pos]++;
        if(num==left&&num==right)
            return;
        int mid=(left+right)/2;
        int left_child=pos*2+1;
        int right_child=pos*2+2;
        if(num<=mid)
            tree_insert(a,left_child,left,mid,num);
        else
            tree_insert(a,right_child,mid+1,right,num);
    }


    //线段树的打印
    public static void tree_print(int[] a,int pos,int left,int right){
        System.out.println(left+" "+right+" "+pos+" "+a[pos]);
        if(left==right)
            return;
        int mid=(left+right)/2;
        tree_print(a,pos*2+1,left,mid);
        tree_print(a,pos*2+2,mid+1,right);
    }
}

```

> 最终版

```


//线段树
class segment_tree{
    int[] nums;
    Node root;
    public segment_tree(int[] nums){
        this.nums=nums;
        this.root=build_tree(nums,0,nums.length-1);
    }

    public Node build_tree(int[] nums,int start,int end){
        if(start>end)
            return null;
        Node node=new Node(start,end);
        if(start==end)
            node.sum=nums[start];
        else {
            int mid=start+(end-start)/2;
            node.left=build_tree(nums,start,mid);
            node.right=build_tree(nums,mid+1,end);
            node.sum=node.left.sum+node.right.sum;
        }

        return node;
    }

    public void update(Node node,int i,int val){
        if (node.start==node.end){
            node.sum=val;
            return;
        }
        int mid=node.start+(node.end-node.start)/2;
        if(i<=mid)
            update(node.left,i,val);
        else
            update(node.right,i,val);
        node.sum=node.left.sum+node.right.sum;
    }

    public int sum_range(Node node,int start,int end){
        if(start>end)
            return 0;
        if(node.start==start&&node.end==end)
            return node.sum;
        int mid=node.start+(node.end-node.start)/2;
        if(end<=mid)
            return sum_range(node.left,start,end);
        else if(start>mid) return sum_range(node.right,start,end);
        else return sum_range(node.left,start,mid)+sum_range(node.right,mid+1,end);
    }
}
class Node{
    int start,end,sum;
    Node left,right;
    Node(int start,int end){
        this.start=start;
        this.end=end;
    }
}
```



==重点==

动态开点，解决内存溢出情况

>  线段树（动态开点）- 估点

​	原题解在 这里，本次增加「动态指针开点方式」和「TS 代码实现」

> 和 729. 我的日程安排表 I 几乎完全一致，只需要将对「线段树」所维护的节点信息进行调整即可。
>
> 线段树维护的节点信息包括：
>
> ls/rs: 分别代表当前节点的左右子节点在线段树数组 tr 中的下标；
> add: 懒标记；
> max: 为当前区间的最大值。
> 对于常规的线段树实现来说，都是一开始就调用 build 操作创建空树，而线段树一般以「满二叉树」的形式用数组存储，因此需要 4 \times n4×n 的空间，并且这些空间在起始 build 空树的时候已经锁死。
>
> 如果一道题仅仅是「值域很大」的离线题（提前知晓所有的询问），我们还能通过「离散化」来进行处理，将值域映射到一个小空间去，从而解决 MLE 问题。
>
> 但对于本题而言，由于「强制在线」的原因，我们无法进行「离散化」，同时值域大小达到 1e91e9 级别，因此如果我们想要使用「线段树」进行求解，只能采取「动态开点」的方式进行。
>
> 动态开点的优势在于，不需要事前构造空树，而是在插入操作 add 和查询操作 query 时根据访问需要进行「开点」操作。由于我们不保证查询和插入都是连续的，因此对于父节点 uu 而言，我们不能通过 u << 1 和 u << 1 | 1 的固定方式进行访问，而要将节点 tr[u]tr[u] 的左右节点所在 tr 数组的下标进行存储，分别记为 ls 和 rs 属性。对于 tr[u].ls = 0tr[u].ls=0 和 tr[u].rs = 0tr[u].rs=0 则是代表子节点尚未被创建，当需要访问到它们，而又尚未创建的时候，则将其进行创建。
>
> 由于存在「懒标记」，线段树的插入和查询都是 \log{n}logn 的，因此我们在单次操作的时候，最多会创建数量级为 \log{n}logn 的点，因此空间复杂度为 O(m\log{n})O(mlogn)，而不是 O(4 \times n)O(4×n)，而开点数的预估需不能仅仅根据 \log{n}logn 来进行，还要对常熟进行分析，才能得到准确的点数上界。
>
> 动态开点相比于原始的线段树实现，本质仍是使用「满二叉树」的形式进行存储，只不过是按需创建区间，如果我们是按照连续段进行查询或插入，最坏情况下仍然会占到 4 \times n4×n 的空间，因此盲猜 \log{n}logn 的常数在 44 左右，保守一点可以直接估算到 66，因此我们可以估算点数为 6 \times m \times \log{n}6×m×logn，其中 n = 1e9n=1e9 和 m = 1e3m=1e3 分别代表值域大小和查询次数。
>
> 当然一个比较实用的估点方式可以「尽可能的多开点数」，利用题目给定的空间上界和我们创建的自定义类（结构体）的大小，尽可能的多开（ Java 的 128M128M 可以开到 5 \times 10^65×10 
> 6
>   以上）。
>
> 作者：AC_OIer
> 链接：https://leetcode.cn/problems/my-calendar-ii/solution/by-ac_oier-a1b3/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



动态开点代码详解

https://leetcode.cn/problems/range-module/solution/by-lfool-eo50/

Node数据结构

```java
class Node {
    // 左右孩子节点
    Node left, right;
    // 当前节点值
    int val;
    // 懒惰标记
    int add;
}
```

下推懒惰标记函数

```java
// leftNum 和 rightNum 表示左右孩子区间的叶子节点数量
// 因为如果是「加减」更新操作的话，需要用懒惰标记的值✖️叶子节点的数量
private void pushDown(Node node, int leftNum, int rightNum) {
    // 动态开点
    if (node.left == null) node.left = new Node();
    if (node.right == null) node.right = new Node();
    // 如果 add 为 0，表示没有标记
    if (node.add == 0) return ;
    // 注意：当前节点加上标记值✖️该子树所有叶子节点的数量
    node.left.val += node.add * leftNum;
    node.right.val += node.add * rightNum;
    // 把标记下推给孩子节点
    // 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖
    node.left.add += node.add;
    node.right.add += node.add;
    // 取消当前节点标记
    node.add = 0;
}
```

实现更新函数

```java
// 在区间 [start, end] 中更新区间 [l, r] 的值，将区间 [l, r] ➕ val
// 对于上面的例子，应该这样调用该函数：update(root, 0, 4, 2, 4, 1)
public void update(Node node, int start, int end, int l, int r, int val) {
    // 找到满足要求的区间
    if (l <= start && end <= r) {
        // 区间节点加上更新值
        // 注意：需要✖️该子树所有叶子节点
        node.val += (end - start + 1) * val;
        // 添加懒惰标记
        // 对区间进行「加减」的更新操作，懒惰标记需要累加，不能直接覆盖
        node.add += val;
        return ;
    }
    int mid = (start + end) >> 1;
    // 下推标记
    // mid - start + 1：表示左孩子区间叶子节点数量
    // end - mid：表示右孩子区间叶子节点数量
    pushDown(node, mid - start + 1, end - mid);
    // [start, mid] 和 [l, r] 可能有交集，遍历左孩子区间
    if (l <= mid) update(node.left, start, mid, l, r, val);
    // [mid + 1, end] 和 [l, r] 可能有交集，遍历右孩子区间
    if (r > mid) update(node.right, mid + 1, end, l, r, val);
    // 向上更新
    pushUp(node);
}
```

线段树的查询

```java
// 在区间 [start, end] 中查询区间 [l, r] 的结果，即 [l ,r] 保持不变
// 对于上面的例子，应该这样调用该函数：query(root, 0, 4, 2, 4)
public int query(Node node, int start, int end, int l, int r) {
    // 区间 [l ,r] 完全包含区间 [start, end]
    // 例如：[2, 4] = [2, 2] + [3, 4]，当 [start, end] = [2, 2] 或者 [start, end] = [3, 4]，直接返回
    if (l <= start && end <= r) return node.val;
    // 把当前区间 [start, end] 均分得到左右孩子的区间范围
    // node 左孩子区间 [start, mid]
    // node 左孩子区间 [mid + 1, end]
    int mid = (start + end) >> 1, ans = 0;
    // 下推标记
    pushDown(node, mid - start + 1, end - mid);
    // [start, mid] 和 [l, r] 可能有交集，遍历左孩子区间
    if (l <= mid) ans += query(node.left, start, mid, l, r);
    // [mid + 1, end] 和 [l, r] 可能有交集，遍历右孩子区间
    if (r > mid) ans += query(node.right, mid + 1, end, l, r);
    // ans 把左右子树的结果都累加起来了，与树的后续遍历同理
    return ans;
}
```

完整

```java
class segment_tree {
    class Node {
        Node left, right;
        int val;
        int add;
    }

    public Node root = new Node();

    public void update(Node node, int start, int end, int l, int r, int val) {
        if (start >= l && end <= r) {
            node.val += (end - start + 1) * val;
            node.add += val;
            return;
        }
        int mid = start + end >> 1;
        push_down(node, mid - start + 1, end - mid);
        if (l <= mid)
            update(node.left, start, mid, l, r, val);
        if (r > mid)
            update(node.right, mid + 1, end, l, r, val);
        push_up(node);
    }

    private void push_down(Node node, int left_num, int right_num) {
        if (node.left == null)
            node.left = new Node();
        if (node.right == null)
            node.right = new Node();
        if (node.add == 0) return;
        node.left.val += node.add * left_num;
        node.right.val += node.add * right_num;
        node.left.add += node.add;
        node.right.add += node.add;
        node.add = 0;
    }

    private void push_up(Node node) {
        node.val = node.left.val + node.right.val;
    }

    public int query(Node node, int start, int end, int l, int r) {
        if (start >= l && end <= r)
            return node.val;
        int mid = start + end >> 1;
        int ans = 0;
        push_down(node, mid - start + 1, end - mid);
        if (l <= mid)
            ans += query(node.left, start, mid, l, r);
        if (r > mid)
            ans += query(node.right, mid + 1, end, l, r);
        return ans;
    }
}
```

## [729. 我的日程安排表 ](https://leetcode.cn/problems/my-calendar-i/)

> 实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。
>
> 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。
>
> 日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start <= x < end 。
>
> 实现 MyCalendar 类：
>
> MyCalendar() 初始化日历对象。
> boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中。
>
>
> 示例：
>
> 输入：
> ["MyCalendar", "book", "book", "book"]
> [[], [10, 20], [15, 25], [20, 30]]
> 输出：
> [null, true, false, true]
>
> 解释：
> MyCalendar myCalendar = new MyCalendar();
> myCalendar.book(10, 20); // return True
> myCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。
> myCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。
>
>
> 提示：
>
> 0 <= start < end <= 109
> 每个测试用例，调用 book 方法的次数最多不超过 1000 次。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/my-calendar-i
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class MyCalendar {
    public int N=(int)1e9;
    segment_tree segment_tree;
    public MyCalendar() {
        segment_tree=new segment_tree();
    }

    public boolean book(int start, int end) {
        int num=segment_tree.query(segment_tree.root, 0,N,start,end-1);
        if(num!=0)
            return false;
        segment_tree.update(segment_tree.root, 0,N,start,end-1,1);
        return true;
    }
}
//线段树
class segment_tree{
    class Node{
        Node left,right;
        int val;
        int add;
    }
    public Node root=new Node();
    public void update(Node node,int start,int end,int l,int r,int val){
        if(start>=l&&end<=r){
            node.val+=(end-start+1)*val;
            node.add+=val;
            return;
        }
        int mid=start+end>>1;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            update(node.left,start,mid,l,r,val);
        if(r>mid)
            update(node.right,mid+1,end,l,r,val);
        push_up(node);
    }
    private void push_down(Node node,int left_num,int right_num){
        if(node.left==null)
            node.left=new Node();
        if(node.right==null)
            node.right=new Node();
        if(node.add==0) return;
        node.left.val+=node.add*left_num;
        node.right.val+=node.add*right_num;
        node.left.add+=node.add;
        node.right.add+=node.add;
        node.add=0;
    }
    private void push_up(Node node){
        node.val=node.left.val+node.right.val;
    }
    public int query(Node node,int start,int end,int l,int r){
        if(start>=l&&end<=r)
            return node.val;
        int mid=start+end>>1;
        int ans=0;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            ans+=query(node.left,start,mid,l,r);
        if(r>mid)
            ans+=query(node.right,mid+1,end,l,r);
        return ans;
    }
}
```

## [731. 我的日程安排表 II](https://leetcode.cn/problems/my-calendar-ii/)

> 实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。
>
> MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start <= x < end。
>
> 当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。
>
> 每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。
>
> 请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)
>
>  
>
> 示例：
>
> MyCalendar();
> MyCalendar.book(10, 20); // returns true
> MyCalendar.book(50, 60); // returns true
> MyCalendar.book(10, 40); // returns true
> MyCalendar.book(5, 15); // returns false
> MyCalendar.book(5, 10); // returns true
> MyCalendar.book(25, 55); // returns true
> 解释： 
> 前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。
> 第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。
> 第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。
> 第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；
> 时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。
>
>
> 提示：
>
> 每个测试用例，调用 MyCalendar.book 函数最多不超过 1000次。
> 调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 [0, 10^9]。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/my-calendar-ii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class MyCalendarTwo {
    int N=(int)1e9;
    segment_tree segment_tree;
    public MyCalendarTwo() {
        segment_tree=new segment_tree();
    }

    public boolean book(int start, int end) {
        int num=segment_tree.query(segment_tree.root,0,N,start,end-1);
        if(num==2) return false;
        segment_tree.update(segment_tree.root,0,N,start,end-1,1);
        return true;
    }
}

class segment_tree{
    class Node{
        Node left,right;
        int val;
        int add;
    }
    public Node root=new Node();
    public void update(Node node,int start,int end,int l,int r,int val){
        if(start>=l&&end<=r){
            node.val+=val;
            node.add+=val;
            return;
        }
        int mid=start+end>>1;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            update(node.left,start,mid,l,r,val);
        if(r>mid)
            update(node.right,mid+1,end,l,r,val);
        push_up(node);
    }
    private void push_down(Node node,int left_num,int right_num){
        if(node.left==null)
            node.left=new Node();
        if(node.right==null)
            node.right=new Node();
        if(node.add==0) return;
        node.left.val+=node.add;
        node.right.val+=node.add;
        node.left.add+=node.add;
        node.right.add+=node.add;
        node.add=0;
    }
    private void push_up(Node node){
        node.val=Math.max(node.left.val,node.right.val);
    }
    public int query(Node node,int start,int end,int l,int r){
        if(start>=l&&end<=r)
            return node.val;
        int mid=start+end>>1;
        int ans=0;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            ans=Math.max(query(node.left,start,mid,l,r),ans);
        if(r>mid)
            ans=Math.max(query(node.right,mid+1,end,l,r),ans);
        return ans;
    }
}
/**
 * Your MyCalendarTwo object will be instantiated and called as such:
 * MyCalendarTwo obj = new MyCalendarTwo();
 * boolean param_1 = obj.book(start,end);
 */
```

## [732. 我的日程安排表 III](https://leetcode.cn/problems/my-calendar-iii/)

> 当 k 个日程安排有一些时间上的交叉时（例如 k 个日程安排都在同一时间内），就会产生 k 次预订。
>
> 给你一些日程安排 [start, end) ，请你在每个日程安排添加后，返回一个整数 k ，表示所有先前日程安排会产生的最大 k 次预订。
>
> 实现一个 MyCalendarThree 类来存放你的日程安排，你可以一直添加新的日程安排。
>
> MyCalendarThree() 初始化对象。
> int book(int start, int end) 返回一个整数 k ，表示日历中存在的 k 次预订的最大值。
>
>
> 示例：
>
> 输入：
> ["MyCalendarThree", "book", "book", "book", "book", "book", "book"]
> [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
> 输出：
> [null, 1, 1, 2, 3, 3, 3]
>
> 解释：
> MyCalendarThree myCalendarThree = new MyCalendarThree();
> myCalendarThree.book(10, 20); // 返回 1 ，第一个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
> myCalendarThree.book(50, 60); // 返回 1 ，第二个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
> myCalendarThree.book(10, 40); // 返回 2 ，第三个日程安排 [10, 40) 与第一个日程安排相交，所以最大 k 次预订是 2 次预订。
> myCalendarThree.book(5, 15); // 返回 3 ，剩下的日程安排的最大 k 次预订是 3 次预订。
> myCalendarThree.book(5, 10); // 返回 3
> myCalendarThree.book(25, 55); // 返回 3
>
>
> 提示：
>
> 0 <= start < end <= 109
> 每个测试用例，调用 book 函数最多不超过 400次
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/my-calendar-iii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class MyCalendarThree {
    int N=(int)1e9;
    segment_tree segment_tree;
    public MyCalendarThree() {
        segment_tree=new segment_tree();
    }

    public int book(int start, int end) {
        segment_tree.update(segment_tree.root, 0,N,start,end-1,1);
        return segment_tree.root.val;
    }
}

class segment_tree{
    class Node{
        Node left,right;
        int val;
        int add;
    }
    public Node root=new Node();
    public void update(Node node,int start,int end,int l,int r,int val){
        if(start>=l&&end<=r){
            node.val+=val;
            node.add+=val;
            return;
        }
        int mid=start+end>>1;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            update(node.left,start,mid,l,r,val);
        if(r>mid)
            update(node.right,mid+1,end,l,r,val);
        push_up(node);
    }
    private void push_down(Node node,int left_num,int right_num){
        if(node.left==null)
            node.left=new Node();
        if(node.right==null)
            node.right=new Node();
        if(node.add==0) return;
        node.left.val+=node.add;
        node.right.val+=node.add;
        node.left.add+=node.add;
        node.right.add+=node.add;
        node.add=0;
    }
    private void push_up(Node node){
        node.val=Math.max(node.left.val,node.right.val);
    }
    public int query(Node node,int start,int end,int l,int r){
        if(start>=l&&end<=r)
            return node.val;
        int mid=start+end>>1;
        int ans=0;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            ans=Math.max(query(node.left,start,mid,l,r),ans);
        if(r>mid)
            ans=Math.max(query(node.right,mid+1,end,l,r),ans);
        return ans;
    }
}
```



## [715. Range 模块](https://leetcode.cn/problems/range-module/)

> Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 半开区间 的范围并查询它们。
>
> 半开区间 [left, right) 表示所有 left <= x < right 的实数 x 。
>
> 实现 RangeModule 类:
>
> RangeModule() 初始化数据结构的对象。
> void addRange(int left, int right) 添加 半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。
> boolean queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true ，否则返回 false 。
> void removeRange(int left, int right) 停止跟踪 半开区间 [left, right) 中当前正在跟踪的每个实数。
>
>
> 示例 1：
>
> 输入
> ["RangeModule", "addRange", "removeRange", "queryRange", "queryRange", "queryRange"]
> [[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]
> 输出
> [null, null, null, true, false, true]
>
> 解释
> RangeModule rangeModule = new RangeModule();
> rangeModule.addRange(10, 20);
> rangeModule.removeRange(14, 16);
> rangeModule.queryRange(10, 14); 返回 true （区间 [10, 14) 中的每个数都正在被跟踪）
> rangeModule.queryRange(13, 15); 返回 false（未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）
> rangeModule.queryRange(16, 17); 返回 true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪）
>
>
> 提示：
>
> 1 <= left < right <= 109
> 在单个测试用例中，对 addRange 、  queryRange 和 removeRange 的调用总数不超过 104 次
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/range-module
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class RangeModule {
    public int N=(int) 1e9;
    segment_tree segment_tree;
    public RangeModule() {
        segment_tree=new segment_tree();
    }

    public void addRange(int left, int right) {
        segment_tree.update(segment_tree.root,1,N,left,right-1,1);
    }

    public boolean queryRange(int left, int right) {
        return segment_tree.query(segment_tree.root, 1,N,left,right-1);
    }

    public void removeRange(int left, int right) {
        segment_tree.update(segment_tree.root, 1,N,left,right-1,-1);
    }
}
class segment_tree{
    class Node{
        Node left,right;
        boolean cover;
        int add;
    }
    public Node root=new Node();
    public void update(Node node,int start,int end,int l,int r,int val){
        if(start>=l&&end<=r){
            node.cover=val==1;
            node.add=val;
            return;
        }
        int mid=start+end>>1;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            update(node.left,start,mid,l,r,val);
        if(r>mid)
            update(node.right,mid+1,end,l,r,val);
        push_up(node);
    }
    private void push_down(Node node,int left_num,int right_num){
        if(node.left==null)
            node.left=new Node();
        if(node.right==null)
            node.right=new Node();
        if(node.add==0) return;
        node.left.cover=node.add==1;
        node.right.cover=node.add==1;
        node.left.add=node.add;
        node.right.add=node.add;
        node.add=0;
    }
    private void push_up(Node node){
        node.cover=node.left.cover&&node.right.cover;
    }
    public boolean query(Node node,int start,int end,int l,int r){
        if(start>=l&&end<=r)
            return node.cover;
        int mid=start+end>>1;
        boolean ans=true;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            ans=ans&&query(node.left,start,mid,l,r);
        if(r>mid)
            ans=ans&&query(node.right,mid+1,end,l,r);
        return ans;
    }
}
```

## [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)

> 给你一个数组 nums ，请你完成两类查询。
>
> 其中一类查询要求 更新 数组 nums 下标对应的值
> 另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left <= right
> 实现 NumArray 类：
>
> NumArray(int[] nums) 用整数数组 nums 初始化对象
> void update(int index, int val) 将 nums[index] 的值 更新 为 val
> int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]）
>
>
> 示例 1：
>
> 输入：
> ["NumArray", "sumRange", "update", "sumRange"]
> [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
> 输出：
> [null, 9, null, 8]
>
> 解释：
> NumArray numArray = new NumArray([1, 3, 5]);
> numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
> numArray.update(1, 2);   // nums = [1,2,5]
> numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
>
>
> 提示：
>
> 1 <= nums.length <= 3 * 104
> -100 <= nums[i] <= 100
> 0 <= index < nums.length
> -100 <= val <= 100
> 0 <= left <= right < nums.length
> 调用 update 和 sumRange 方法次数不大于 3 * 104 
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/range-sum-query-mutable
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class NumArray {
    int N=(int) 1e9;
    segment_tree segment_tree;
    public NumArray(int[] nums) {
        segment_tree=new segment_tree();
        int n=nums.length;
        for(int i=0;i<n;i++)
            segment_tree.update(segment_tree.root, 0,N,i,i,nums[i]);
    }

    public void update(int index, int val) {
        segment_tree.update(segment_tree.root, 0,N,index,index,val);
    }

    public int sumRange(int left, int right) {
        return segment_tree.query(segment_tree.root, 0,N,left,right);
    }
}


//线段树
class segment_tree{
    class Node{
        Node left,right;
        int val;
        int add;
    }
    public Node root=new Node();
    public void update(Node node,int start,int end,int l,int r,int val){
        if(start>=l&&end<=r){
            node.val=(end-start+1)*val;//注意
            node.add+=val;
            return;
        }
        int mid=start+end>>1;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            update(node.left,start,mid,l,r,val);
        if(r>mid)
            update(node.right,mid+1,end,l,r,val);
        push_up(node);
    }
    private void push_down(Node node,int left_num,int right_num){
        if(node.left==null)
            node.left=new Node();
        if(node.right==null)
            node.right=new Node();
        if(node.add==0) return;
        node.left.val+=node.add*left_num;
        node.right.val+=node.add*right_num;
        node.left.add=node.add;//注意
        node.right.add=node.add;//注意
        node.add=0;
    }
    private void push_up(Node node){
        node.val=node.left.val+node.right.val;
    }
    public int query(Node node,int start,int end,int l,int r){
        if(start>=l&&end<=r)
            return node.val;
        int mid=start+end>>1;
        int ans=0;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            ans+=query(node.left,start,mid,l,r);
        if(r>mid)
            ans+=query(node.right,mid+1,end,l,r);
        return ans;
    }
}
```



## [699. 掉落的方块](https://leetcode.cn/problems/falling-squares/)

> 在二维平面上的 x 轴上，放置着一些方块。
>
> 给你一个二维整数数组 positions ，其中 positions[i] = [lefti, sideLengthi] 表示：第 i 个方块边长为 sideLengthi ，其左侧边与 x 轴上坐标点 lefti 对齐。
>
> 每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 另一个正方形的顶边 或者是 x 轴上 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。
>
> 在每个方块掉落后，你必须记录目前所有已经落稳的 方块堆叠的最高高度 。
>
> 返回一个整数数组 ans ，其中 ans[i] 表示在第 i 块方块掉落后堆叠的最高高度。
>
>  
>
> 示例 1：
>
>
> 输入：positions = [[1,2],[2,3],[6,1]]
> 输出：[2,5,5]
> 解释：
> 第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。
> 第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。
> 第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。
> 因此，返回 [2, 5, 5] 作为答案。
> 示例 2：
>
> 输入：positions = [[100,100],[200,100]]
> 输出：[100,100]
> 解释：
> 第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。
> 第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。
> 因此，返回 [100, 100] 作为答案。
> 注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。
>
>
> 提示：
>
> 1 <= positions.length <= 1000
> 1 <= lefti <= 108
> 1 <= sideLengthi <= 106
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/falling-squares
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int N=(int)1e9;
    public List<Integer> fallingSquares(int[][] positions) {
        List<Integer> ans=new ArrayList<>();
        segment_tree segment_tree=new segment_tree();
        int max=0;
        for(int[] i:positions){
            int a=i[0],b=a+i[1];
            int num=segment_tree.query(segment_tree.root, 1,N,a,b-1);
            segment_tree.update(segment_tree.root, 1,N,a,b-1,num+i[1]);
            max=Math.max(max,num+i[1]);
            ans.add(max);
        }

        return ans;
    }
}


//线段树
class segment_tree{
    class Node{
        Node left,right;
        int val;
        int add;
    }
    public Node root=new Node();
    public void update(Node node,int start,int end,int l,int r,int val){
        if(start>=l&&end<=r){
            node.val=val;
            node.add=val;
            return;
        }
        int mid=start+end>>1;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            update(node.left,start,mid,l,r,val);
        if(r>mid)
            update(node.right,mid+1,end,l,r,val);
        push_up(node);
    }
    private void push_down(Node node,int left_num,int right_num){
        if(node.left==null)
            node.left=new Node();
        if(node.right==null)
            node.right=new Node();
        if(node.add==0) return;
        node.left.val=node.add;
        node.right.val=node.add;
        node.left.add=node.add;
        node.right.add=node.add;
        node.add=0;
    }
    private void push_up(Node node){
        node.val=Math.max(node.left.val,node.right.val);
    }
    public int query(Node node,int start,int end,int l,int r){
        if(start>=l&&end<=r)
            return node.val;
        int mid=start+end>>1;
        int ans=0;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            ans=Math.max(query(node.left,start,mid,l,r),ans);
        if(r>mid)
            ans=Math.max(query(node.right,mid+1,end,l,r),ans);
        return ans;
    }
}
```



## [933. 最近的请求次数](https://leetcode.cn/problems/number-of-recent-calls/)

> 写一个 RecentCounter 类来计算特定时间范围内最近的请求。
>
> 请你实现 RecentCounter 类：
>
> RecentCounter() 初始化计数器，请求数为 0 。
> int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
> 保证 每次对 ping 的调用都使用比之前更大的 t 值。
>
>  
>
> 示例 1：
>
> 输入：
> ["RecentCounter", "ping", "ping", "ping", "ping"]
> [[], [1], [100], [3001], [3002]]
> 输出：
> [null, 1, 2, 3, 3]
>
> 解释：
> RecentCounter recentCounter = new RecentCounter();
> recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
> recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
> recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
> recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
>
>
> 提示：
>
> 1 <= t <= 109
> 保证每次对 ping 调用所使用的 t 值都 严格递增
> 至多调用 ping 方法 104 次
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/number-of-recent-calls
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class RecentCounter {
    int N=(int)1e9;
    segment_tree segment_tree;
    public RecentCounter() {
        segment_tree=new segment_tree();
    }

    public int ping(int t) {
        segment_tree.update(segment_tree.root, 1,N,t,t,1);
        return segment_tree.query(segment_tree.root, 1,N,Math.max(0,t-3000),t);
    }
}


//线段树
class segment_tree{
    class Node{
        Node left,right;
        int val;
        int add;
    }
    public Node root=new Node();
    public void update(Node node,int start,int end,int l,int r,int val){
        if(start>=l&&end<=r){
            node.val+=(end-start+1)*val;
            node.add+=val;
            return;
        }
        int mid=start+end>>1;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            update(node.left,start,mid,l,r,val);
        if(r>mid)
            update(node.right,mid+1,end,l,r,val);
        push_up(node);
    }
    private void push_down(Node node,int left_num,int right_num){
        if(node.left==null)
            node.left=new Node();
        if(node.right==null)
            node.right=new Node();
        if(node.add==0) return;
        node.left.val+=node.add*left_num;
        node.right.val+=node.add*right_num;
        node.left.add+=node.add;
        node.right.add+=node.add;
        node.add=0;
    }
    private void push_up(Node node){
        node.val=node.left.val+node.right.val;
    }
    public int query(Node node,int start,int end,int l,int r){
        if(start>=l&&end<=r)
            return node.val;
        int mid=start+end>>1;
        int ans=0;
        push_down(node,mid-start+1,end-mid);
        if(l<=mid)
            ans+=query(node.left,start,mid,l,r);
        if(r>mid)
            ans+=query(node.right,mid+1,end,l,r);
        return ans;
    }
}
```

## [2407. 最长递增子序列 II](https://leetcode.cn/problems/longest-increasing-subsequence-ii/)

> 给你一个整数数组 nums 和一个整数 k 。
>
> 找到 nums 中满足以下要求的最长子序列：
>
> 子序列 严格递增
> 子序列中相邻元素的差值 不超过 k 。
> 请你返回满足上述要求的 最长子序列 的长度。
>
> 子序列 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。
>
>  
>
> 示例 1：
>
> 输入：nums = [4,2,1,4,3,4,5,8,15], k = 3
> 输出：5
> 解释：
> 满足要求的最长子序列是 [1,3,4,5,8] 。
> 子序列长度为 5 ，所以我们返回 5 。
> 注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。
> 示例 2：
>
> 输入：nums = [7,4,5,1,8,12,4,7], k = 5
> 输出：4
> 解释：
> 满足要求的最长子序列是 [4,5,8,12] 。
> 子序列长度为 4 ，所以我们返回 4 。
> 示例 3：
>
> 输入：nums = [1,5], k = 1
> 输出：1
> 解释：
> 满足要求的最长子序列是 [1] 。
> 子序列长度为 1 ，所以我们返回 1 。
>
>
> 提示：
>
> 1 <= nums.length <= 105
> 1 <= nums[i], k <= 105
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/longest-increasing-subsequence-ii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int N = (int) 1e9;

    public int lengthOfLIS(int[] nums, int k) {
        int n = nums.length;
        int ans = 0;
        segment_tree segment_tree = new segment_tree();
        for (int i = 0; i < n; i++) {
            int cnt = segment_tree.query(segment_tree.root, 0, N, Math.max(0, nums[i] - k), nums[i] - 1) + 1;//获取到达当前值的最大数量满足的区间里面的最大值
            segment_tree.update(segment_tree.root, 0, N, nums[i], nums[i], cnt);//进行更新，对于覆盖更新需要把+add和*left_num都去掉，用最大值来代替
            ans = Math.max(ans, cnt);
        }

        return ans;
    }
}

class segment_tree {
    class Node {
        Node left, right;
        int val;
        int add;
    }

    public Node root = new Node();

    public void update(Node node, int start, int end, int l, int r, int val) {
        if (start >= l && end <= r) {
            node.val = val;
            node.add = val;
            return;
        }
        int mid = start + end >> 1;
        push_down(node, mid - start + 1, end - mid);
        if (l <= mid)
            update(node.left, start, mid, l, r, val);
        if (r > mid)
            update(node.right, mid + 1, end, l, r, val);
        push_up(node);
    }

    private void push_down(Node node, int left_num, int right_num) {
        if (node.left == null)
            node.left = new Node();
        if (node.right == null)
            node.right = new Node();
        if (node.add == 0) return;
        node.left.val = node.add ;
        node.right.val = node.add;
        node.left.add = node.add;
        node.right.add = node.add;
        node.add = 0;
    }

    private void push_up(Node node) {
        node.val = Math.max(node.left.val, node.right.val);
    }

    public int query(Node node, int start, int end, int l, int r) {
        if (start >= l && end <= r)
            return node.val;
        int mid = start + end >> 1;
        int ans = 0;
        push_down(node, mid - start + 1, end - mid);
        if (l <= mid)
            ans = Math.max(query(node.left, start, mid, l, r), ans);
        if (r > mid)
            ans = Math.max(query(node.right, mid + 1, end, l, r), ans);
        return ans;
    }
}
```

==线段树总结：==

再次强调一遍：上面给出的模版基于求「区间和」以及对区间进行「加减」的更新操作，且为「动态开点」

但是下面给出的题目实战中，有些题目需要对模版进行小小的修改 (很多人问这个问题，这里统一整理汇总一下！！)

对于表示为「区间和」且对区间进行「加减」的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！(这种情况和模版一致！！) 如题目 最近的请求次数
对于表示为「区间和」且对区间进行「覆盖」的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『不需要累加』！！(因为是覆盖操作！！) 如题目 区域和检索 - 数组可修改
对于表示为「区间最值」且对区间进行「加减」的更新操作的情况，我们在更新节点值的时候『不需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！ 如题目 我的日程安排表 I、我的日程安排表 III
注意：对于题目 最近的请求次数 和 区域和检索 - 数组可修改 可以「不用✖️左右孩子区间叶子节点的数量」

为什么？？因为这两个题目是「点更新」，在介绍线段树更新的时候，我们说过：「点更新」和「区间更新」可以合并成一种，「点更新」不就是更新长度为 1 的区间嘛！！

上面两个题目调用更新函数的方式为：update(root, 1, N, t, t, 1); 和 update(root, 0, N, i, i, nums[i]);

由于区间是一个点，所以一定会更新到叶子节点，故可以不用✖️左右孩子区间叶子节点的数量！

作者：lfool
链接：https://leetcode.cn/problems/my-calendar-iii/solution/by-lfool-jnv9/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 树状数组

博客地址：https://blog.csdn.net/flushhip/article/details/79165701

动态前缀和问题的数据结构，大佬们总是把ST表，树状数组，线段树三个东西联系在一起，都是用于解决动态区间问题

```java
	int[]tr;
    int n;
    public int Lowbit(int x) {
        return x & -x;
    }

    public void Add(int x, int u) {
        for (int i = x; i <= n; i += Lowbit(i)) 
            tr[i] += u;
    }

    public int Query(int x) {
        int ans = 0;
        for (int i = x; i > 0; i -= Lowbit(i)) 
            ans += tr[i];
        return ans;
    }

    public int QueryAll(int x, int y){
        return Query(x) - Query(y - 1);
    }
```



```java
public class Main {
    public static int n;
    public static int max_n = 10010;
    public static int[] a;
    public static int[] c;

    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        n=sc.nextInt();
        a=new int[n+1];
        c=new int[n+1];

        for(int i=1;i<=10;i++){
            a[i]=i;
            add(i,a[i]);
        }
        System.out.println(query_all(1,3));
    }

    public static int low_bit(int i) {//c数组的区间长度
        return (-i) & i;
    }

    public static void add(int i, int z) {//点更新。a[i]+z
        for (; i <= n; i += low_bit(i))//更新所有的祖宗
            c[i] += z;
    }

    public static int query(int i) {//前缀和，a[1]~a[i]
        int s = 0;
        for (; i > 0; i -= low_bit(i))//累加所有前驱
            s += c[i];

        return s;
    }

    public static int query_all(int x, int y) {
        return query(y) - query(x - 1);
    }
}
```

## [1395. 统计作战单位数](https://leetcode.cn/problems/count-number-of-teams/)

>  n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。
>
> 每 3 个士兵可以组成一个作战单位，分组规则如下：
>
> 从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k]
> 作战单位需满足： rating[i] < rating[j] < rating[k] 或者 rating[i] > rating[j] > rating[k] ，其中  0 <= i < j < k < n
> 请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。
>
>  
>
> 示例 1：
>
> 输入：rating = [2,5,3,4,1]
> 输出：3
> 解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。
> 示例 2：
>
> 输入：rating = [2,1,3]
> 输出：0
> 解释：根据题目条件，我们无法组建作战单位。
> 示例 3：
>
> 输入：rating = [1,2,3,4]
> 输出：4
>
>
> 提示：
>
> n == rating.length
> 3 <= n <= 1000
> 1 <= rating[i] <= 10^5
> rating 中的元素都是唯一的
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/count-number-of-teams
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int N = (int) 1e5 + 10;//记录所能走的最远距离
    int[] tr = new int[N];//树状数组
    int n;//原数组长度

    public int low_bits(int x) {//进行lowbit操作
        return -x & x;
    }

    public void add(int x,int u){//进行累加操作
        for(int i=x;i<=N;i+=low_bits(i))
            tr[i]+=u;
    }

    public int query(int x){//进行前缀和查询
        int ans=0;
        for(int i=x;i>0;i-=low_bits(i))
            ans+=tr[i];
        return ans;
    }

    public int numTeams(int[] rating) {
        n=rating.length;//获得当前数组的长度
        int ans=0;//定义结果

        for(int i=0;i<n;i++){//遍历整个数组
            int a=rating[i];//获得左边界
            for(int j=i+1;j<n;j++){
                int b=rating[j];//获得右边界
                if(a<b) ans+=query(b-1)-query(a);//求两边界之间的和
                else ans+=query(a-1)-query(b);
                add(b,1);//如果
            }
            for(int j=i+1;j<n;j++)
                add(rating[j],-1);//清空树状
        }

        return ans;
    }
}
```

## [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)

> 给你一个数组 nums ，请你完成两类查询。
>
> 其中一类查询要求 更新 数组 nums 下标对应的值
> 另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left <= right
> 实现 NumArray 类：
>
> NumArray(int[] nums) 用整数数组 nums 初始化对象
> void update(int index, int val) 将 nums[index] 的值 更新 为 val
> int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]）
>
>
> 示例 1：
>
> 输入：
> ["NumArray", "sumRange", "update", "sumRange"]
> [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
> 输出：
> [null, 9, null, 8]
>
> 解释：
> NumArray numArray = new NumArray([1, 3, 5]);
> numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
> numArray.update(1, 2);   // nums = [1,2,5]
> numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
>
>
> 提示：
>
> 1 <= nums.length <= 3 * 104
> -100 <= nums[i] <= 100
> 0 <= index < nums.length
> -100 <= val <= 100
> 0 <= left <= right < nums.length
> 调用 update 和 sumRange 方法次数不大于 3 * 104 
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/range-sum-query-mutable
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class NumArray {
    BIT bit;
    int[] nums;
    public NumArray(int[] nums) {
        int n=nums.length;
        this.nums=nums;
        this.bit=new BIT(nums);
    }

    public void update(int index, int val) {
        int diff=val-nums[index];
        nums[index]=val;
        bit.add(index+1,diff);
    }

    public int sumRange(int left, int right) {
        return bit.query(right+1)- bit.query(left);
    }

}

class BIT{
    int[] tr;
    int n;

    public BIT(int[] input){
        this.n=input.length;
        tr=new int[n+1];
        for(int i=1;i<=n;i++)
            add(i,input[i-1]);
    }
    public int low_bit(int x){
        return x&-x;
    }

    public void add(int x,int u){
        for(int i=x;i<=n;i+=low_bit(i))
            tr[i]+=u;
    }

    public int query(int x){
        int ans=0;
        for(int i=x;i>0;i-=low_bit(i))
            ans+=tr[i];

        return ans;
    }
}
```

## [1649. 通过指令创建有序数组](https://leetcode.cn/problems/create-sorted-array-through-instructions/)

> 给你一个整数数组 instructions ，你需要根据 instructions 中的元素创建一个有序数组。一开始你有一个空的数组 nums ，你需要 从左到右 遍历 instructions 中的元素，将它们依次插入 nums 数组中。每一次插入操作的 代价 是以下两者的 较小值 ：
>
> nums 中 严格小于  instructions[i] 的数字数目。
> nums 中 严格大于  instructions[i] 的数字数目。
> 比方说，如果要将 3 插入到 nums = [1,2,3,5] ，那么插入操作的 代价 为 min(2, 1) (元素 1 和  2 小于 3 ，元素 5 大于 3 ），插入后 nums 变成 [1,2,3,3,5] 。
>
> 请你返回将 instructions 中所有元素依次插入 nums 后的 总最小代价 。由于答案会很大，请将它对 109 + 7 取余 后返回。
>
>  
>
> 示例 1：
>
> 输入：instructions = [1,5,6,2]
> 输出：1
> 解释：一开始 nums = [] 。
> 插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。
> 插入 5 ，代价为 min(1, 0) = 0 ，现在 nums = [1,5] 。
> 插入 6 ，代价为 min(2, 0) = 0 ，现在 nums = [1,5,6] 。
> 插入 2 ，代价为 min(1, 2) = 1 ，现在 nums = [1,2,5,6] 。
> 总代价为 0 + 0 + 0 + 1 = 1 。
> 示例 2:
>
> 输入：instructions = [1,2,3,6,5,4]
> 输出：3
> 解释：一开始 nums = [] 。
> 插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。
> 插入 2 ，代价为 min(1, 0) = 0 ，现在 nums = [1,2] 。
> 插入 3 ，代价为 min(2, 0) = 0 ，现在 nums = [1,2,3] 。
> 插入 6 ，代价为 min(3, 0) = 0 ，现在 nums = [1,2,3,6] 。
> 插入 5 ，代价为 min(3, 1) = 1 ，现在 nums = [1,2,3,5,6] 。
> 插入 4 ，代价为 min(3, 2) = 2 ，现在 nums = [1,2,3,4,5,6] 。
> 总代价为 0 + 0 + 0 + 0 + 1 + 2 = 3 。
> 示例 3：
>
> 输入：instructions = [1,3,3,3,2,4,2,1,2]
> 输出：4
> 解释：一开始 nums = [] 。
> 插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。
> 插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3] 。
> 插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3] 。
> 插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3,3] 。
> 插入 2 ，代价为 min(1, 3) = 1 ，现在 nums = [1,2,3,3,3] 。
> 插入 4 ，代价为 min(5, 0) = 0 ，现在 nums = [1,2,3,3,3,4] 。
> 插入 2 ，代价为 min(1, 4) = 1 ，现在 nums = [1,2,2,3,3,3,4] 。
> 插入 1 ，代价为 min(0, 6) = 0 ，现在 nums = [1,1,2,2,3,3,3,4] 。
> 插入 2 ，代价为 min(2, 4) = 2 ，现在 nums = [1,1,2,2,2,3,3,3,4] 。
> 总代价为 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4 。
>
>
> 提示：
>
> 1 <= instructions.length <= 105
> 1 <= instructions[i] <= 105
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/create-sorted-array-through-instructions
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int mod=(int) 1e9+7;
    public int createSortedArray(int[] instructions) {
        int n=instructions.length;//数组长度
        BIT bit=new BIT(100_0000);//数组中最大的元素数
        int cost=0;//花费数目
        for(int num:instructions){
            int left=bit.query(num-1);//小于num的数量
            int right=bit.query(100_000)- bit.query(num);//大于num的数量
            cost=(cost+Math.min(left,right))%mod;
            bit.add(num,1);//num数+1
        }

        return cost;
    }
}
class BIT{
    int[] pr;//前缀和数组
    public BIT(int N){
        pr=new int[N];//数组的最大长度
    }

    public int low_bit(int x){//进行lowbit操作
        return x&-x;
    }

    public void add(int x,int u){//进行更新操作
        for(x++;x<pr.length;x+=low_bit(x))
            pr[x]+=u;
    }

    public int query(int x){//用于求区间和
        int ans=0;
        for(x++;x>0;x-=low_bit(x))
            ans+=pr[x];

        return ans;
    }

}
```

## [1893. 检查是否区域内所有整数都被覆盖](https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/)

> 给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。
>
> 如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。
>
> 已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti <= x <= endi ，那么我们称整数x 被覆盖了。
>
>  
>
> 示例 1：
>
> 输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
> 输出：true
> 解释：2 到 5 的每个整数都被覆盖了：
> - 2 被第一个区间覆盖。
> - 3 和 4 被第二个区间覆盖。
> - 5 被第三个区间覆盖。
> 示例 2：
>
> 输入：ranges = [[1,10],[10,20]], left = 21, right = 21
> 输出：false
> 解释：21 没有被任何一个区间覆盖。
>
>
> 提示：
>
> 1 <= ranges.length <= 50
> 1 <= starti <= endi <= 50
> 1 <= left <= right <= 50
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean isCovered(int[][] ranges, int left, int right) {
        BIT bit = new BIT(60);
        for (int[] i : ranges) {
            int a = i[0];
            int b = i[1];
            for(int j=a;j<=b;j++)
                bit.add(j,1);
        }

        for(int i=left;i<=right;i++){
            int num=bit.query(i)- bit.query(i-1);
            if(num==0) return false;
        }
        
        return true;
    }
}

class BIT {
    int[] pr;

    public BIT(int N) {
        pr = new int[N];
    }

    public int low_bit(int x) {
        return x & -x;
    }

    public void add(int x, int u) {
        for (x++; x < pr.length; x += low_bit(x))
            pr[x] += u;
    }

    public int query(int x) {
        int ans = 0;
        for (x++; x > 0; x -= low_bit(x))
            ans += pr[x];

        return ans;
    }
}
```

## [1310. 子数组异或查询](https://leetcode.cn/problems/xor-queries-of-a-subarray/)

> 有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。
>
> 对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。
>
> 并返回一个包含给定查询 queries 所有结果的数组。
>
>  
>
> 示例 1：
>
> 输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
> 输出：[2,7,14,8] 
> 解释：
> 数组中元素的二进制表示形式是：
> 1 = 0001 
> 3 = 0011 
> 4 = 0100 
> 8 = 1000 
> 查询的 XOR 值为：
> [0,1] = 1 xor 3 = 2 
> [1,2] = 3 xor 4 = 7 
> [0,3] = 1 xor 3 xor 4 xor 8 = 14 
> [3,3] = 8
> 示例 2：
>
> 输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
> 输出：[8,0,4,4]
>
>
> 提示：
>
> 1 <= arr.length <= 3 * 10^4
> 1 <= arr[i] <= 10^9
> 1 <= queries.length <= 3 * 10^4
> queries[i].length == 2
> 0 <= queries[i][0] <= queries[i][1] < arr.length
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/xor-queries-of-a-subarray
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int N=(int)3e4+10;
    public int[] xorQueries(int[] arr, int[][] queries) {
        int n=queries.length;
        int m=arr.length;
        int[] ans=new int[n];
        BIT bit=new BIT(N);

        for(int i=0;i<m;i++){
            int num=arr[i];
            bit.add(i,num);
        }

        int temp=-1;
        for(int[] i:queries){
            int left=i[0];
            int right=i[1];
            ans[++temp]= bit.query(right)^bit.query(left-1);
        }

        return ans;
    }
}
class BIT{
    int[] tr;
    public BIT(int N){
        tr=new int[N];
    }

    public int low_bit(int x){
        return x&-x;
    }

    public void add(int x,int u){
        for(x++;x<tr.length;x+=low_bit(x))
            tr[x]^=u;
    }

    public int query(int x){
        int ans=0;
        for(x++;x>0;x-=low_bit(x))
            ans^=tr[x];

        return ans;
    }
}
```

## [1409. 查询带键的排列](https://leetcode.cn/problems/queries-on-a-permutation-with-key/)

> 给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）：
>
> 一开始，排列 P=[1,2,3,...,m]。
> 对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 queries[i] 的查询结果。
> 请你以数组形式返回待查数组  queries 的查询结果。
>
>  
>
> 示例 1：
>
> 输入：queries = [3,1,2,1], m = 5
> 输出：[2,1,2,1] 
> 解释：待查数组 queries 处理如下：
> 对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。
> 对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 
> 对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。
> 对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 
> 因此，返回的结果数组为 [2,1,2,1] 。  
> 示例 2：
>
> 输入：queries = [4,1,2,2], m = 4
> 输出：[3,1,2,0]
> 示例 3：
>
> 输入：queries = [7,5,5,8,3], m = 8
> 输出：[6,5,0,7,5]
>
>
> 提示：
>
> 1 <= m <= 10^3
> 1 <= queries.length <= m
> 1 <= queries[i] <= m
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/queries-on-a-permutation-with-key
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int N=1010;
    public int[] processQueries(int[] queries, int m) {
        int n=queries.length;
        BIT bit=new BIT(2*N);

        //_ _ _ _ 1 2 3 4 5
        //_ _ _ 3 1 2 _ 4 4
        int[] pos=new int[m+1];//数值与下标进行配对
        for(int i=1;i<=m;i++){
            pos[i]=n+i;
            bit.add(n+i,1);//将元素的位置为1
        }

        int[] ans=new int[n];
        for(int i=0;i<n;i++){
            int cur=pos[queries[i]];//获得当前值得下标
            bit.add(cur,-1);//将前缀和数组进行更新
            ans[i]= bit.query(cur);//添加进结果中
            cur=n-i;//更新下标
            pos[queries[i]]=cur;//键值对的值进行更新
            bit.add(cur,1);//更新前缀和
        }

        return ans;
    }
}
class BIT{
    int[] tr;
    public BIT(int N){
        tr=new int[N];
    }

    public int low_bit(int x){
        return x&-x;
    }

    public void add(int x,int u){
        for(x++;x<tr.length;x+=low_bit(x))
            tr[x]+=u;
    }

    public int query(int x){
        int ans=0;
        for(x++;x>0;x-=low_bit(x))
            ans+=tr[x];

        return ans;
    }
}
```

## [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

> 给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
>
>  
>
> 示例 1：
>
> 输入：nums = [5,2,6,1]
> 输出：[2,1,1,0] 
> 解释：
> 5 的右侧有 2 个更小的元素 (2 和 1)
> 2 的右侧仅有 1 个更小的元素 (1)
> 6 的右侧有 1 个更小的元素 (1)
> 1 的右侧有 0 个更小的元素
> 示例 2：
>
> 输入：nums = [-1]
> 输出：[0]
> 示例 3：
>
> 输入：nums = [-1,-1]
> 输出：[0,0]
>
>
> 提示：
>
> 1 <= nums.length <= 105
> -104 <= nums[i] <= 104
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/count-of-smaller-numbers-after-self
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class BIT{
    int[] tr;
    public BIT(int N){
        tr=new int[N];
    }

    public int low_bit(int x){
        return x&-x;
    }

    public void add(int x,int u){
        for(x++;x<tr.length;x+=low_bit(x))
            tr[x]+=u;
    }

    public int query(int x){
        int ans=0;
        for(x++;x>0;x-=low_bit(x))
            ans+=tr[x];

        return ans;
    }
}

class Solution {
    int N=10000;
    public List<Integer> countSmaller(int[] nums) {
        int n=nums.length;
        BIT bit=new BIT(100010);
        for(int i=n-1;i>=0;i--)
            nums[i]+=N;

        List<Integer> ans=new ArrayList<>();
        for(int i=n-1;i>=0;i--){
            int num=nums[i];
            bit.add(num,1);
            ans.add(bit.query(num-1));
        }

        Collections.reverse(ans);
        return ans;
    }
}
```

## [面试题 10.10. 数字流的秩](https://leetcode.cn/problems/rank-from-stream-lcci/)

> 假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：
>
> 实现 track(int x) 方法，每读入一个数字都会调用该方法；
>
> 实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。
>
> 注意：本题相对原题稍作改动
>
> 示例:
>
> 输入:
> ["StreamRank", "getRankOfNumber", "track", "getRankOfNumber"]
> [[], [1], [0], [0]]
> 输出:
> [null,0,null,1]
> 提示：
>
> x <= 50000
> track 和 getRankOfNumber 方法的调用次数均不超过 2000 次
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/rank-from-stream-lcci
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class StreamRank {
    BIT bit=new BIT(50010);
    public StreamRank() {

    }

    public void track(int x) {
        bit.add(x,1);
    }

    public int getRankOfNumber(int x) {
        return bit.query(x);
    }
}

class BIT{
    int[] tr;
    public BIT(int N){
        tr=new int[N];
    }

    public int low_bit(int x){
        return x&-x;
    }

    public void add(int x,int u){
        for(x++;x<tr.length;x+=low_bit(x))
            tr[x]+=u;
    }

    public int query(int x){
        int ans=0;
        for(x++;x>0;x-=low_bit(x))
            ans+=tr[x];

        return ans;
    }
}
```

## [1964. 找出到每个位置为止最长的有效障碍赛跑路线](https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/)

> 你打算构建一些障碍赛跑路线。给你一个 下标从 0 开始 的整数数组 obstacles ，数组长度为 n ，其中 obstacles[i] 表示第 i 个障碍的高度。
>
> 对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标  i ，在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度：
>
> 你可以选择下标介于 0 到 i 之间（包含 0 和 i）的任意个障碍。
> 在这条路线中，必须包含第 i 个障碍。
> 你必须按障碍在 obstacles 中的 出现顺序 布置这些障碍。
> 除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。
> 返回长度为 n 的答案数组 ans ，其中 ans[i] 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。
>
>  
>
> 示例 1：
>
> 输入：obstacles = [1,2,3,2]
> 输出：[1,2,3,3]
> 解释：每个位置的最长有效障碍路线是：
> - i = 0: [1], [1] 长度为 1
> - i = 1: [1,2], [1,2] 长度为 2
> - i = 2: [1,2,3], [1,2,3] 长度为 3
> - i = 3: [1,2,3,2], [1,2,2] 长度为 3
> 示例 2：
>
> 输入：obstacles = [2,2,1]
> 输出：[1,2,1]
> 解释：每个位置的最长有效障碍路线是：
> - i = 0: [2], [2] 长度为 1
> - i = 1: [2,2], [2,2] 长度为 2
> - i = 2: [2,2,1], [1] 长度为 1
> 示例 3：
>
> 输入：obstacles = [3,1,5,6,4,2]
> 输出：[1,1,2,3,2,2]
> 解释：每个位置的最长有效障碍路线是：
> - i = 0: [3], [3] 长度为 1
> - i = 1: [3,1], [1] 长度为 1
> - i = 2: [3,1,5], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线
> - i = 3: [3,1,5,6], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线
> - i = 4: [3,1,5,6,4], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线
> - i = 5: [3,1,5,6,4,2], [1,2] 长度为 2
>
>
> 提示：
>
> n == obstacles.length
> 1 <= n <= 105
> 1 <= obstacles[i] <= 107
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {
        int n=obstacles.length;
        int[] stack=new int[n];
        int top=-1;
        int[] ans=new int[n];
        for(int i=0;i<n;i++){
            if(top==-1||obstacles[i]>=stack[top]){
                stack[++top]=obstacles[i];
                ans[i]=top+1;
            }else{
                int l=0,r=top,m=0;
                while (l<r){
                    m=l+(r-l)/2;
                    if(stack[m]<=obstacles[i])
                        l=m+1;
                    else r=m;
                }
                stack[r]=obstacles[i];
                ans[i]=l+1;
            }
        }
        
        return ans;
    }
}
```

解法2

```java
class Solution {
    List<Integer> stack;
    int[] ans;
    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {
        int n=obstacles.length;
        stack=new ArrayList<>();
        ans=new int[n];

        for(int i=0;i<n;i++){
            if(stack.size()==0||stack.get(stack.size()-1)<=obstacles[i]){
                stack.add(obstacles[i]);
                ans[i]=stack.size();
            }else{
                int index=binary_search(obstacles[i]);
                stack.set(index,obstacles[i]);
                ans[i]=++index;
            }
        }

        return ans;
    }
    public int binary_search(int x){
        int l=0,r=stack.size()-1;
        while (l<r){
            int mid=l+(r-l)/2;
            if(stack.get(mid)<=x){
                l=mid+1;
            }else r=mid;
        }

        return l;
    }
}

```

## [2179. 统计数组中好三元组数目](https://leetcode.cn/problems/count-good-triplets-in-an-array/)

> 给你两个下标从 0 开始且长度为 n 的整数数组 nums1 和 nums2 ，两者都是 [0, 1, ..., n - 1] 的 排列 。
>
> 好三元组 指的是 3 个 互不相同 的值，且它们在数组 nums1 和 nums2 中出现顺序保持一致。换句话说，如果我们将 pos1v 记为值 v 在 nums1 中出现的位置，pos2v 为值 v 在 nums2 中的位置，那么一个好三元组定义为 0 <= x, y, z <= n - 1 ，且 pos1x < pos1y < pos1z 和 pos2x < pos2y < pos2z 都成立的 (x, y, z) 。
>
> 请你返回好三元组的 总数目 。
>
>  
>
> 示例 1：
>
> 输入：nums1 = [2,0,1,3], nums2 = [0,1,2,3]
> 输出：1
> 解释：
> 总共有 4 个三元组 (x,y,z) 满足 pos1x < pos1y < pos1z ，分别是 (2,0,1) ，(2,0,3) ，(2,1,3) 和 (0,1,3) 。
> 这些三元组中，只有 (0,1,3) 满足 pos2x < pos2y < pos2z 。所以只有 1 个好三元组。
> 示例 2：
>
> 输入：nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
> 输出：4
> 解释：总共有 4 个好三元组 (4,0,3) ，(4,0,2) ，(4,1,3) 和 (4,1,2) 。
>
>
> 提示：
>
> n == nums1.length == nums2.length
> 3 <= n <= 105
> 0 <= nums1[i], nums2[i] <= n - 1
> nums1 和 nums2 是 [0, 1, ..., n - 1] 的排列。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/count-good-triplets-in-an-array
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public long goodTriplets(int[] nums1, int[] nums2) {
        int n=nums1.length;
        BIT bit=new BIT(n+10);
        HashMap<Integer,Integer> hashMap=new HashMap<>();
        for(int i=0;i<n;i++)
            hashMap.put(nums1[i],i);
        for(int i=0;i<n;i++)
            nums2[i]=hashMap.get(nums2[i]);

        long ans=0;
        for(int i=0;i<n;i++){
            int num=nums2[i];
            int l=bit.query(num);
            int r=n-(num+1)-(i-l);
            ans+=1l*l*r;
            bit.add(num,1);
        }

        return ans;
    }
}
class BIT{
    int[] tr;
    public BIT(int N){
        tr=new int[N];
    }

    public int low_bit(int x){
        return x&-x;
    }

    public void add(int x,int u){
        for(x++;x<tr.length;x+=low_bit(x))
            tr[x]+=u;
    }

    public int query(int x){
        int ans=0;
        for(x++;x>0;x-=low_bit(x))
            ans+=tr[x];

        return ans;
    }
}
```

```
//将nums1看做是正序，重新映射，转换成大于当前的数和小于当前的数的数目
4 0 1 3 2->0 1 2 3 4
4 1 0 2 3->0 2 1 4 3
树状数组求前缀和：【边遍历边添加】
1 2 3 4 5
        1
  1
1 
    1
      1
满足的条件：由于nums1是正序【0 1 2 3 4 4 ...】
因此对于遍历num2的每一个元素i，左边的小于i，右边的大于i才是满足情况的
```











# 滚动哈希

![image-20220822233400852](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220822233400852.png)



# 双向BFS

> 模板

```java
d1、d2 为两个方向的队列
m1、m2 为两个方向的哈希表，记录每个节点距离起点的
    
// 只有两个队列都不空，才有必要继续往下搜索
// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点
while(!d1.isEmpty() && !d2.isEmpty()) {
    if (d1.size() < d2.size()) {
        update(d1, m1, m2);
    } else {
        update(d2, m2, m1);
    }
}

// update 为将当前队列 d 中包含的元素取出，进行「一次完整扩展」的逻辑（按层拓展）
void update(Deque d, Map cur, Map other) {}
```



## [815. 公交路线](https://leetcode.cn/problems/bus-routes/)

> 给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
>
> 例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
> 现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
>
> 求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。
>
>  
>
> 示例 1：
>
> 输入：routes = [[1,2,7],[3,6,7]], source = 1, target = 6
> 输出：2
> 解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 
> 示例 2：
>
> 输入：routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
> 输出：-1
>
>
> 提示：
>
> 1 <= routes.length <= 500.
> 1 <= routes[i].length <= 105
> routes[i] 中的所有值 互不相同
> sum(routes[i].length) <= 105
> 0 <= routes[i][j] < 106
> 0 <= source, target < 106
> 通过次数32,975提交次数74,959
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/bus-routes
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

单向BFS，下标作为区间标号

```java
class Solution {
    public int numBusesToDestination(int[][] routes, int source, int target) {
        if(source==target) return 0;//位置相同，返回0
        Map<Integer,Set<Integer>> map=new HashMap<>();//车站-线路
        Deque<Integer> deque=new LinkedList<>();//线路
        Map<Integer,Integer> m=new HashMap<>();//线路-距离
        int n=routes.length;
        for(int i=0;i<n;i++){
            for(int station:routes[i]){//将车站与线路进行连接
                if(station==source){//如果当前节点是源节点，就加入到队列中，更新距离初值
                    deque.offer(i);
                    m.put(i,1);
                }
                map.computeIfAbsent(station,key->new HashSet<>()).add(i);//进行联系
            }
        }

        while (!deque.isEmpty()){//BFS进行扩散
            int poll=deque.poll();
            int step=m.get(poll);//获得当前步数
            for(int station:routes[poll]){
                if(station==target) return step;//如果当前路线中有结点，就返回步数
                for(int i:map.getOrDefault(station,new HashSet<>())){//向队列中添加元素
                    if(!m.containsKey(i)){
                        m.put(i,step+1);
                        deque.add(i);
                    }
                }
            }
        }
        
        return -1;//找不到结果就返回
    }
}
```

## [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

> 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -> s1 -> s2 -> ... -> sk：
>
> 每一对相邻的单词只差一个字母。
>  对于 1 <= i <= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。
> sk == endWord
> 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。
>
>
> 示例 1：
>
> 输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
> 输出：5
> 解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
> 示例 2：
>
> 输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
> 输出：0
> 解释：endWord "cog" 不在字典中，所以无法进行转换。
>
>
> 提示：
>
> 1 <= beginWord.length <= 10
> endWord.length == beginWord.length
> 1 <= wordList.length <= 5000
> wordList[i].length == beginWord.length
> beginWord、endWord 和 wordList[i] 由小写英文字母组成
> beginWord != endWord
> wordList 中的所有字符串 互不相同
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/word-ladder
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    String s, e;
    Set<String> set = new HashSet<>();

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        s = beginWord;
        e = endWord;
        for (String i : wordList) set.add(i);
        if (!set.contains(e)) return 0;
        int ans = bfs();
        return ans == -1 ? 0 : ans + 1;
    }

    public int bfs() {
        Deque<String> deque1 = new LinkedList<>();
        Deque<String> deque2 = new LinkedList<>();
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        deque1.add(s);
        map1.put(s, 0);
        deque2.add(e);
        map2.put(e, 0);

        while (!deque1.isEmpty() && !deque2.isEmpty()) {
            int t=-1;
            if(deque1.size()<=deque2.size()){
                t=update(deque1,map1,map2);
            }else {
                t=update(deque2,map2,map1);
            }
            if(t!=-1) return t;
        }

        return -1;
    }

    public int update(Deque<String> deque,Map<String,Integer> cur,Map<String,Integer> other){
        int m=deque.size();
        while (m-->0){
            String poll=deque.poll();
            int n=poll.length();

            for(int i=0;i<n;i++){
                for(int j=0;j<26;j++){
                    String sub=poll.substring(0,i)+String.valueOf((char) ('a'+j))+poll.substring(i+1);

                    if(set.contains(sub)){
                        if(cur.containsKey(sub)&&cur.get(sub)<=cur.get(poll)+1) continue;

                        if(other.containsKey(sub)){
                            return cur.get(poll)+1+other.get(sub);
                        }else {
                            deque.offer(sub);
                            cur.put(sub,cur.get(poll)+1);
                        }
                    }
                }
            }
        }
        return -1;
    }
}
```

> 主要是解决搜索空间爆炸
>
> 三叶姐的双端BFS

```java
class Solution {
    String s, e;
    Set<String> set = new HashSet<>();
    public int ladderLength(String _s, String _e, List<String> ws) {
        s = _s;
        e = _e;
        // 将所有 word 存入 set，如果目标单词不在 set 中，说明无解
        for (String w : ws) set.add(w);
        if (!set.contains(e)) return 0;
        int ans = bfs();
        return ans == -1 ? 0 : ans + 1;
    }

    int bfs() {
        // d1 代表从起点 beginWord 开始搜索（正向）
        // d2 代表从结尾 endWord 开始搜索（反向）
        Deque<String> d1 = new ArrayDeque<>(), d2 = new ArrayDeque(); 
        
        /*
         * m1 和 m2 分别记录两个方向出现的单词是经过多少次转换而来
         * e.g. 
         * m1 = {"abc":1} 代表 abc 由 beginWord 替换 1 次字符而来
         * m2 = {"xyz":3} 代表 xyz 由 endWord 替换 3 次字符而来
         */
        Map<String, Integer> m1 = new HashMap<>(), m2 = new HashMap<>();
        d1.add(s);
        m1.put(s, 0);
        d2.add(e);
        m2.put(e, 0);
        
        /*
         * 只有两个队列都不空，才有必要继续往下搜索
         * 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点
         * e.g. 
         * 例如，如果 d1 为空了，说明从 beginWord 搜索到底都搜索不到 endWord，反向搜索也没必要进行了
         */
        while (!d1.isEmpty() && !d2.isEmpty()) {
            int t = -1;
            // 为了让两个方向的搜索尽可能平均，优先拓展队列内元素少的方向
            if (d1.size() <= d2.size()) {
                t = update(d1, m1, m2);
            } else {
                t = update(d2, m2, m1);
            }
            if (t != -1) return t;
        }
        return -1;
    }

    // update 代表从 deque 中取出一个单词进行扩展，
    // cur 为当前方向的距离字典；other 为另外一个方向的距离字典
    int update(Deque<String> deque, Map<String, Integer> cur, Map<String, Integer> other) {
        int m = deque.size();
        while (m-- > 0) {
            // 获取当前需要扩展的原字符串
            String poll = deque.pollFirst();
            int n = poll.length();

            // 枚举替换原字符串的哪个字符 i
            for (int i = 0; i < n; i++) {
                // 枚举将 i 替换成哪个小写字母
                for (int j = 0; j < 26; j++) {
                    // 替换后的字符串
                    String sub = poll.substring(0, i) + String.valueOf((char)('a' + j)) + poll.substring(i + 1);
                    if (set.contains(sub)) {
                        // 如果该字符串在「当前方向」被记录过（拓展过），跳过即可
                        if (cur.containsKey(sub) && cur.get(sub) <= cur.get(poll) + 1) continue;

                        // 如果该字符串在「另一方向」出现过，说明找到了联通两个方向的最短路
                        if (other.containsKey(sub)) {
                            return cur.get(poll) + 1 + other.get(sub);
                        } else {
                            // 否则加入 deque 队列
                            deque.addLast(sub);
                            cur.put(sub, cur.get(poll) + 1);
                        }
                    }
                }
            }
        }
        return -1;
    }
}
```

## [1345. 跳跃游戏 IV](https://leetcode.cn/problems/jump-game-iv/)

> 给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。
>
> 每一步，你可以从下标 i 跳到下标 i + 1 、i - 1 或者 j ：
>
> i + 1 需满足：i + 1 < arr.length
> i - 1 需满足：i - 1 >= 0
> j 需满足：arr[i] == arr[j] 且 i != j
> 请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。
>
> 注意：任何时候你都不能跳到数组外面。
>
>  
>
> 示例 1：
>
> 输入：arr = [100,-23,-23,404,100,23,23,23,3,404]
> 输出：3
> 解释：那你需要跳跃 3 次，下标依次为 0 --> 4 --> 3 --> 9 。下标 9 为数组的最后一个元素的下标。
> 示例 2：
>
> 输入：arr = [7]
> 输出：0
> 解释：一开始就在最后一个元素处，所以你不需要跳跃。
> 示例 3：
>
> 输入：arr = [7,6,9,6,9,6,9,7]
> 输出：1
> 解释：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。
>
>
> 提示：
>
> 1 <= arr.length <= 5 * 104
> -108 <= arr[i] <= 108
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/jump-game-iv
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int[] arr;
    int INF=0x3f3f3f3f;//定义为最大值/2
    int n;//数组长度
    Map<Integer,List<Integer>> map=new HashMap<>();
    public int minJumps(int[] arr) {
        this.arr=arr;
        n=arr.length;
        if(n==1) return 0;//如果起点和结点一样，直接返回结果
        for(int i=n-1;i>=0;--i) map.computeIfAbsent(arr[i],key->new ArrayList<>()).add(i);//数值-下标键值对

        Deque<Integer> deque1=new LinkedList<>();//从左侧扩散用的队列
        Deque<Integer> deque2=new LinkedList<>();//从右侧扩散用的队列
        int[] dist1=new int[n];//从起点到某个位置的距离
        int[] dist2=new int[n];//从结点到某个位置的距离

        Arrays.fill(dist1,INF);//距离初始化
        Arrays.fill(dist2,INF);
        deque1.offer(0);//队列初始化
        dist1[0]=0;
        deque2.offer(n-1);
        dist2[n-1]=0;

        while (!deque1.isEmpty()&&!deque2.isEmpty()){
            int t=-1;//定义结果
            if(deque1.size()<=deque2.size()){//先遍历元素少的队列
                t=update(deque1,deque2,dist1,dist2);
            }else {
                t=update(deque2,deque1,dist2,dist1);
            }
            if(t!=-1) return t;
        }

        return 0;
    }

    public int update(Deque<Integer> cur_deque,Deque<Integer> other_deque,int[] cur_dist,int[] other_dist){
        int m=cur_deque.size();//定义队列中元素的个数
        while (m--!=0){//进行遍历
            int t=cur_deque.poll(),step=cur_dist[t];//获得当前元素的下标
            if(t+1<n){//如果可以向前走
                if(other_dist[t+1]!=INF) return step+1+other_dist[t+1];//如果要走的位置已经被deque2遍历过了，就返回到达的距离
                if(cur_dist[t+1]==INF){//判断是否被访问过
                    cur_deque.add(t+1);
                    cur_dist[t+1]=step+1;
                }
            }
            if(t-1>=0){//向后移动一格
                if(other_dist[t-1]!=INF) return step+1+other_dist[t-1];
                if(cur_dist[t-1]==INF){
                    cur_deque.offer(t-1);
                    cur_dist[t-1]=step+1;
                }
            }
            for(int i:map.getOrDefault(arr[t],new ArrayList<>())){//等值跳转:对每个等值的元素赋值为步数，因为需要从每个步数进行bfs运算。+1、-1
                if(other_dist[i]!=INF) return step+1+other_dist[i];
                if(cur_dist[i]==INF){
                    cur_deque.add(i);
                    cur_dist[i]=step+1;
                }
            }
            map.remove(arr[t]);//将该值-下标从map中移除，防止遍下一次遍历

        }

        return -1;
    }
}
```



# 双端队列

![image-20220827195706591](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220827195706591.png)

## [1190. 反转每对括号间的子串](https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/)[1190. 反转每对括号间的子串](https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/)

> 给出一个字符串 s（仅含有小写英文字母和括号）。
>
> 请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。
>
> 注意，您的结果中 不应 包含任何括号。
>
>  
>
> 示例 1：
>
> 输入：s = "(abcd)"
> 输出："dcba"
> 示例 2：
>
> 输入：s = "(u(love)i)"
> 输出："iloveu"
> 解释：先反转子字符串 "love" ，然后反转整个字符串。
> 示例 3：
>
> 输入：s = "(ed(et(oc))el)"
> 输出："leetcode"
> 解释：先反转子字符串 "oc" ，接着反转 "etco" ，然后反转整个字符串。
> 示例 4：
>
> 输入：s = "a(bcdefghijkl(mno)p)q"
> 输出："apmnolkjihgfedcbq"
>
>
> 提示：
>
> 0 <= s.length <= 2000
> s 中只有小写英文字母和括号
> 题目测试用例确保所有括号都是成对出现的
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public String reverseParentheses(String s) {
        int n=s.length();
        char[] cs=s.toCharArray();
        Deque<Character> deque=new ArrayDeque<>();
        for(int i=0;i<n;i++){
            char c=cs[i];
            if(c==')'){
                StringBuilder path=new StringBuilder();
                while (!deque.isEmpty()){
                    if(deque.peekLast()!='('){
                        path.append(deque.pollLast());
                    }else {
                        deque.pollLast();
                        for(int j=0;j<path.length();j++){
                            deque.addLast(path.charAt(j));
                        }
                        break;
                    }
                }
            }else {
                deque.addLast(c);
            }
        }
        StringBuilder sb=new StringBuilder();
        while (!deque.isEmpty()) sb.append(deque.pollFirst());
        return sb.toString();
    }
}
```



# A*算法

## [433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)

> 基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。
>
> 假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。
>
> 例如，"AACCGGTT" --> "AACCGGTA" 就是一次基因变化。
> 另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）
>
> 给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。
>
> 注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。
>
>  
>
> 示例 1：
>
> 输入：start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
> 输出：1
> 示例 2：
>
> 输入：start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
> 输出：2
> 示例 3：
>
> 输入：start = "AAAAACCC", end = "AACCCCCC", bank = ["AAAACCCC","AAACCCCC","AACCCCCC"]
> 输出：3
>
>
> 提示：
>
> start.length == 8
> end.length == 8
> 0 <= bank.length <= 10
> bank[i].length == 8
> start、end 和 bank[i] 仅由字符 ['A', 'C', 'G', 'T'] 组成
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimum-genetic-mutation
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处

```java
class Solution {
    class Node{//存放当前字符串、多少个不同的元素
        String s;
        int val;
        Node(String s){
            this.s=s;
            for(int i=0;i<8;i++){
                if(s.charAt(i)!=T.charAt(i)) val++;
            }
        }
    }

    String S,T;//起始字符串和最终字符串
    char[] items=new char[]{'A','C','G','T'};//能够变换选择的字符串

    public int minMutation(String start, String end, String[] bank) {
        Set<String> set=new HashSet<>();//存放仓库元素
        for(String s:bank) set.add(s);
        S=start;T=end;//进行赋值
        PriorityQueue<Node> q=new PriorityQueue<>((o1,o2)->o1.val-o2.val);//挑选路径短的元素
        Map<String,Integer> map=new HashMap<>();//存放到达当前字符串所走的最短路径
        q.add(new Node(S));//
        map.put(S,0);
        while (!q.isEmpty()){
            Node cur=q.poll();
            char[] cs=cur.s.toCharArray();
            int step=map.get(cur.s);
            for(int i=0;i<8;i++){
                for(char c:items){
                    if(cs[i]==c) continue;
                    char[] clone=cs.clone();
                    clone[i]=c;
                    String sub=String.valueOf(clone);
                    if(!set.contains(sub)) continue;
                    if(sub.equals(T)) return step+1;
                    if(!map.containsKey(sub)||map.get(sub)>step+1){
                        map.put(sub,step+1);
                        q.add(new Node(sub));
                    }
                }
            }
        }
        
        return -1;
    }
}
```

1. 数组转换成字符串：String.valueOf(char[])
2. 字符串相加：String str=str+sub_str
3. Astart的曼哈顿等价于优先队列的实现

## [675. 为高尔夫比赛砍树](https://leetcode.cn/problems/cut-off-trees-for-golf-event/)

> 你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：
>
> 0 表示障碍，无法触碰
> 1 表示地面，可以行走
> 比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度
> 每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。
>
> 你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。
>
> 你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。
>
> 可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg)
>
> 输入：forest = [[1,2,3],[0,0,4],[7,6,5]]
> 输出：6
> 解释：沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg)
>
>
> 输入：forest = [[1,2,3],[0,0,0],[7,6,5]]
> 输出：-1
> 解释：由于中间一行被障碍阻塞，无法访问最下面一行中的树。
> 示例 3：
>
> 输入：forest = [[2,3,4],[0,0,5],[8,7,6]]
> 输出：6
> 解释：可以按与示例 1 相同的路径来砍掉所有的树。
> (0,0) 位置的树，可以直接砍去，不用算步数。
>
>
> 提示：
>
> m == forest.length
> n == forest[i].length
> 1 <= m, n <= 50
> 0 <= forest[i][j] <= 109
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/cut-off-trees-for-golf-event
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int[][] graph;
    int n,m;
    int[] dx=new int[]{-1,0,1,0},dy=new int[]{0,1,0,-1};
    public int cutOffTree(List<List<Integer>> forest) {
        n=forest.size();m=forest.get(0).size();
        graph=new int[n][m];
        List<int[]> list=new ArrayList<>();
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                graph[i][j]=forest.get(i).get(j);
                if(graph[i][j]>1) list.add(new int[]{graph[i][j],i,j});
            }
        }

        Collections.sort(list,(o1,o2)->o1[0]-o2[0]);
        int s_x=0,s_y=0,ans=0;
        for(int[] i:list){
            int nx=i[1],ny=i[2];
            int d=a_start(s_x,s_y,nx,ny);
            if(d==-1) return -1;
            ans+=d;
            s_x=nx;s_y=ny;
        }

        return ans;
    }
    int get_idx(int x,int y){
        return x*m+y;
    }
    int f(int x,int y,int p,int q){
        return Math.abs(x-p)+Math.abs(y-q);
    }
    int a_start(int x,int y,int p,int q){
        if(x==p&&y==q) return 0;
        Map<Integer,Integer> map=new HashMap<>();
        PriorityQueue<int[]> queue=new PriorityQueue<>((o1,o2)->o1[0]-o2[0]);
        queue.add(new int[]{f(x,y,p,q),x,y});
        map.put(get_idx(x,y),0);
        while (!queue.isEmpty()){
            int[] cur=queue.poll();
            int cur_x=cur[1],cur_y=cur[2],step=map.get(get_idx(cur_x,cur_y));
            for(int i=0;i<4;i++){
                int n_x=cur_x+dx[i],n_y=cur_y+dy[i],n_idx=get_idx(n_x,n_y);
                if(n_x<0||n_x>=n||n_y<0||n_y>=m) continue;
                if(graph[n_x][n_y]==0) continue;
                if(n_x==p&&n_y==q) return step+1;
                if(!map.containsKey(n_idx)||map.get(n_idx)>step+1){
                    queue.add(new int[]{step+1+f(n_x,n_y,p,q),n_x,n_y});
                    map.put(n_idx,step+1);
                }
            }
        }
        return -1;
    }
}
```



# 素数

## 素数筛

![image-20220828233113179](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220828233113179.png)

![image-20220828233643692](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220828233643692.png)

## [204. 计数质数](https://leetcode.cn/problems/count-primes/)

> 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。
>
>  
>
> 示例 1：
>
> 输入：n = 10
> 输出：4
> 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
> 示例 2：
>
> 输入：n = 0
> 输出：0
> 示例 3：
>
> 输入：n = 1
> 输出：0
>
>
> 提示：
>
> 0 <= n <= 5 * 106
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/count-primes
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



埃氏筛

```java
class Solution {
    public int countPrimes(int n) {
        int[] is_prim=new int[n];
        Arrays.fill(is_prim,1);
        int ans=0;
        for(int i=2;i<n;i++){
            if(is_prim[i]==1){
                ans++;
                for(long j=1l*i*i;j<n;j+=i){
                    is_prim[(int) j]=0;
                }
            }
        }

        return ans;
    }
}
```

线性筛

```java
class Solution {
    public int countPrimes(int n) {
        List<Integer> primes=new ArrayList<>();
        int[] is_prim=new int[n];
        Arrays.fill(is_prim,1);
        for(int i=2;i<n;i++){
            if(is_prim[i]==1)
                primes.add(i);
            for(int j=0;j<primes.size()&&i*primes.get(j)<n;j++){
                is_prim[i*primes.get(j)]=0;
                if(i%primes.get(j)==0)
                    break;
            }
        }

        return primes.size();
    }
}
```

# 二叉树

## [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

> 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)
>
>
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[20,9],[15,7]]
> 示例 2：
>
> 输入：root = [1]
> 输出：[[1]]
> 示例 3：
>
> 输入：root = []
> 输出：[]
>
>
> 提示：
>
> 树中节点数目在范围 [0, 2000] 内
> -100 <= Node.val <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        int depth = 1;
        Deque<TreeNode> deque = new ArrayDeque<>();
        List<List<Integer>> ans = new ArrayList<>();
        if(root==null) return ans;
        deque.offer(root);

        while (!deque.isEmpty()) {
            int size = deque.size();
            List<Integer> temp = new ArrayList<>();

            for (int i = 0; i < size; i++) {
                if (depth % 2 == 1) {//奇数行
                    TreeNode node = deque.pollFirst();
                    temp.add(node.val);
                    if (node.left != null) {
                        deque.offerLast(node.left);
                    }
                    if (node.right != null) {
                        deque.offerLast(node.right);
                    }
                } else {//偶数行
                    TreeNode node = deque.pollLast();
                    temp.add(node.val);
                    if (node.right != null) {
                        deque.offerFirst(node.right);
                    }
                    if (node.left != null) {
                        deque.offerFirst(node.left);
                    }
                }
            }
            ans.add(temp);
            depth++;
        }

        return ans;
    }
}
```

# 背包问题

![image-20220917095918442](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220917095918442.png)

## \2. 01背包问题

> 有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。
>
> 第 ii 件物品的体积是 vivi，价值是 wiwi。
>
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
> 输出最大价值。
>
> #### 输入格式
>
> 第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。
>
> 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。
>
> #### 输出格式
>
> 输出一个整数，表示最大价值。
>
> #### 数据范围
>
> 0<N,V≤10000<N,V≤1000
> 0<vi,wi≤10000<vi,wi≤1000
>
> #### 输入样例
>
> ```
> 4 5
> 1 2
> 2 4
> 3 4
> 4 5
> ```
>
> #### 输出样例：
>
> ```
> 8
> ```

```java
import java.util.*;

class Main{
    static int N=1010;
    static int[] v=new int[N];
    static int[] w=new int[N];
    static int[][] f=new int[N][N];
    static int n,m;
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        n=sc.nextInt();
        m=sc.nextInt();
        for(int i=1;i<=n;i++){
            v[i]= sc.nextInt();
            w[i]=sc.nextInt();
        }

        for(int i=1;i<=n;i++){
            for(int j=0;j<=m;j++){
                f[i][j]=f[i-1][j];
                if(j>=v[i])
                    f[i][j]=Math.max(f[i][j],f[i-1][j-v[i]]+w[i]);
            }
        }
        System.out.println(f[n][m]);
    }
}
```

1. 由于j是从大到小循环的，假设j = 5； j >= 2; j –; 也就是这一层（第i层）会先算出来f[5],（注意这个时候，第i层正在算f[5], 也就是说第i层没有更新f[4] f[3]，也就是此时的f[4] f[3] 是i - 1层的）那么算f[5]要用到比他更小的f[4]或者f[3]也就是i - 1层的了。
2. 压缩那里看第一次录屏就没看明白，看第二次y总说到第i层的时候由于是从大到小循环，f[j - v[i]]没有被更新过所以还保留了f[i-1][j - v[i]]的值就明白了

![image-20221022234037436](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221022234037436.png)

![image-20221013233759084](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221013233759084.png)

dp优化

```java
import java.util.*;

class Main {
    static int N = 1010;
    static int[] v = new int[N];
    static int[] w = new int[N];
    static int[] f = new int[N];
    static int n, m;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        for (int i = 1; i <= n; i++) {
            v[i] = sc.nextInt();
            w[i] = sc.nextInt();
        }

        for (int i = 1; i <= n; i++) {
            for (int j =m; j >=0; j--) {
                if(j>=v[i])
                    f[j]=Math.max(f[j],f[j-v[i]]+w[i]);
            }   
        }
        System.out.println(f[m]);
    }
}
```

1. j如果是从小到大，那么j-vi用的都是当前层的，而我想要的是上一层的，就可以用j-vi是从大到小，这样就用不了当前层的了

## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

> 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,5,11,5]
> 输出：true
> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。
> 示例 2：
>
> 输入：nums = [1,2,3,5]
> 输出：false
> 解释：数组不能分割成两个元素和相等的子集。
>
>
> 提示：
>
> 1 <= nums.length <= 200
> 1 <= nums[i] <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/partition-equal-subset-sum
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum=Arrays.stream(nums).sum();
        if(sum%2==1) return false;
        sum/=2;
        int n=nums.length;

        boolean[][] dp=new boolean[n+1][sum+1];
        for(int i=0;i<=n;i++)
            dp[i][0]=true;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=sum;j++){
                dp[i][j]=dp[i-1][j];
                if(j>=nums[i-1])
                    dp[i][j] |=dp[i-1][j-nums[i-1]];
            }
        }

        return dp[n][sum];
    }
}
```





## 完全背包

![image-20221023000921520](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221023000921520.png)

![image-20221023001148304](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221023001148304.png)

![image-20221023001322893](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221023001322893.png)

### \3. 完全背包问题

> 有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。
>
> 第 ii 种物品的体积是 vivi，价值是 wiwi。
>
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
> 输出最大价值。
>
> #### 输入格式
>
> 第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。
>
> 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。
>
> #### 输出格式
>
> 输出一个整数，表示最大价值。
>
> #### 数据范围
>
> 0<N,V≤10000<N,V≤1000
> 0<vi,wi≤10000<vi,wi≤1000
>
> #### 输入样例
>
> ```
> 4 5
> 1 2
> 2 4
> 3 4
> 4 5
> ```
>
> #### 输出样例：
>
> ```
> 10
> ```

```java
import java.util.*;

class Main {
    static int N = 1010;
    static int[] v = new int[N];
    static int[] w = new int[N];
    static int[][] f = new int[N][N];
    static int n, m;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        for (int i = 1; i <= n; i++) {
            v[i] = sc.nextInt();
            w[i] = sc.nextInt();
        }

        for (int i = 1; i <= n; i++) {
            for (int j =0; j <=m; j++) {
                f[i][j]=f[i-1][j];
                if(j>=v[i])
                    f[i][j]=Math.max(f[i][j],f[i][j-v[i]]+w[i]);
            }
        }
        System.out.println(f[n][m]);
    }
}
```

dp优化

```
import java.util.*;

class Main {
    static int N = 1010;
    static int[] v = new int[N];
    static int[] w = new int[N];
    static int[] f = new int[N];
    static int n, m;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        for (int i = 1; i <= n; i++) {
            v[i] = sc.nextInt();
            w[i] = sc.nextInt();
        }

        for (int i = 1; i <= n; i++) {
            for (int j =0; j <=m; j++) {
                f[j]=f[j];
                if(j>=v[i])
                    f[j]=Math.max(f[j],f[j-v[i]]+w[i]);
            }
        }
        System.out.println(f[m]);
    }
}
```





# 扫描线

![image-20220919233421555](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220919233421555.png)

![image-20220919233451062](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220919233451062.png)

# 动态规划-博弈类

![image-20220928155920126](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220928155920126.png)

## [486. 预测赢家](https://leetcode.cn/problems/predict-the-winner/)

> 给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。
>
> 玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]），取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。
>
> 如果玩家 1 能成为赢家，返回 true 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true 。你可以假设每个玩家的玩法都会使他的分数最大化。
>
>  3
>
> 示例 1：
>
> 输入：nums = [1,5,2]
> 输出：false
> 解释：一开始，玩家 1 可以从 1 和 2 中进行选择。
> 如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 
> 所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
> 因此，玩家 1 永远不会成为赢家，返回 false 。
> 示例 2：
>
> 输入：nums = [1,5,233,7]
> 输出：true
> 解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。
> 最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。
>
>
> 提示：
>
> 1 <= nums.length <= 20
> 0 <= nums[i] <= 107
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/predict-the-winner
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        Integer[][] memo=new Integer[nums.length][nums.length];
        return dfs(nums,0,nums.length-1,memo)>=0;
    }

    public int dfs(int[] nums,int i,int j,Integer[][] memo){
        if(i>j) return 0;
        if(memo[i][j]!=null) return memo[i][j];
        memo[i][j]=Math.max(nums[i]-dfs(nums,i+1,j,memo),nums[j]-dfs(nums,i,j-1,memo));
        return memo[i][j];
    }
}
```

1. 使用Integer作为数组类型，可以用来确定当期下标是否填充过值
2. 不管是A还是B，都是选最大的`memo[i][j]=Math.max(nums[i]-dfs(nums,i+1,j,memo),nums[j]-dfs(nums,i,j-1,memo));`

## [1025. 除数博弈](https://leetcode.cn/problems/divisor-game/)

> 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。
>
> 最初，黑板上有一个数字 n 。在每个玩家的回合，玩家需要执行以下操作：
>
> 选出任一 x，满足 0 < x < n 且 n % x == 0 。
> 用 n - x 替换黑板上的数字 n 。
> 如果玩家无法执行这些操作，就会输掉游戏。
>
> 只有在爱丽丝在游戏中取得胜利时才返回 true 。假设两个玩家都以最佳状态参与游戏。
>
>  
>
> 示例 1：
>
> 输入：n = 2
> 输出：true
> 解释：爱丽丝选择 1，鲍勃无法进行操作。
> 示例 2：
>
> 输入：n = 3
> 输出：false
> 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
>
>
> 提示：
>
> 1 <= n <= 1000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/divisor-game
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean divisorGame(int n) {
        Boolean[] memo = new Boolean[n + 1];
        return dfs(n, memo);
    }

    public boolean dfs(int n, Boolean[] memo) {
        if (n == 1) return false;
        if (memo[n] != null) return memo[n];
        boolean can_win = false;
        for (int i = 1; i <= n / 2; i++) {
            if (n % i == 0 && !dfs(n - i, memo)) {
                can_win = true;
                break;
            }
        }

        return memo[n] = can_win;
    }
}
```

## [877. 石子游戏](https://leetcode.cn/problems/stone-game/)

> Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。
>
> 游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。
>
> Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。
>
> 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。
>
>  
>
> 示例 1：
>
> 输入：piles = [5,3,4,5]
> 输出：true
> 解释：
> Alice 先开始，只能拿前 5 颗或后 5 颗石子 。
> 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
> 如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。
> 如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。
> 这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。
> 示例 2：
>
> 输入：piles = [3,7,2,3]
> 输出：true
>
>
> 提示：
>
> 2 <= piles.length <= 500
> piles.length 是 偶数
> 1 <= piles[i] <= 500
> sum(piles[i]) 是 奇数
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/stone-game
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        int n=piles.length;
        Integer[][] memo=new Integer[n][n];
        return dfs(piles,0,n-1,memo)>0;
    }

    public int dfs(int[] piles,int start,int end,Integer[][] memo){
        if(start>end) return 0;
        if(memo[start][end]!=null) return memo[start][end];
        memo[start][end]=Math.max(piles[start]-dfs(piles,start+1,end,memo),piles[end]-dfs(piles,start,end-1,memo));
        return memo[start][end];
    }
}
```

dp解法

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        int n=piles.length;
        int[][] dp=new int[n][n];
        for(int i=0;i<n;i++)
            dp[i][i]=piles[i];
        for(int len=1;len<n;len++){
            for(int i=0;i<n-len;i++){
                int j=i+len;
                dp[i][j]=Math.max(piles[i]-dp[i+1][j],piles[j]-dp[i][j-1]);
            }
        }
        return dp[0][n-1]>=0;
    }
}
```



# 动态规划

## [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

> 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
>
> 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
>
> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
>
>  
>
> 示例 1：
>
> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> 示例 2：
>
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
>
>
> 提示：
>
> 1 <= prices.length <= 105
> 0 <= prices[i] <= 104
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans=Integer.MIN_VALUE;
        int pre_min=prices[0];
        int n=prices.length;
        
        for(int i=1;i<n;i++){
            ans=Math.max(ans,prices[i]-pre_min);
            pre_min=Math.min(pre_min,prices[i]);
        }
        
        return Math.max(0,ans);
    }
}
```

## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

> 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
>
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
>
> 返回 你能获得的 最大 利润 。
>
>  
>
> 示例 1：
>
> 输入：prices = [7,1,5,3,6,4]
> 输出：7
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
>      总利润为 4 + 3 = 7 。
> 示例 2：
>
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      总利润为 4 。
> 示例 3：
>
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
>
>
> 提示：
>
> 1 <= prices.length <= 3 * 104
> 0 <= prices[i] <= 104
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans=0;
        int pre_min=prices[0];
        int n=prices.length;
        
        for(int i=1;i<n;i++){
            if(prices[i]>pre_min){
                ans+=prices[i]-pre_min;
                pre_min=prices[i];
            }else{
                pre_min=Math.min(pre_min,prices[i]);
            }
        }
        
        return ans;
    }
}
```

![img](https://labuladong.github.io/algo/images/%e8%82%a1%e7%a5%a8%e9%97%ae%e9%a2%98/1.png)

## [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

> 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
>
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
>  
>
> 示例 1:
>
> 输入：prices = [3,3,5,0,0,3,1,4]
> 输出：6
> 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
> 示例 2：
>
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
>      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
>      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
> 示例 3：
>
> 输入：prices = [7,6,4,3,1] 
> 输出：0 
> 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
> 示例 4：
>
> 输入：prices = [1]
> 输出：0
>
>
> 提示：
>
> 1 <= prices.length <= 105
> 0 <= prices[i] <= 105
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int max_k=2,n=prices.length;
        int[][][] dp=new int[n][max_k+1][2];
        
        for(int i=0;i<n;i++){
            for(int k=max_k;k>=1;k--){
                if(i-1==-1){
                    dp[i][k][0]=0;
                    dp[i][k][1]=-prices[i];
                    continue;
                }
                dp[i][k][0]=Math.max(dp[i-1][k][0],dp[i-1][k][1]+prices[i]);
                dp[i][k][1]=Math.max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i]);
            }
        }
        
        return dp[n-1][max_k][0];
    }
}
```

## \1027. 方格取数

> 设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：
>
> ![2.gif](https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif)
>
> 某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。
>
> 在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。
>
> 此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。
>
> #### 输入格式
>
> 第一行为一个整数N，表示 N×N 的方格图。
>
> 接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。
>
> 行和列编号从 11 开始。
>
> 一行“0 0 0”表示结束。
>
> #### 输出格式
>
> 输出一个整数，表示两条路径上取得的最大的和。
>
> #### 数据范围
>
> N≤10N≤10
>
> #### 输入样例：
>
> ```
> 8
> 2 3 13
> 2 6 6
> 3 5 7
> 4 4 14
> 5 2 21
> 5 6 4
> 6 3 15
> 7 2 14
> 0 0 0
> ```
>
> #### 输出样例：
>
> ```
> 67
> ```

```java
import java.util.*;

public class Main{
    static int N=15;
    static int[][][] f=new int[N+N][N][N];
    static int[][] w=new int[N][N];
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n =sc.nextInt();
        while(true){
            int x=sc.nextInt();
            int y=sc.nextInt();
            int z=sc.nextInt();
            if(x==0&&y==0&&z==0) break;
            w[x][y]=z;
        }
        
        //两个来回，可以看做两条路径同时走，k=i1+j1=i1+j2,最初k=2
        for(int k=2;k<=2*n;k++){
            //i1从1开始走到n
            for(int i1=1;i1<=n;i1++){
                //i2也是从1走到n
                for(int i2=1;i2<=n;i2++){
                    //由于步数一样，根据总步数-x=y
                    int j1=k-i1,j2=k-i2;
                   	//满足要求
                    if(j1>=1&&j1<=n&&j2>=1&&j2<=n){
                        int t=w[i1][j1];
                        if(i1!=i2) t+=w[i2][j2];
                        
                        //第一个下来，第二个人下来
                        f[k][i1][i2]=Math.max(f[k][i1][i2],f[k-1][i1-1][i2-1]+t);						                                                //第一个人从下来，第二个人往右
                        f[k][i1][i2]=Math.max(f[k][i1][i2],f[k-1][i1-1][i2]+t);
                        //第一个人往右，第二个人下来                        
                        f[k][i1][i2]=Math.max(f[k][i1][i2],f[k-1][i1][i2-1]+t);
                        //第一个人往右，第二个人往右                        
                        f[k][i1][i2]=Math.max(f[k][i1][i2],f[k-1][i1][i2]+t);
                    }
                }
            }
        }
        
        System.out.println(f[2*n][n][n]);
    }
}
```


# 周赛

## 274. 周赛

#### [5967. 检查是否所有 A 都在 B 之前](https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/)

> 给你一个 仅 由字符 'a' 和 'b' 组成的字符串  s 。如果字符串中 每个 'a' 都出现在 每个 'b' 之前，返回 true ；否则，返回 false 。
>

```java
class Solution {
    public boolean checkString(String s) {
        int n=s.length();
        //初始化第一个值时，也要进行判断是给数组赋值为零还是1，而不能ans【0】=s.charAt(0)
        if(n==1&&s.charAt(0)=='a') return true;
        int[] ans=new int[n];
        if(s.charAt(0)=='a') ans[0]=1;
        else ans[0]=0;
        for(int i=1;i<n;i++){
            if(s.charAt(i)=='a') ans[i]=1;
            else ans[i]=0;
            if(ans[i-1]<ans[i]) return false;
        }
        return true;
    }
}
```

#### [5968. 银行中的激光束数量](https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/)

> 银行内部的防盗安全装置已经激活。给你一个下标从 **0** 开始的二进制字符串数组 `bank` ，表示银行的平面图，这是一个大小为 `m x n` 的二维矩阵。 `bank[i]` 表示第 `i` 行的设备分布，由若干 `'0'` 和若干 `'1'` 组成。`'0'` 表示单元格是空的，而 `'1'` 表示单元格有一个安全设备。
>
> 对任意两个安全设备而言，**如果****同时** 满足下面两个条件，则二者之间存在 **一个** 激光束：
>
> - 两个设备位于两个 **不同行** ：`r1` 和 `r2` ，其中 `r1 < r2` 。
> - 满足 `r1 < i < r2` 的 **所有** 行 `i` ，都 **没有安全设备** 。
>
> 激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。
>
> 返回银行中激光束的总数量。

``` java
class Solution {
    public int numberOfBeams(String[] bank) {
        int m=bank.length;
        int n=bank[0].length();
        int temp1=0;
        int ans=0;
        for(int i=0;i<n;i++) if(bank[0].charAt(i)=='1') temp1++;
        for(int i=1;i<m;i++){
            int temp2=0;
            for(int j=0;j<n;j++){
                if(bank[i].charAt(j)=='1') temp2++; 
            } 
            //要注意只有当该行`1`的数值大于0，时才进行交换
            if(temp2>0){ans+=temp1*temp2;temp1=temp2;}
        }
        return ans;
    }
}
```

#### [5969. 摧毁小行星](https://leetcode-cn.com/problems/destroying-asteroids/)

> 给你一个整数 mass ，它表示一颗行星的初始质量。再给你一个整数数组 asteroids ，其中 asteroids[i] 是第 i 颗小行星的质量。
>
> 你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。
>
> 如果所有小行星 都 能被摧毁，请返回 true ，否则返回 false 。

```java
class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        long ans=mass;
        for(int i:asteroids){
            if(ans<i) return false;
            else ans+=i;
        }
        return true;
    }
}
```

---

1. 判断能否能吞掉全部，就首先排序，如果从小到大开始排序，能通过，那指定能通过，如果排序之后还不能通过，那无论放哪个位置都是无法通过的
2. 参数用的是int类型，但是对于相加后得到的和就需要用long类型了

## 273. 周赛

### [2119. 反转两次的数字](https://leetcode-cn.com/problems/a-number-after-a-double-reversal/)

> 反转 一个整数意味着倒置它的所有位。
>
>     例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。
>
> 给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。

```java
class Solution {
    public boolean isSameAfterReversals(int num) {
        if(num==0) return true;
        if(num%10==0) return false;
        return true;
    }
}
```

### [2120. 执行所有后缀指令](https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/)

> 现有一个 n x n 大小的网格，左上角单元格坐标 (0, 0) ，右下角单元格坐标 (n - 1, n - 1) 。给你整数 n 和一个整数数组 startPos ，其中 startPos = [startrow, startcol] 表示机器人最开始在坐标为 (startrow, startcol) 的单元格上。
>
> 另给你一个长度为 m 、下标从 0 开始的字符串 s ，其中 s[i] 是对机器人的第 i 条指令：'L'（向左移动），'R'（向右移动），'U'（向上移动）和 'D'（向下移动）。
>
> 机器人可以从 s 中的任一第 i 条指令开始执行。它将会逐条执行指令直到 s 的末尾，但在满足下述条件之一时，机器人将会停止：
>
>     下一条指令将会导致机器人移动到网格外。
>     没有指令可以执行。
>
> 返回一个长度为 m 的数组 answer ，其中 answer[i] 是机器人从第 i 条指令 开始 ，可以执行的 指令数目 。
>

![image-20220108234954891](https://gitee.com/demon_night/images/raw/master/imgs/202201301004314.png)

```java
class Solution {
    public int[] executeInstructions(int n, int[] startPos, String s) {
        int[] ans=new int[s.length()];
        int[] tempans=new int[2];
        tempans[0]=startPos[0];
        tempans[1]=startPos[1];
        for(int i=0;i<s.length();i++){
            int temp=0;
            for(int j=i;j<s.length();j++){
                if(s.charAt(j)=='L'){
                    if(startPos[1]-1>=0)  {startPos[1]--;temp++;}
                    else break;
                }
                if(s.charAt(j)=='R'){
                    if(startPos[1]+1<n)  {startPos[1]++;temp++;}
                    else break;
                }
                if(s.charAt(j)=='U'){
                    if(startPos[0]-1>=0)  {startPos[0]--;temp++;}
                    else break;
                }
                if(s.charAt(j)=='D'){
                    if(startPos[0]+1<n)  {startPos[0]++;temp++;}
                    else break;
                }
            }
            ans[i]=temp;
        startPos[0]=tempans[0];
        startPos[1]=tempans[1];            
        }
        return ans;
    }
}
```

## 68. 双周赛

### [2114. 句子中的最多单词数](https://leetcode-cn.com/problems/maximum-number-of-words-found-in-sentences/)

> 一个 句子 由一些 单词 以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。
>
> 给你一个字符串数组 sentences ，其中 sentences[i] 表示单个 句子 。
>
> 请你返回单个句子里 单词的最多数目 。
>

```java
class Solution {
    public int mostWordsFound(String[] sentences) {
        int n=sentences.length;
        int ans=0;
        for(int i=0;i<n;i++){
            int temp=0;
            for(int j=0;j<sentences[i].length();j++){
                if(sentences[i].charAt(j)==' ') temp++;
            }
            ans=Math.max(ans,temp);
        }
        return ans+1;
    }
}
```



### [2115. 从给定原材料中找到所有可以做出的菜](https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/)

> 你有 n 道不同菜的信息。给你一个字符串数组 recipes 和一个二维字符串数组 ingredients 。第 i 道菜的名字为 recipes[i] ，如果你有它 所有 的原材料 ingredients[i] ，那么你可以 做出 这道菜。一道菜的原材料可能是 另一道 菜，也就是说 ingredients[i] 可能包含 recipes 中另一个字符串。
>
> 同时给你一个字符串数组 supplies ，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。
>
> 请你返回你可以做出的所有菜。你可以以 任意顺序 返回它们。
>
> 注意两道菜在它们的原材料中可能互相包含。
>

```java
class Solution {
    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {
        int n=recipes.length;
        List<String> ans=new ArrayList<>();
        Set<String> s=new HashSet<>();
        for(String temp:supplies) s.add(temp);
        for(int i=0;i<recipes.length;){
            if(s.containsAll(ingredients.get(i))){
                if(s.add(recipes[i])) {//如果添加过该菜就返回false
                    if(ans.add(recipes[i])) i+=-i;//如果添加过该菜就返回false
                }
                else i+=1;
            }
            else i+=1;
        }
        return ans;
    }
}
```

1. 如果能配成该菜，就把该菜添加到配料中、ans中，并且从头开始再看一遍是不是刚才的才作为配料能生成一种新菜
2. 如果能配成该菜，但是该菜添加过配料中【也说明已经添加过ans中】，就继续看能否配成下一个菜
3. 细节：如果该菜添加到过配料就一定添加到ans中过
4. 总结：如果遇到新菜，就返回从新遍历【i+=-i】

> 大佬解法：

```java
class Solution {
    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {
        List<String> res = new ArrayList<>();
        HashSet<String> set = new HashSet<>(Set.of(supplies));
        for (int i = 0; i < recipes.length;) {
            // 核心代码，当已知材料中有这些材料 并且 set中第一次添加该成品菜 则i加-i，目的回到0重新遍历，看是否有刚刚做出的成品菜当作材料能做出的菜。若set中不是第一次添加该成品菜，则+1，继续向后遍历
            i += set.containsAll(ingredients.get(i)) && set.add(recipes[i]) && res.add(recipes[i]) ? -i : 1;
        }
        return res;
    }
```

## 第 275 场周赛

### [5976. 检查是否每一行每一列都包含全部整数](https://leetcode-cn.com/problems/check-if-every-row-and-column-contains-all-numbers/)

> 对一个大小为 n x n 的矩阵而言，如果其每一行和每一列都包含从 1 到 n 的 全部 整数（含 1 和 n），则认为该矩阵是一个 有效 矩阵。
>
> 给你一个大小为 n x n 的整数矩阵 matrix ，请你判断矩阵是否为一个有效矩阵：如果是，返回 true ；否则，返回 false 。
>
> 
>
> 示例 1：
>
> 输入：matrix = [[1,2,3],[3,1,2],[2,3,1]]
> 输出：true
> 解释：在此例中，n = 3 ，每一行和每一列都包含数字 1、2、3 。
> 因此，返回 true 。
>
> 示例 2：
>
> 输入：matrix = [[1,1,1],[1,2,3],[1,2,3]]
> 输出：false
> 解释：在此例中，n = 3 ，但第一行和第一列不包含数字 2 和 3 。
> 因此，返回 false 

```java
class Solution {
    public boolean checkValid(int[][] matrix) {
        int n=matrix.length;
        int[][] array=new int[n][n+1];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                array[i][matrix[i][j]]++;
                if(array[i][matrix[i][j]]>1) return false;
            }
        }
        int[][] arrays=new int[n+1][n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                arrays[matrix[j][i]][i]++;
                if(arrays[matrix[j][i]][i]>1) return false;
            }
        }        
        return true;
    }
}
```

1. 记下该行、列遇到遇到的数的数量，如果大于1，说明有重复，就返回false
2. 注意里面的数值是从1开始的，因此我们存放数值的数组【行或列】就要比矩阵数组大1
3. 行里面没有重复后，判断每列有没有重复的，只有两者同时都没有重复的才返回false

### [5977. 最少交换次数来组合所有的 1 II](https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/)

> 交换 定义为选中一个数组中的两个 互不相同 的位置并交换二者的值。
>
> 环形 数组是一个数组，可以认为 第一个 元素和 最后一个 元素 相邻 。
>
> 给你一个 二进制环形 数组 nums ，返回在 任意位置 将数组中的所有 1 聚集在一起需要的最少交换次数。
>
>  
>
> 示例 1：
>
> 输入：nums = [0,1,0,1,1,0,0]
> 输出：1
> 解释：这里列出一些能够将所有 1 聚集在一起的方案：
> [0,0,1,1,1,0,0] 交换 1 次。
> [0,1,1,1,0,0,0] 交换 1 次。
> [1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。
> 无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。
> 因此，需要的最少交换次数为 1 。
>
> 示例 2：
>
> 输入：nums = [0,1,1,1,0,0,1,1,0]
> 输出：2
> 解释：这里列出一些能够将所有 1 聚集在一起的方案：
> [1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。
> [1,1,1,1,1,0,0,0,0] 交换 2 次。
> 无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。
> 因此，需要的最少交换次数为 2 。
>
> 示例 3：
>
> 输入：nums = [1,1,0,0,1]
> 输出：0
> 解释：得益于数组的环形特性，所有的 1 已经聚集在一起。
> 因此，需要的最少交换次数为 0 。

```java
class Solution {
    public int minSwaps(int[] nums) {
        int n=nums.length;//数组长度
        int one_count=0;//1的总数目
        int ans=n;//用于返回的变量，最大不能超过n
        int count=0;//对窗口中1的数目进行计数
        for(int i:nums) one_count+=i;//计算1的总数目
        for(int r=0;r<one_count;r++){
            count+=nums[r];//形成最初的滑动窗口，查看其中1的个数
        }
        for(int l=0,r=one_count-1;l<n;l++){
            ans=Math.min(ans,one_count-count);//判断0的数目是否小于之前见到的
            count+=nums[++r%n];//右指针r向后移动1位，若为1则加上，为什么用++r：因为r=one_count-1是已经判断过是不是1了
            count-=nums[l];//左指针减去左边的一位，如果左边为1，count【1的数量】就减去1，否则减去0
        }
        return ans;
    }
}
```

1. 找出1的数目，形成固定窗口大小，找到当0最少的时候，就是0需要交换的最小次数
2. 需要注意的是头尾相连，因此左指针最大走到索引为n-1，对于右指针r超过n时这种情况我们可以通过`取模`将其依次放在其位置上

## 第276场周赛

### [5980. 将字符串拆分为若干长度为 k 的组](https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/)

> #### 
>
> 字符串 `s` 可以按下述步骤划分为若干长度为 `k` 的组：
>
> - 第一组由字符串中的前 `k` 个字符组成，第二组由接下来的 `k` 个字符串组成，依此类推。每个字符都能够成为 **某一个** 组的一部分。
> - 对于最后一组，如果字符串剩下的字符 **不足** `k` 个，需使用字符 `fill` 来补全这一组字符。
>
> 注意，在去除最后一个组的填充字符 `fill`（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 `s` 。
>
> 给你一个字符串 `s` ，以及每组的长度 `k` 和一个用于填充的字符 `fill` ，按上述步骤处理之后，返回一个字符串数组，该数组表示 `s` 分组后 **每个组的组成情况** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "abcdefghi", k = 3, fill = "x"
> 输出：["abc","def","ghi"]
> 解释：
> 前 3 个字符是 "abc" ，形成第一组。
> 接下来 3 个字符是 "def" ，形成第二组。
> 最后 3 个字符是 "ghi" ，形成第三组。
> 由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。
> 因此，形成 3 组，分别是 "abc"、"def" 和 "ghi" 。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "abcdefghij", k = 3, fill = "x"
> 输出：["abc","def","ghi","jxx"]
> 解释：
> 与前一个例子类似，形成前三组 "abc"、"def" 和 "ghi" 。
> 对于最后一组，字符串中仅剩下字符 'j' 可以用。为了补全这一组，使用填充字符 'x' 两次。
> 因此，形成 4 组，分别是 "abc"、"def"、"ghi" 和 "jxx" 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 100`
> - `s` 仅由小写英文字母组成
> - `1 <= k <= 100`
> - `fill` 是一个小写英文字母

```java
class Solution {
    public String[] divideString(String s, int k, char fill) {
        int n=k-s.length()%k;
        if(n!=k){
            for(int i=0;i<n;i++){
                s+=fill;
        }   
        }
        String[] array=new String[s.length()/k];
        Arrays.fill(array,"");
        int temp=0;
        for(int i=0;i<s.length();){
            for(int j=i;j<i+k;j++){
                array[temp]+=s.charAt(j);
            }
            temp++;
            i+=k;
        }
        return array;
    }
}
```



### [5194. 得到目标值的最少行动次数](https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/)

> 你正在玩一个整数游戏。从整数 1 开始，期望得到整数 target 。
>
> 在一次行动中，你可以做下述两种操作之一：
>
>     递增，将当前整数的值加 1（即， x = x + 1）。
>     加倍，使当前整数的值翻倍（即，x = 2 * x）。
>
> 在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 maxDoubles 次。
>
> 给你两个整数 target 和 maxDoubles ，返回从 1 开始得到 target 需要的最少行动次数。
>
>  
>
> 示例 1：
>
> 输入：target = 5, maxDoubles = 0
> 输出：4
> 解释：一直递增 1 直到得到 target 。
>
> 示例 2：
>
> 输入：target = 19, maxDoubles = 2
> 输出：7
> 解释：最初，x = 1 。
> 递增 3 次，x = 4 。
> 加倍 1 次，x = 8 。
> 递增 1 次，x = 9 。
> 加倍 1 次，x = 18 。
> 递增 1 次，x = 19 。
>
> 示例 3：
>
> 输入：target = 10, maxDoubles = 4
> 输出：4
> 解释：
> 最初，x = 1 。 
> 递增 1 次，x = 2 。 
> 加倍 1 次，x = 4 。 
> 递增 1 次，x = 5 。 
> 加倍 1 次，x = 10 。 
>
>  
>
> 提示：
>
>     1 <= target <= 109
>     0 <= maxDoubles <= 100
>

```java
class Solution {
    public int minMoves(int target, int maxDoubles) {
        int ans=0;//记录结果
        while(target>1){//当target变成1后截至
            if(maxDoubles>0){//判断是否还有翻倍机会，因为，我们想把翻倍机会用到较大的数
                if(target%2==0){//如果能够被2整除，说明，可以被除2
                    target=target/2;//除2
                    maxDoubles--;//翻倍机会-1
                }
                else{
                    target--;//不能被2整除，只能-1
                }
                ans++;//次数+1
            }
            else{//翻倍机会没了，只能1个1个减了，因此所需次数是当前数-1
                ans+=target-1;//加上1次跳所需要的次数
                target=1;//将target置为1，
            }
        }
        return ans;
    }
}
```

## 第 70 场双周赛

### [5971. 打折购买糖果的最小开销](https://leetcode-cn.com/problems/minimum-cost-of-buying-candies-with-discount/)

> 一家商店正在打折销售糖果。每购买 **两个** 糖果，商店会 **免费** 送一个糖果。
>
> 免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 **较小值** 。
>
> - 比方说，总共有 `4` 个糖果，价格分别为 `1` ，`2` ，`3` 和 `4` ，一位顾客买了价格为 `2` 和 `3` 的糖果，那么他可以免费获得价格为 `1` 的糖果，但不能获得价格为 `4` 的糖果。
>
> 给你一个下标从 **0** 开始的整数数组 `cost` ，其中 `cost[i]` 表示第 `i` 个糖果的价格，请你返回获得 **所有** 糖果的 **最小** 总开销。
>
>  
>
> **示例 1：**
>
> ```
> 输入：cost = [1,2,3]
> 输出：5
> 解释：我们购买价格为 2 和 3 的糖果，然后免费获得价格为 1 的糖果。
> 总开销为 2 + 3 = 5 。这是开销最小的 唯一 方案。
> 注意，我们不能购买价格为 1 和 3 的糖果，并免费获得价格为 2 的糖果。
> 这是因为免费糖果的价格必须小于等于购买的 2 个糖果价格的较小值。
> ```
>
> **示例 2：**
>
> ```
> 输入：cost = [6,5,7,9,2,2]
> 输出：23
> 解释：最小总开销购买糖果方案为：
> - 购买价格为 9 和 7 的糖果
> - 免费获得价格为 6 的糖果
> - 购买价格为 5 和 2 的糖果
> - 免费获得价格为 2 的最后一个糖果
> 因此，最小总开销为 9 + 7 + 5 + 2 = 23 。
> ```
>
> **示例 3：**
>
> ```
> 输入：cost = [5,5]
> 输出：10
> 解释：由于只有 2 个糖果，我们需要将它们都购买，而且没有免费糖果。
> 所以总最小开销为 5 + 5 = 10 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= cost.length <= 100`
> - `1 <= cost[i] <= 100`

```java
class Solution {
    public int minimumCost(int[] cost) {
        int n=cost.length;
        int ans=0;
        if(n==1) return cost[0];
        else if(n==2) return cost[0]+cost[1];
        else{
            Arrays.sort(cost);
            int i;
            for(i=n-1;i>=1;){
                ans+=cost[i]+cost[i-1];
                i-=3;
            }
            if(i==0) ans+=cost[0];
            return ans;
        }
    }
}
```

### [5972. 统计隐藏数组数目](https://leetcode-cn.com/problems/count-the-hidden-sequences/)

> 给你一个下标从 0 开始且长度为 n 的整数数组 differences ，它表示一个长度为 n + 1 的 隐藏 数组 相邻 元素之间的 差值 。更正式的表述为：我们将隐藏数组记作 hidden ，那么 differences[i] = hidden[i + 1] - hidden[i] 。
>
> 同时给你两个整数 lower 和 upper ，它们表示隐藏数组中所有数字的值都在 闭 区间 [lower, upper] 之间。
>
>     比方说，differences = [1, -3, 4] ，lower = 1 ，upper = 6 ，那么隐藏数组是一个长度为 4 且所有值都在 1 和 6 （包含两者）之间的数组。
>         [3, 4, 1, 5] 和 [4, 5, 2, 6] 都是符合要求的隐藏数组。
>         [5, 6, 3, 7] 不符合要求，因为它包含大于 6 的元素。
>         [1, 2, 3, 4] 不符合要求，因为相邻元素的差值不符合给定数据。
>
> 请你返回 符合 要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 0 。
>
>  
>
> 示例 1：
>
> 输入：differences = [1,-3,4], lower = 1, upper = 6
> 输出：2
> 解释：符合要求的隐藏数组为：
> - [3, 4, 1, 5]
> - [4, 5, 2, 6]
> 所以返回 2 。
>
> 示例 2：
>
> 输入：differences = [3,-4,5,1,-2], lower = -4, upper = 5
> 输出：4
> 解释：符合要求的隐藏数组为：
> - [-3, 0, -4, 1, 2, 0]
> - [-2, 1, -3, 2, 3, 1]
> - [-1, 2, -2, 3, 4, 2]
> - [0, 3, -1, 4, 5, 3]
> 所以返回 4 。
>
> 示例 3：
>
> 输入：differences = [4,-7,2], lower = 3, upper = 6
> 输出：0
> 解释：没有符合要求的隐藏数组，所以返回 0 。
>

## 第 277 场周赛

### [5989. 元素计数](https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/)

> 给你一个整数数组 nums ，统计并返回在 nums 中同时具有一个严格较小元素和一个严格较大元素的元素数目。
>
>  
>
> 示例 1：
>
> 输入：nums = [11,7,2,15]
> 输出：2
> 解释：元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。
> 元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。
> 总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。
>
> 示例 2：
>
> 输入：nums = [-3,3,3,90]
> 输出：2
> 解释：元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。
> 由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。
>
>  
>
> 提示：
>
>     1 <= nums.length <= 100
>     -105 <= nums[i] <= 105
>

```java
class Solution {
    public int countElements(int[] nums) {
        Arrays.sort(nums);
        int n=nums.length;
        if(n==1) return 0;
        int min_index=0;
        int max_index=n-1;
        if(nums[max_index]==nums[min_index]) return 0;
        for(int i=1;i<n-1;i++){
            if(nums[i]==nums[0]){
                min_index=Math.max(min_index,i);
            }
            if(nums[i]==nums[n-1]){
                max_index=Math.min(max_index,i);
            }
        }
        return max_index-min_index-1;
    }
}
```

### [5991. 按符号重排数组](https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/)

> 给你一个下标从 **0** 开始的整数数组 `nums` ，数组长度为 **偶数** ，由数目相等的正整数和负整数组成。
>
> 你需要 **重排** `nums` 中的元素，使修改后的数组满足下述条件：
>
> 1. 任意 **连续** 的两个整数 **符号相反**
> 2. 对于符号相同的所有整数，**保留** 它们在 `nums` 中的 **顺序** 。
> 3. 重排后数组以正整数开头。
>
> 重排元素满足上述条件后，返回修改后的数组。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [3,1,-2,-5,2,-4]
> 输出：[3,-2,1,-5,2,-4]
> 解释：
> nums 中的正整数是 [3,1,2] ，负整数是 [-2,-5,-4] 。
> 重排的唯一可行方案是 [3,-2,1,-5,2,-4]，能满足所有条件。
> 像 [1,-2,2,-5,3,-4]、[3,1,2,-2,-5,-4]、[-2,3,-5,1,-4,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [-1,1]
> 输出：[1,-1]
> 解释：
> 1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。
> 所以 nums 重排为 [1,-1] 。
> ```
>
>  
>
> **提示：**
>
> - `2 <= nums.length <= 2 * 105`
> - `nums.length` 是 **偶数**
> - `1 <= |nums[i]| <= 105`
> - `nums` 由 **相等** 数量的正整数和负整数组成

```java
class Solution {
    public int[] rearrangeArray(int[] nums) {
        int n=nums.length;
        int[] a1=new int[n/2];
        int[] a2=new int[n/2];
        int temp1=0;
        int temp2=0;
        for(int i=0;i<n;i++){
            if(nums[i]>0){
                a1[temp1++]=nums[i];
            }
            if(nums[i]<0){
                a2[temp2++]=nums[i];
            }
        }
        int[] ans=new int[n];
        int temp3=0;
        for(int i=0;i<n;i++){
            ans[i++]=a1[temp3];
            ans[i]=a2[temp3++];
        }
        return ans;
    }
}
```

### [5990. 找出数组中的所有孤独数字](https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/)

> 给你一个整数数组 nums 。如果数字 x 在数组中仅出现 一次 ，且没有 相邻 数字（即，x + 1 和 x - 1）出现在数组中，则认为数字 x 是 孤独数字 。
>
> 返回 nums 中的 所有 孤独数字。你可以按 任何顺序 返回答案。
>
>  
>
> 示例 1：
>
> 输入：nums = [10,6,5,8]
> 输出：[10,8]
> 解释：
> - 10 是一个孤独数字，因为它只出现一次，并且 9 和 11 没有在 nums 中出现。
> - 8 是一个孤独数字，因为它只出现一次，并且 7 和 9 没有在 nums 中出现。
> - 5 不是一个孤独数字，因为 6 出现在 nums 中，反之亦然。
> 因此，nums 中的孤独数字是 [10, 8] 。
> 注意，也可以返回 [8, 10] 。
>
> 示例 2：
>
> 输入：nums = [1,3,5,3]
> 输出：[1,5]
> 解释：
> - 1 是一个孤独数字，因为它只出现一次，并且 0 和 2 没有在 nums 中出现。
> - 5 是一个孤独数字，因为它只出现一次，并且 4 和 6 没有在 nums 中出现。
> - 3 不是一个孤独数字，因为它出现两次。
> 因此，nums 中的孤独数字是 [1, 5] 。
> 注意，也可以返回 [5, 1] 。
>
>  
>
> 提示：
>
> ![image-20220123133421619](https://cdn.jsdelivr.net/gh/yzk656/image/202212241932220.png)

```java
class Solution {
    public List<Integer> findLonely(int[] nums) {
        Map<Integer,Integer> m1=new HashMap<>();
        for(int i:nums){
            m1.put(i,m1.getOrDefault(i,0)+1);
        }
        List<Integer> ans=new ArrayList<>();
        for(int i:nums){
            if(m1.get(i)==1){
                if(!(m1.containsKey(i-1)||m1.containsKey(i+1))){
                    ans.add(i);
                }
            }
        }
        return ans;
    }
}
```

1. getOrDefault(key，default_Value):在获取指key对应的value，如果找不到key就返回default_Value
2. 查看集合中是否含有某个key：containsKey()
3. 查看集合中是否含有某个value：containsValue()

## 第 71 场双周赛

### [5984.拆分数位后四位数字的最小和](https://leetcode-cn.com/contest/biweekly-contest-71/problems/minimum-sum-of-four-digit-number-after-splitting-digits/)

> 给你一个四位 **正** 整数 `num` 。请你使用 `num` 中的 **数位** ，将 `num` 拆成两个新的整数 `new1` 和 `new2` 。`new1` 和 `new2` 中可以有 **前导 0** ，且 `num` 中 **所有** 数位都必须使用。
>
> - 比方说，给你 `num = 2932` ，你拥有的数位包括：两个 `2` ，一个 `9` 和一个 `3` 。一些可能的 `[new1, new2]` 数对为 `[22, 93]`，`[23, 92]`，`[223, 9]` 和 `[2, 329]` 。
>
> 请你返回可以得到的 `new1` 和 `new2` 的 **最小** 和。
>
>  
>
> **示例 1：**
>
> ```
> 输入：num = 2932
> 输出：52
> 解释：可行的 [new1, new2] 数对为 [29, 23] ，[223, 9] 等等。
> 最小和为数对 [29, 23] 的和：29 + 23 = 52 。
> ```
>
> **示例 2：**
>
> ```
> 输入：num = 4009
> 输出：13
> 解释：可行的 [new1, new2] 数对为 [0, 49] ，[490, 0] 等等。
> 最小和为数对 [4, 9] 的和：4 + 9 = 13 。
> ```
>
>  
>
> **提示：**
>
> - `1000 <= num <= 9999`

```java
class Solution {
    public int minimumSum(int num) {
        int[] a=new int[4];
        int ans=10000;
        int temp=0;
        int temp1=0;
        int temp2=0;
        while(num>0){
            a[temp++]=num%10;
            num/=10;
        }
        Arrays.sort(a);
        return Math.min(ans,a[0]*10+a[2]+a[1]*10+a[3]);
    }
}
```

### [5985根据给定数字划分数组](https://leetcode-cn.com/contest/biweekly-contest-71/problems/partition-array-according-to-given-pivot/)

> ![image-20220205235131829](https://gitee.com/demon_night/images/raw/master/imgs/202202060051331.png)
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [9,12,5,10,14,3,10], pivot = 10
> 输出：[9,5,3,10,10,12,14]
> 解释：
> 元素 9 ，5 和 3 小于 pivot ，所以它们在数组的最左边。
> 元素 12 和 14 大于 pivot ，所以它们在数组的最右边。
> 小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [9, 5, 3] 和 [12, 14] ，它们在结果数组中的相对顺序需要保留。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [-3,4,3,2], pivot = 2
> 输出：[-3,2,4,3]
> 解释：
> 元素 -3 小于 pivot ，所以在数组的最左边。
> 元素 4 和 3 大于 pivot ，所以它们在数组的最右边。
> 小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [-3] 和 [4, 3] ，它们在结果数组中的相对顺序需要保留。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-106 <= nums[i] <= 106`
> - `pivot` 等于 `nums` 中的一个元素。

```java
class Solution {
    public int[] pivotArray(int[] nums, int pivot) {
        int n=nums.length;
        int[] num=new int[n];
        List<Integer> l=new ArrayList<>();
        for(int i:nums) l.add(i);
        int temp1=0;
        for(int i=0;i<n;i++){
            if(l.get(i)<pivot) {
                num[temp1++]=l.get(i);
            }
        }
        for(int i=0;i<l.size();i++){
            if(l.get(i)==pivot){
                num[temp1++]=l.get(i);
            }
        }
        for(int i=0;i<l.size();i++){
            if(l.get(i)>pivot){
                num[temp1++]=l.get(i);
            }
        }
        return num;
    }
}
```

## 第 279 场周赛

### [对奇偶下标分别排序](https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/) 

> ![image-20220206145748003](https://gitee.com/demon_night/images/raw/master/imgs/202202061557356.png)
>
> **示例 1：**
>
> ```
> 输入：nums = [4,1,2,3]
> 输出：[2,3,4,1]
> 解释：
> 首先，按非递增顺序重排奇数下标（1 和 3）的值。
> 所以，nums 从 [4,1,2,3] 变为 [4,3,2,1] 。
> 然后，按非递减顺序重排偶数下标（0 和 2）的值。
> 所以，nums 从 [4,1,2,3] 变为 [2,3,4,1] 。
> 因此，重排之后形成的数组是 [2,3,4,1] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,1]
> 输出：[2,1]
> 解释：
> 由于只有一个奇数下标和一个偶数下标，所以不会发生重排。
> 形成的结果数组是 [2,1] ，和初始数组一样。 
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 100`
> - `1 <= nums[i] <= 100`

```java
class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n=nums.length;
        int n1,n2;
        if(n%2!=0) {
            n1=n/2+1;
            n2=n/2;
        }else{
            n1=n2=n/2;
        }
        int temp1=0,temp2=0;
        int[] a1=new int[n1];
        int[] a2=new int[n2];
        for(int i=0;i<n;i++){
            a1[temp1++]=nums[i];
            if(++i<n){
                a2[temp2++]=nums[i];
            }
        }
        Arrays.sort(a1);
        Arrays.sort(a2);
        temp1=0;
        for(int i=0;i<n;i++){
            nums[i]=a1[temp1++];
            if(++i<n&&n2>=0){
                nums[i]=a2[--n2];
            }
        }
        return nums;
    }
}
```

### [6001. 重排数字的最小值](https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/)

> 给你一个整数 num 。重排 num 中的各位数字，使其值 最小化 且不含 任何 前导零。
>
> 返回不含前导零且值最小的重排数字。
>
> 注意，重排各位数字后，num 的符号不会改变。
>
>  
>
> 示例 1：
>
> 输入：num = 310
> 输出：103
> 解释：310 中各位数字的可行排列有：013、031、103、130、301、310 。
> 不含任何前导零且值最小的重排数字是 103 。
>
> 示例 2：
>
> 输入：num = -7605
> 输出：-7650
> 解释：-7605 中各位数字的部分可行排列为：-7650、-6705、-5076、-0567。
> 不含任何前导零且值最小的重排数字是 -7650 。
>
>  
>
> 提示：
>
>     -1015 <= num <= 1015
>

```java
class Solution {
    public long smallestNumber(long num) {
        boolean flag=false;
        if(num<0) flag=true;
        
         num=Math.abs(num);
        
        String s=Long.toString(num);
        List<Integer> l=new ArrayList<>();
        for(int i=0;i<s.length();i++){
            l.add(s.charAt(i)-48);
        }
        Collections.sort(l);
        int n=l.size();
        Long ans=0L;
        int temp=0;
        if(!flag){
            for(int i=0;i<n;i++){
                if(l.get(i)!=0){
                    Collections.swap(l,0,i);
                    break;
                }
            }
            for(int i=0;i<n;i++){
                ans=ans*10+l.get(i);
            }
            return ans;
        }else{
            for(int i=n-1;i>=0;i--){
                ans=ans*10+l.get(i);
            }
            return (-1)*ans;            
        }
    }
}
```

- 负数也是个字符，需要对它进行处理

## 第 280 场周赛

### [2169. 得到 0 的操作数](https://leetcode-cn.com/problems/count-operations-to-obtain-zero/)

> 给你两个 **非负** 整数 `num1` 和 `num2` 。
>
> 每一步 **操作** 中，如果 `num1 >= num2` ，你必须用 `num1` 减 `num2` ；否则，你必须用 `num2` 减 `num1` 。
>
> - 例如，`num1 = 5` 且 `num2 = 4` ，应该用 `num1` 减 `num2` ，因此，得到 `num1 = 1` 和 `num2 = 4` 。然而，如果 `num1 = 4`且 `num2 = 5` ，一步操作后，得到 `num1 = 4` 和 `num2 = 1` 。
>
> 返回使 `num1 = 0` 或 `num2 = 0` 的 **操作数** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：num1 = 2, num2 = 3
> 输出：3
> 解释：
> - 操作 1 ：num1 = 2 ，num2 = 3 。由于 num1 < num2 ，num2 减 num1 得到 num1 = 2 ，num2 = 3 - 2 = 1 。
> - 操作 2 ：num1 = 2 ，num2 = 1 。由于 num1 > num2 ，num1 减 num2 。
> - 操作 3 ：num1 = 1 ，num2 = 1 。由于 num1 == num2 ，num1 减 num2 。
> 此时 num1 = 0 ，num2 = 1 。由于 num1 == 0 ，不需要再执行任何操作。
> 所以总操作数是 3 。
> ```
>
> **示例 2：**
>
> ```
> 输入：num1 = 10, num2 = 10
> 输出：1
> 解释：
> - 操作 1 ：num1 = 10 ，num2 = 10 。由于 num1 == num2 ，num1 减 num2 得到 num1 = 10 - 10 = 0 。
> 此时 num1 = 0 ，num2 = 10 。由于 num1 == 0 ，不需要再执行任何操作。
> 所以总操作数是 1 。
> ```
>
>  
>
> - ![image-20220218124732741](https://cdn.jsdelivr.net/gh/yzk656/image/202212241932277.png)

```java
class Solution {
    public int countOperations(int num1, int num2) {
        int ans=0;
        while(!(num1==0||num2==0)){
            if(num1>=num2){
                num1=num1-num2;
            }else{
                num2=num2-num1;
            }
            ans++;
        }
        return ans;
    }
}
```

### [2170. 使数组变成交替数组的最少操作数](https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/)

> #### 
>
> 给你一个下标从 **0** 开始的数组 `nums` ，该数组由 `n` 个正整数组成。
>
> 如果满足下述条件，则数组 `nums` 是一个 **交替数组** ：
>
> - `nums[i - 2] == nums[i]` ，其中 `2 <= i <= n - 1` 。
> - `nums[i - 1] != nums[i]` ，其中 `1 <= i <= n - 1` 。
>
> 在一步 **操作** 中，你可以选择下标 `i` 并将 `nums[i]` **更改** 为 **任一** 正整数。
>
> 返回使数组变成交替数组的 **最少操作数** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [3,1,3,2,4,3]
> 输出：3
> 解释：
> 使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。
> 在这种情况下，操作数为 3 。
> 可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,2,2,2]
> 输出：2
> 解释：
> 使数组变成交替数组的方法之一是将该数组转换为 [1,2,1,2,1].
> 在这种情况下，操作数为 2 。
> 注意，数组不能转换成 [2,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。
> ```
>
> ![image-20220218124936892](https://cdn.jsdelivr.net/gh/yzk656/image/202212241931499.png)

```java
class Solution {
    public int minimumOperations(int[] nums) {
        int n=nums.length;
        HashMap<Integer,Integer> odd_number=new HashMap<>();//存储下标奇数位中每个数值得个数
        HashMap<Integer,Integer> even_number=new HashMap<>();//存储下标偶数位中每个数值得个数
        for(int i=0;i<n;i++) {//遍历整个2数组
            //getOrDefault(key,default_value):如果找不到该key所对应的节点就返回default_value
            if (i % 2 == 0) even_number.put(nums[i], even_number.getOrDefault(nums[i], 0) + 1);
            else odd_number.put(nums[i], odd_number.getOrDefault(nums[i], 0) + 1);
        }
        int[][] odd_max=check(odd_number);//找到数最多、次多的数值
        int[][] even_max=check(even_number);//找到数最多、次多的数值
        if(even_max[0][0]!=odd_max[0][0]) n-=(even_max[0][1]+odd_max[0][1]);//如果奇数位值不等于偶数位值，则减去奇数位和偶数位最多的就得到租少的修改数
        else n-=Math.max(even_max[0][1]+odd_max[1][1],even_max[1][1]+odd_max[0][1]);//如果奇数位最多的值等于偶数位最多的值，所以就要修改偶数位最多的值或者奇数位最多的值，因此寻找“不需要修改的数值【也就是其他数要修改为的数值】”的最大值，总数减去最大值才能得到需要修改数的最小值
        return n;
    }
    int[][] check(HashMap<Integer,Integer> map){
        int[][] max_count=new int[2][2];//第一列存数值，第二列存该数值的个数，第一行存最多的，第二行存次多的
        for(int key:map.keySet()){//遍历整个集合的key
            int val=map.get(key);
            if(val>max_count[0][1]){//如果该值得数目大于之前遇到的
                max_count[1][0]=max_count[0][0];//将之前最多的移到次多的
                max_count[1][1]=max_count[0][1];
                max_count[0][0]=key;//将“最多的”重置为最新的“最多的”
                max_count[0][1]=val;
            }else if(val>max_count[1][1]){//如果比最多的少，比次多的大，则将次多的进行更新
                max_count[1][0]=key;
                max_count[1][1]=val;
            }
        }
        return max_count;//返回得到的数组
    }
}
```

- getOrDefault(key,default_value):如果找不到该key所对应的节点就返回default_value

### [2171. 拿出最少数目的魔法豆](https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/)

> 给你一个 正 整数数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。
>
> 请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少 还有 一颗 魔法豆的袋子）魔法豆的数目 相等 。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。
>
> 请你返回你需要拿出魔法豆的 最少数目。
>
>  
>
> 示例 1：
>
> 输入：beans = [4,1,6,5]
> 输出：4
> 解释：
> - 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。
>   剩下袋子中魔法豆的数目为：[4,0,6,5]
> - 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。
>   剩下袋子中魔法豆的数目为：[4,0,4,5]
> - 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。
>   剩下袋子中魔法豆的数目为：[4,0,4,4]
>   总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。
>   没有比取出 4 个魔法豆更少的方案。
>
> 示例 2：
>
> 输入：beans = [2,10,3,2]
> 输出：7
> 解释：
> - 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。
>   剩下袋子中魔法豆的数目为：[0,10,3,2]
> - 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。
>   剩下袋子中魔法豆的数目为：[0,10,3,0]
> - 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。
>   剩下袋子中魔法豆的数目为：[0,10,0,0]
>   总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。
>   没有比取出 7 个魔法豆更少的方案。
>
> ![image-20220218153405920](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220218153405920.png)

![image-20220218153457503](https://gitee.com/demon_night/images/raw/master/imgs/202202181534358.png)

```java
class Solution {
    public long minimumRemoval(int[] beans) {
        int n=beans.length;
        Long sum=0L;
        for(int i:beans) sum+=i;
        Arrays.sort(beans);
        Long temp=0L,ans=Long.MAX_VALUE;
        for(int i=0;i<n;i++){
            temp=sum-(1L)*(n-i)*beans[i];//注意
            if(temp<ans) ans=temp;
        }
        return ans;
    }
}
```

- 我们最后要达到的最终状态是除了0以外，其他所有豆子都一样的数目，假设这个数目为k。

  每个袋子里有两种情况：

      袋子原来豆子数目bean < k，此时该袋子里豆子要被全部拿走，拿走数目为bean。
      袋子原来豆子数目bean > k，此时该袋子里豆子要被拿走bean - k。

- temp=sum-(1L)*(n-i)*beans[i]：对于一个式子在程序运行时会把结果存到该式子中最大的数据类型，因此如果怕他溢出，就将其乘上一个更大的数据类型，防止溢出

## 第 281 场周赛

### [2180. 统计各位数字之和为偶数的整数个数](https://leetcode-cn.com/problems/count-integers-with-even-digit-sum/)

> #### 
>
> 给你一个正整数 `num` ，请你统计并返回 **小于或等于** `num` 且各位数字之和为 **偶数** 的正整数的数目。
>
> 正整数的 **各位数字之和** 是其所有位上的对应数字相加的结果。
>
>  
>
> **示例 1：**
>
> ```
> 输入：num = 4
> 输出：2
> 解释：
> 只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。    
> ```
>
> **示例 2：**
>
> ```
> 输入：num = 30
> 输出：14
> 解释：
> 只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： 
> 2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= num <= 1000`

```java
class Solution {
    public int countEven(int num) {
        int ans=0;
        for(int i=1;i<=num;i++){
            int temp=i;
            int ans1=0;
            while(temp>0){
                ans1+=temp%10;
                temp/=10;
            }
            if(ans1%2==0) ans++;
        }
        return ans;
    }
}
```

### [2181. 合并零之间的节点](https://leetcode-cn.com/problems/merge-nodes-in-between-zeros/)

> #### 
>
> 给你一个链表的头节点 `head` ，该链表包含由 `0` 分隔开的一连串整数。链表的 **开端** 和 **末尾** 的节点都满足 `Node.val == 0` 。
>
> 对于每两个相邻的 `0` ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 `0` 移除，修改后的链表不应该含有任何 `0` 。
>
>  返回修改后链表的头节点 `head` 。
>
>  
>
> **示例 1：
>  ![img](https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png)**
>
> ```
> 输入：head = [0,3,1,0,4,5,2,0]
> 输出：[4,11]
> 解释：
> 上图表示输入的链表。修改后的链表包含：
> - 标记为绿色的节点之和：3 + 1 = 4
> - 标记为红色的节点之和：4 + 5 + 2 = 11
> ```
>
> **示例 2：
>  ![img](https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png)**
>
> ```
> 输入：head = [0,1,0,3,0,2,2,0]
> 输出：[1,3,4]
> 解释：
> 上图表示输入的链表。修改后的链表包含：
> - 标记为绿色的节点之和：1 = 1
> - 标记为红色的节点之和：3 = 3
> - 标记为黄色的节点之和：2 + 2 = 4
> ```
>
>  
>
> **提示：**
>
> - 列表中的节点数目在范围 `[3, 2 * 105]` 内
> - `0 <= Node.val <= 1000`
> - **不** 存在连续两个 `Node.val == 0` 的节点
> - 链表的 **开端** 和 **末尾** 节点都满足 `Node.val == 0`

```java
class Solution {
    public ListNode mergeNodes(ListNode head) {
        ListNode ans=new ListNode();
        ListNode node=ans;
        int temp=0;
        head=head.next;
        while (head!=null){
            if(head.val!=0) temp+=head.val;
            else{
                node.next=new ListNode(temp);
                node=node.next;
                temp=0;
            }
            head=head.next;
        }
        return ans.next;
    }
}
```

- 对于java的链表来说，可以先建议一个不存val的头节点，然后再建立个指针指向头节点，再有新节点时可以将新节点加到指针的后面，不断的移动指针即可，最终返回头节点的名称的下一项即可

  - ```java
    ListNode ans=new ListNode();
    ListNode node=ans;
    
    node.next=new ListNode(temp);
    
    return ans.next
    ```

### reverse()【用于数组集合】

- reverse函数反转string
- reverse函数反转字符数组

### [2182. 构造限制重复的字符串](https://leetcode-cn.com/problems/construct-string-with-repeat-limit/)

> 给你一个字符串 s 和一个整数 repeatLimit ，用 s 中的字符构造一个新字符串 repeatLimitedString ，使任何字母 连续 出现的次数都不超过 repeatLimit 次。你不必使用 s 中的全部字符。
>
> 返回 字典序最大的 repeatLimitedString 。
>
> 如果在字符串 a 和 b 不同的第一个位置，字符串 a 中的字母在字母表中出现时间比字符串 b 对应的字母晚，则认为字符串 a 比字符串 b 字典序更大 。如果字符串中前 min(a.length, b.length) 个字符都相同，那么较长的字符串字典序更大。
>
>  
>
> 示例 1：
>
> 输入：s = "cczazcc", repeatLimit = 3
> 输出："zzcccac"
> 解释：使用 s 中的所有字符来构造 repeatLimitedString "zzcccac"。
> 字母 'a' 连续出现至多 1 次。
> 字母 'c' 连续出现至多 3 次。
> 字母 'z' 连续出现至多 2 次。
> 因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。
> 该字符串是字典序最大的 repeatLimitedString ，所以返回 "zzcccac" 。
> 注意，尽管 "zzcccca" 字典序更大，但字母 'c' 连续出现超过 3 次，所以它不是一个有效的 repeatLimitedString 。
>
> 示例 2：
>
> 输入：s = "aababab", repeatLimit = 2
> 输出："bbabaa"
> 解释：
> 使用 s 中的一些字符来构造 repeatLimitedString "bbabaa"。 
> 字母 'a' 连续出现至多 2 次。 
> 字母 'b' 连续出现至多 2 次。 
> 因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 
> 该字符串是字典序最大的 repeatLimitedString ，所以返回 "bbabaa" 。 
> 注意，尽管 "bbabaaa" 字典序更大，但字母 'a' 连续出现超过 2 次，所以它不是一个有效的 repeatLimitedString 。
>
>  
>
> 提示：
>
>     1 <= repeatLimit <= s.length <= 105
>     s 由小写英文字母组成
>

```java
class Solution {
    public String repeatLimitedString(String s, int repeatLimit) {
        int[] a=new int[26];//用于存储相对应字母的个数
        for(int i=0;i<s.length();i++) a[s.charAt(i)-'a']++;//遍历整个字符串
        reverse(a);//将数组翻转。将字母序大的排在前面
        StringBuilder s1=new StringBuilder();//用于返回最终的答案
        for(int i=0;i<a.length;i++){//遍历整个数组
            while(a[i]>0){//如果大的数组用完了，才i+1
                if(a[i]<=repeatLimit){//如果当前最大的字母的数目小于repeatLimit就直接将所有的添加到s1里面
                    for(int j=0;j<a[i];j++) s1.append((char)('z'-i));
                    a[i]=0;//添加完后，将该字母所对应的数组内容置为0
                    break;
                }else{
                    for(int j=0;j<repeatLimit;j++) s1.append((char)('z'-i));//如果超过repeatLimit，就先添加repeatLimit个最大的字母
                    a[i]-=repeatLimit;
                    char temp=find(i,a);//寻找次大的字母
                    if(temp=='X') return s1.toString();//如果找不到相隔符，就直接退出(由于字母里面没有大写的，就用大X代表找不到相隔符)
                    else s1.append(temp);//如果找到了相隔符，就进行添加
                }
            }
        }
        return s1.toString();//返回最终结果
    }
    public char find(int i,int[] a){//用于找”次大“的相隔符
        for(int j=i+1;j<a.length;j++){
            if(a[j]>0) {
                a[j]--;
                return (char) ('z'-j);
            }
        }
        return 'X';//找遍整个数组,还没有找到，就返回大写的X
    }
    public void reverse(int[] a){//通过双指针方法用于翻转数组
        int x=0,y=a.length-1;
        while(x<y){
            int temp=a[x];
            a[x]=a[y];
            a[y]=temp;
            x++;y--;
        }
    }
}
```

- ![image-20220221220348606](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220221220348606.png)

## 第 283 场周赛

### [6016. Excel 表中某个范围内的单元格](https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/)

> Excel 表中的一个单元格 (r, c) 会以字符串 "<col><row>" 的形式进行表示，其中：
>
>     <col> 即单元格的列号 c 。用英文字母表中的 字母 标识。
>         例如，第 1 列用 'A' 表示，第 2 列用 'B' 表示，第 3 列用 'C' 表示，以此类推。
>     <row> 即单元格的行号 r 。第 r 行就用 整数 r 标识。
>
> 给你一个格式为 "<col1><row1>:<col2><row2>" 的字符串 s ，其中 <col1> 表示 c1 列，<row1> 表示 r1 行，<col2> 表示 c2 列，<row2> 表示 r2 行，并满足 r1 <= r2 且 c1 <= c2 。
>
> 找出所有满足 r1 <= x <= r2 且 c1 <= y <= c2 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 字符串 表示，并以 非递减 顺序排列（先按列排，再按行排）。
>
>  
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202203061452911.png)
>
> 输入：s = "K1:L2"
> 输出：["K1","K2","L1","L2"]
> 解释：
> 上图显示了列表中应该出现的单元格。
> 红色箭头指示单元格的出现顺序。
>
> 示例 2：
>
> ![](https://gitee.com/demon_night/images/raw/master/imgs/202203061452942.png)
>
> 输入：s = "A1:F1"
> 输出：["A1","B1","C1","D1","E1","F1"]
> 解释：
> 上图显示了列表中应该出现的单元格。 
> 红色箭头指示单元格的出现顺序。
>
>  
>
> 提示：
>
>     s.length == 5
>     'A' <= s[0] <= s[3] <= 'Z'
>     '1' <= s[1] <= s[4] <= '9'
>     s 由大写英文字母、数字、和 ':' 组成
>

```java
class Solution {
    public List<String> cellsInRange(String s) {
        List<String> l=new ArrayList<>();
        char temp1=s.charAt(0);
        char temp2=s.charAt(3);
        int a=s.charAt(1)-'0';
        int b=s.charAt(4)-'0';
        for(char j=temp1;j<=temp2;j++){
            for(int i=a;i<=b;i++){
                String temp3=String.valueOf(j)+String.valueOf(i);
                l.add(temp3);
            }
        }
        return l;
    }
}
```

### [6017. 向数组中追加 K 个整数](https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/)

> 给你一个整数数组 nums 和一个整数 k 。请你向 nums 中追加 k 个 未 出现在 nums 中的、互不相同 的 正 整数，并使结果数组的元素和 最小 。
>
> 返回追加到 nums 中的 k 个整数之和。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,4,25,10,25], k = 2
> 输出：5
> 解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。
> nums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。
> 所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。
>
> 示例 2：
>
> 输入：nums = [5,6], k = 6
> 输出：25
> 解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 1 、2 、3 、4 、7 和 8 。
> nums 最终元素和为 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36 ，这是所有情况中的最小值。
> 所以追加到数组中的两个整数之和是 1 + 2 + 3 + 4 + 7 + 8 = 25 ，所以返回 25 。
>
> ![image-20220306145335046](https://cdn.jsdelivr.net/gh/yzk656/image/202212241931578.png)

> 等差数列求和

- <img src="https://pic3.zhimg.com/v2-00171242d42a94fd27bbd7c53e1db1e2_r.jpg" alt="查看源图像" style="zoom: 25%;" />

```java
class Solution {
    public long minimalKSum(int[] nums, int k) {
        Arrays.sort(nums);//将数组进行排序
        LinkedHashSet<Integer> h=new LinkedHashSet<>();//放进LinkedHashSet，这样存入顺序和取出顺序一致同时也去重了
        for(int i:nums) h.add(i);//将其添加到集合中
        Long ans=0L;//用于存放最终结果
        int start=1;//等差数列的第一个数；因为我们是按顺序求和的即1,2,3...
        for(int i:h){
            int n=i-start;//数列中个数，也就是两个数之间能够添加的数的个数
            if(n==0) {//如果个数为0，则找下一个值同时要改变数列的值
                start=i+1;
                continue;
            }
            if(k>n){//如果剩余添加的个数大于当前数列的个数，就进行整个数列的求和
                ans+=1L*start*n+1L*n*(n-1)/2;
                k-=n;
            } else {//否则就进行部分数列的求和
                ans+=1L*k*start+1L*k*(k-1)/2;
                k=0;
            }
            start=i+1;//数列的头节点改变
            if(k==0) return ans;
        }
        if(k>0) ans+=1L*k*start+1L*k*(k-1)/2;//如果整个数组里面空余的房间填满了，就进行数组外的数进行额外添加
        return ans;//返回最终结果
    }
}
```

- 哎，大意了，当时等差数列求和忘了Sn=a1**n+n**(n-1)/2

  还有一点需要注意的是对于中间变量如：1L**n**(n-1)/2;必须要乘1L否则默认存储长度是int类型的，因此我们需要将其乘于1L，这样就会将这个表达式的结果放在longlong空间大小的存储空间中，这一定要总结教训！！！

### [2196. 根据描述创建二叉树](https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/)

> 给你一个二维整数数组 descriptions ，其中 descriptions[i] = [parenti, childi, isLefti] 表示 parenti 是 childi 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外：
>
>     如果 isLefti == 1 ，那么 childi 就是 parenti 的左子节点。
>     如果 isLefti == 0 ，那么 childi 就是 parenti 的右子节点。
>
> 请你根据 descriptions 的描述来构造二叉树并返回其 根节点 。
>
> 测试用例会保证可以构造出 有效 的二叉树。
>
>  
>
> 示例 1：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202203072221935.png)
>
> 输入：descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]
> 输出：[50,20,80,15,17,19]
> 解释：根节点是值为 50 的节点，因为它没有父节点。
> 结果二叉树如上图所示。
>
> 示例 2：
>
> ![img](https://gitee.com/demon_night/images/raw/master/imgs/202203072222976.png)
>
> 输入：descriptions = [[1,2,1],[2,3,0],[3,4,1]]
> 输出：[1,2,null,null,3,4]
> 解释：根节点是值为 1 的节点，因为它没有父节点。 
> 结果二叉树如上图所示。 
>
> ![image-20220307222133205](https://cdn.jsdelivr.net/gh/yzk656/image/202212241931000.png)

```java
```

## 第 284 场周赛

### [6031. 找出数组中的所有 K 近邻下标](https://leetcode-cn.com/problems/find-all-k-distant-indices-in-an-array/)

> #### 
>
> 给你一个下标从 **0** 开始的整数数组 `nums` 和两个整数 `key` 和 `k` 。**K 近邻下标** 是 `nums` 中的一个下标 `i` ，并满足至少存在一个下标 `j` 使得 `|i - j| <= k` 且 `nums[j] == key` 。
>
> 以列表形式返回按 **递增顺序** 排序的所有 K 近邻下标。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [3,4,9,1,3,9,5], key = 9, k = 1
> 输出：[1,2,3,4,5,6]
> 解释：因此，nums[2] == key 且 nums[5] == key 。
> - 对下标 0 ，|0 - 2| > k 且 |0 - 5| > k ，所以不存在 j 使得 |0 - j| <= k 且 nums[j] == key 。所以 0 不是一个 K 近邻下标。
> - 对下标 1 ，|1 - 2| <= k 且 nums[2] == key ，所以 1 是一个 K 近邻下标。
> - 对下标 2 ，|2 - 2| <= k 且 nums[2] == key ，所以 2 是一个 K 近邻下标。
> - 对下标 3 ，|3 - 2| <= k 且 nums[2] == key ，所以 3 是一个 K 近邻下标。
> - 对下标 4 ，|4 - 5| <= k 且 nums[5] == key ，所以 4 是一个 K 近邻下标。
> - 对下标 5 ，|5 - 5| <= k 且 nums[5] == key ，所以 5 是一个 K 近邻下标。
> - 对下标 6 ，|6 - 5| <= k 且 nums[5] == key ，所以 6 是一个 K 近邻下标。
> 因此，按递增顺序返回 [1,2,3,4,5,6] 。 
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,2,2,2,2], key = 2, k = 2
> 输出：[0,1,2,3,4]
> 解释：对 nums 的所有下标 i ，总存在某个下标 j 使得 |i - j| <= k 且 nums[j] == key ，所以每个下标都是一个 K 近邻下标。 
> 因此，返回 [0,1,2,3,4] 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 1000`
> - `1 <= nums[i] <= 1000`
> - `key` 是数组 `nums` 中的一个整数
> - `1 <= k <= nums.length`

```java
class Solution {
    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {
        List<Integer> l=new ArrayList<>();
        int len=nums.length;
        for(int i=0;i<len;i++){
            if(nums[i]==key) l.add(i);
        }
        Set<Integer> ans=new LinkedHashSet<>();
        for(int i:l){
            int pre=(i-k)<0 ? 0:(i-k);
            int next=(i+k)>(len-1)?(len-1):(i+k);
            while(pre<=next) {
                ans.add(pre);
                pre++;
            }
        }
        l.clear();
        for(int i:ans) l.add(i);
        return l;
    }
}
```

### [5203. 统计可以提取的工件](https://leetcode-cn.com/problems/count-artifacts-that-can-be-extracted/)

> 存在一个 n x n 大小、下标从 0 开始的网格，网格中埋着一些工件。给你一个整数 n 和一个下标从 0 开始的二维整数数组 artifacts ，artifacts 描述了矩形工件的位置，其中 artifacts[i] = [r1i, c1i, r2i, c2i] 表示第 i 个工件在子网格中的填埋情况：
>
>     (r1i, c1i) 是第 i 个工件 左上 单元格的坐标，且
>     (r2i, c2i) 是第 i 个工件 右下 单元格的坐标。
>
> 你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。
>
> 给你一个下标从 0 开始的二维整数数组 dig ，其中 dig[i] = [ri, ci] 表示你将会挖掘单元格 (ri, ci) ，返回你可以提取的工件数目。
>
> 生成的测试用例满足：
>
>     不存在重叠的两个工件。
>     每个工件最多只覆盖 4 个单元格。
>     dig 中的元素互不相同。
>
>  
>
> 示例 1：
>
> ![image-20220313225855066](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220313225855066.png)
>
> 输入：n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]
> 输出：1
> 解释： 
> 不同颜色表示不同的工件。挖掘的单元格用 'D' 在网格中进行标记。
> 有 1 个工件可以提取，即红色工件。
> 蓝色工件在单元格 (1,1) 的部分尚未裸露出来，所以无法提取该工件。
> 因此，返回 1 。
>
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram-1.jpg)
>
> 输入：n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]
> 输出：2
> 解释：红色工件和蓝色工件的所有部分都裸露出来（用 'D' 标记），都可以提取。因此，返回 2 。 
>
>  
>
> ![image-20220313225846463](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220313225846463.png)
>

```java
class Solution {
    boolean[][] F;
    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {
        F=new boolean[n][n];
        int len_dig=dig.length;
        for(int i=0;i<len_dig;i++){
            F[dig[i][0]][dig[i][1]]=true;
        }
        int ans=0;
        for(int i=0;i<artifacts.length;i++){
            int r1=artifacts[i][0];
            int c1=artifacts[i][1];
            int r2=artifacts[i][2];
            int c2=artifacts[i][3];
            boolean flag=false;
            outer:for(int m=r1;m<=r2;m++){
                for(int p=c1;p<=c2;p++){
                    if(!pd(new int[]{m,p})){
                        flag=true;
                        break outer;
                    }
                }
            }
            if(!flag)ans++;
        }
        return ans;
    }
    public boolean pd(int[] temp){
        if(F[temp[0]][temp[1]]) return true;
        return false;
    }
}
```

- 应该使用boolean数组来判断是否被占用过，而不是每一次都遍历整个集合
  - 原先自己用Set集合来存储dig下标，导致遍历时不能数组来判断，因为比较数组比较了地址，两个值虽然相同，但是地址不同，如果要是用for循环遍历数组就会导致三重循环，直接爆掉，因此最好的就是采用**判断数组**来进行判断，这样的时间复杂度为O(1),因为是根据数组下标来进行判断的

## 第 285 场周赛

### [2210. 统计数组中峰和谷的数量](https://leetcode-cn.com/problems/count-hills-and-valleys-in-an-array/)

> 给你一个下标从 0 开始的整数数组 nums 。如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums 中，某个峰的一部分。类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。对于相邻下标 i 和 j ，如果 nums[i] == nums[j] ， 则认为这两下标属于 同一个 峰或谷。
>
> 注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。
>
> 返回 nums 中峰和谷的数量。
>
>  
>
> 示例 1：
>
> 输入：nums = [2,4,1,1,6,5]
> 输出：3
> 解释：
> 在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。
> 在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 > 2 且 4 > 1 ，下标 1 是一个峰。
> 在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 < 4 且 1 < 6 ，下标 2 是一个谷。
> 在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 < 4 且 1 < 6 ，下标 3 符合谷的定义，但需要注意它和下标 2 是同一个谷的一部分。
> 在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 > 1 且 6 > 5 ，下标 4 是一个峰。
> 在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。
> 共有 3 个峰和谷，所以返回 3 。
>
> 示例 2：
>
> 输入：nums = [6,6,5,5,4,1]
> 输出：0
> 解释：
> 在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。
> 在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。
> 在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 < 6 且 5 > 4 ，下标 2 既不是峰也不是谷。
> 在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 < 6 且 5 > 4 ，下标 3 既不是峰也不是谷。
> 在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 < 5 且 4 > 1 ，下标 4 既不是峰也不是谷。
> 在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。
> 共有 0 个峰和谷，所以返回 0 。
>
>  
>
> 提示：
>
>     3 <= nums.length <= 100
>     1 <= nums[i] <= 100
>

```java
class Solution {
    public int countHillValley(int[] nums) {
        List<Integer> l=new ArrayList<>();
        l.add(nums[0]);
        for(int i=1;i<nums.length;i++){
            if(nums[i]!=nums[i-1]) l.add(nums[i]);
        }
        int[] a=new int[l.size()];
        int temp=0;
        for(int i:l){
            a[temp]=i;
            temp++;
        }
        int ans=0;
        for(int i=1;i<l.size()-1;i++){
            if(a[i]>a[i-1]&&a[i]>a[i+1]) ans++;
            if(a[i]<a[i-1]&&a[i]<a[i+1]) ans++;
        }
        return ans;
    }
}
```

### [2211. 统计道路上的碰撞次数](https://leetcode-cn.com/problems/count-collisions-on-a-road/)

> #### 
>
> 在一条无限长的公路上有 `n` 辆汽车正在行驶。汽车按从左到右的顺序按从 `0` 到 `n - 1` 编号，每辆车都在一个 **独特的** 位置。
>
> 给你一个下标从 **0** 开始的字符串 `directions` ，长度为 `n` 。`directions[i]` 可以是 `'L'`、`'R'` 或 `'S'` 分别表示第 `i` 辆车是向 **左** 、向 **右** 或者 **停留** 在当前位置。每辆车移动时 **速度相同** 。
>
> 碰撞次数可以按下述方式计算：
>
> - 当两辆移动方向 **相反** 的车相撞时，碰撞次数加 `2` 。
> - 当一辆移动的车和一辆静止的车相撞时，碰撞次数加 `1` 。
>
> 碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。
>
> 返回在这条道路上发生的 **碰撞总次数** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：directions = "RLRSLL"
> 输出：5
> 解释：
> 将会在道路上发生的碰撞列出如下：
> - 车 0 和车 1 会互相碰撞。由于它们按相反方向移动，碰撞数量变为 0 + 2 = 2 。
> - 车 2 和车 3 会互相碰撞。由于 3 是静止的，碰撞数量变为 2 + 1 = 3 。
> - 车 3 和车 4 会互相碰撞。由于 3 是静止的，碰撞数量变为 3 + 1 = 4 。
> - 车 4 和车 5 会互相碰撞。在车 4 和车 3 碰撞之后，车 4 会待在碰撞位置，接着和车 5 碰撞。碰撞数量变为 4 + 1 = 5 。
> 因此，将会在道路上发生的碰撞总次数是 5 。
> ```
>
> **示例 2：**
>
> ```
> 输入：directions = "LLRR"
> 输出：0
> 解释：
> 不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 0 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= directions.length <= 105`
> - `directions[i]` 的值为 `'L'`、`'R'` 或 `'S'`

```java
class Solution {
    public int countCollisions(String directions) {
        char[] direction=directions.toCharArray();
        int num_R=0;
        boolean sw=false;
        int count=0;
        for(int i=0;i<directions.length();i++){
            if(direction[i]=='R') num_R++;
            else if(direction[i]=='L'){
                if(sw) {
                    count+=num_R+1;
                    num_R=0;
                }else{
                    if(num_R!=0){
                        count+=num_R+1;
                        num_R=0;
                        sw=true;
                    }
                }
            }else if(direction[i]=='S'){
                if(num_R!=0){
                    count+=num_R;
                    num_R=0;
                }
                sw=true;
            }
        }
        return count;
    }
}
```

## 第 286 场周赛

### [2215. 找出两数组的不同](https://leetcode-cn.com/problems/find-the-difference-of-two-arrays/)

> #### 
>
> 给你两个下标从 `0` 开始的整数数组 `nums1` 和 `nums2` ，请你返回一个长度为 `2` 的列表 `answer` ，其中：
>
> - `answer[0]` 是 `nums1` 中所有 **不** 存在于 `nums2` 中的 **不同** 整数组成的列表。
> - `answer[1]` 是 `nums2` 中所有 **不** 存在于 `nums1` 中的 **不同** 整数组成的列表。
>
> **注意：**列表中的整数可以按 **任意** 顺序返回。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2,3], nums2 = [2,4,6]
> 输出：[[1,3],[4,6]]
> 解释：
> 对于 nums1 ，nums1[1] = 2 出现在 nums2 中下标 0 处，然而 nums1[0] = 1 和 nums1[2] = 3 没有出现在 nums2 中。因此，answer[0] = [1,3]。
> 对于 nums2 ，nums2[0] = 2 出现在 nums1 中下标 1 处，然而 nums2[1] = 4 和 nums2[2] = 6 没有出现在 nums2 中。因此，answer[1] = [4,6]。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums1 = [1,2,3,3], nums2 = [1,1,2,2]
> 输出：[[3],[]]
> 解释：
> 对于 nums1 ，nums1[2] 和 nums1[3] 没有出现在 nums2 中。由于 nums1[2] == nums1[3] ，二者的值只需要在 answer[0] 中出现一次，故 answer[0] = [3]。
> nums2 中的每个整数都在 nums1 中出现，因此，answer[1] = [] 。 
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums1.length, nums2.length <= 1000`
> - `-1000 <= nums1[i], nums2[i] <= 1000`

```java
class Solution {
    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {
        HashSet<Integer> nums_1=new HashSet<>();
        HashSet<Integer> nums_2=new HashSet<>();
        for(int i=0;i<nums1.length;i++) nums_1.add(nums1[i]);
        for(int i=0;i<nums2.length;i++) nums_2.add(nums2[i]);
        List<List<Integer>> ans=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        for(int i:nums_1){
            if(!nums_2.contains(i)) temp.add(i);
        }
        ans.add(0,temp);
        List<Integer> temp1=new ArrayList<>();
        for(int i:nums_2){
            if(!nums_1.contains(i)) temp1.add(i);
        }
        ans.add(1,temp1);
        return ans;
    }
}
```

### [2216. 美化数组的最少删除数[贪心]](https://leetcode-cn.com/problems/minimum-deletions-to-make-array-beautiful/)

> 给你一个下标从 **0** 开始的整数数组 `nums` ，如果满足下述条件，则认为数组 `nums` 是一个 **美丽数组** ：
>
> - `nums.length` 为偶数
> - 对所有满足 `i % 2 == 0` 的下标 `i` ，`nums[i] != nums[i + 1]` 均成立
>
> 注意，空数组同样认为是美丽数组。
>
> 你可以从 `nums` 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 **不变** 。
>
> 返回使 `nums` 变为美丽数组所需删除的 **最少** 元素数目*。*
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,2,3,5]
> 输出：1
> 解释：可以删除 nums[0] 或 nums[1] ，这样得到的 nums = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,1,2,2,3,3]
> 输出：2
> 解释：可以删除 nums[0] 和 nums[5] ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。
> ```
>
>  
>
> - ![image-20220328221859801](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220328221859801.png)

```java
class Solution {
    public int minDeletion(int[] nums) {
        List<Integer> l=new ArrayList<>();
        for(int i=0;i<nums.length-1;){
            if(nums[i]!=nums[i+1]){
                l.add(nums[i]);
                l.add(nums[i+1]);
                i+=2;
            }else{
                i++;
            }
        }
        return nums.length-l.size();
    }
}
```

### [2217. 找到指定长度的回文数](https://leetcode-cn.com/problems/find-palindrome-with-fixed-length/)

> 给你一个整数数组 queries 和一个 正 整数 intLength ，请你返回一个数组 answer ，其中 answer[i] 是长度为 intLength 的 正回文数 中第 queries[i] 小的数字，如果不存在这样的回文数，则为 -1 。
>
> 回文数 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。
>
>  
>
> 示例 1：
>
> 输入：queries = [1,2,3,4,5,90], intLength = 3
> 输出：[101,111,121,131,141,999]
> 解释：
> 长度为 3 的最小回文数依次是：
> 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...
> 第 90 个长度为 3 的回文数是 999 。
>
> 示例 2：
>
> 输入：queries = [2,4,6], intLength = 4
> 输出：[1111,1331,1551]
> 解释：
> 长度为 4 的前 6 个回文数是：
> 1001, 1111, 1221, 1331, 1441 和 1551 。
>
> ![image-20220328222021729](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220328222021729.png)

```java
class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {

        boolean flag=false;
        int z=0;
        if(intLength%2==0) flag=true;
        if(flag) z=intLength/2;
        else z=intLength/2+1;
        List<Long> ans=new ArrayList<>();

        long temp=1;
        long max=0;
        for(int i=0;i<z-1;i++) temp*=10;
        for(int i=0;i<intLength;i++) max=max*10+9;

        for(int i:queries){
            
            long temp1=temp+i-1;
            String tt=String.valueOf(i);
            int len=0;
            if(flag) len=tt.length()*2;
            else len=tt.length()*2-1;
            if(len>intLength){
                ans.add((long)(-1));
                continue;
            }
            
            StringBuilder s=new StringBuilder(Long.toString(temp1));
            if(flag){
                String s_temp1=s.toString();
                String s_temp2=String.valueOf(s.reverse());
                s=new StringBuilder(s_temp1);
                s=s.append(s_temp2);
            }
            else {
                StringBuilder s_temp=new StringBuilder(s.substring(0,s.length()-1));
                s=s.append(s_temp.reverse());
            }
            long cnt=0;
            for(int j=0;j<s.length();j++) cnt=cnt*10+Integer.parseInt(String.valueOf(s.charAt(j)));
            if(cnt>max) ans.add((long)(-1));
            else ans.add(cnt);
        }

        long[] ans1=new long[ans.size()];
        int t=0;
        for(int i=0;i<ans.size();i++) {
            ans1[t]=ans.get(i);
            t++;
        }

        return ans1;
    }
}
```

- 对于回文字符串，只需要求出左边的，然后翻转拼接就行了
- 截取方法：`substring()`

> 修改后

```java
class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        
        List<Long> l=new ArrayList<>();
        boolean flag=(intLength%2)==0 ?  true:false;
        int z=(intLength%2)==0 ? intLength/2:intLength/2+1;
        
        int T=1;
        for(int i=0;i<z-1;i++) T*=10;
        
        long max=0;
        for(int i=0;i<intLength;i++) max=max*10+9;
        
        for(int i: queries){
            long temp=T;
            temp=temp+i-1;
            String tt=String.valueOf(temp);
            int len=flag==true ? tt.length()*2:(tt.length()*2-1);
            if(len>intLength) {
                l.add((long)(-1));
                continue;
            }
            StringBuilder s=new StringBuilder(String.valueOf(temp));
            if(flag){
                StringBuilder temp1=new StringBuilder(s.toString());
                s=s.append(temp1.reverse());
            }else{
                StringBuilder temp1=new StringBuilder(s.substring(0,s.length()-1));
                s=s.append(temp1.reverse());
            }
            long temp2=0;
            for(int j=0;j<s.length();j++) temp2=temp2*10+Integer.parseInt(String.valueOf(s.charAt(j)));
            if(temp2>max) l.add((long)(-1));
            else l.add(temp2);
            
        }
        
        long[] ans=new long[l.size()];
        int temp3=0;
        for(long i:l){
            ans[temp3]=i;
            temp3++;
        }        
        
        return ans;
    }
}
```

## 第 75 场双周赛

### [6033. 转换数字的最少位翻转次数](https://leetcode-cn.com/problems/minimum-bit-flips-to-convert-number/)

> 一次 位翻转 定义为将数字 x 二进制中的一个位进行 翻转 操作，即将 0 变成 1 ，或者将 1 变成 0 。
>
> 比方说，x = 7 ，二进制表示为 111 ，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到 110 ，或者翻转右边起第二位得到 101 ，或者翻转右边起第五位（这一位是前导 0 ）得到 10111 等等。
> 给你两个整数 start 和 goal ，请你返回将 start 转变成 goal 的 最少位翻转 次数。
>
>  
>
> 示例 1：
>
> 输入：start = 10, goal = 7
> 输出：3
> 解释：10 和 7 的二进制表示分别为 1010 和 0111 。我们可以通过 3 步将 10 转变成 7 ：
> - 翻转右边起第一位得到：1010 -> 1011 。
> - 翻转右边起第三位：1011 -> 1111 。
> - 翻转右边起第四位：1111 -> 0111 。
> 我们无法在 3 步内将 10 转变成 7 。所以我们返回 3 。
> 示例 2：
>
> 输入：start = 3, goal = 4
> 输出：3
> 解释：3 和 4 的二进制表示分别为 011 和 100 。我们可以通过 3 步将 3 转变成 4 ：
> - 翻转右边起第一位：011 -> 010 。
> - 翻转右边起第二位：010 -> 000 。
> - 翻转右边起第三位：000 -> 100 。
> 我们无法在 3 步内将 3 变成 4 。所以我们返回 3 。
>
> ![image-20220404105106295](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220404105106295.png)

```java
class Solution {
    public int minBitFlips(int start, int goal) {
    	StringBuilder s1=new StringBuilder(Integer.toBinaryString(start));
    	StringBuilder s2=new StringBuilder(Integer.toBinaryString(goal));
    	int a=s1.length(),b=s2.length();
    	int t=a>=b ? a-b:b-a;
    	StringBuilder s3=new StringBuilder();
    	for(int i=0;i<t;i++) s3=s3.append('0');
    	if(a>b) s2=s3.append(s2.toString());
    	else s1=s3.append(s1.toString());
    	int ans=0;
    	for(int i=0;i<s1.length();i++) {
    		if(s1.charAt(i)!=s2.charAt(i)) ans++;
    	}
    	return ans;
    }
}
```

### [6034. 数组的三角和](https://leetcode-cn.com/problems/find-triangular-sum-of-an-array/)

> 给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 0 到 9 之间（两者都包含）的一个数字。
>
> nums 的 三角和 是执行以下操作以后最后剩下元素的值：
>
> nums 初始包含 n 个元素。如果 n == 1 ，终止 操作。否则，创建 一个新的下标从 0 开始的长度为 n - 1 的整数数组 newNums 。
> 对于满足 0 <= i < n - 1 的下标 i ，newNums[i] 赋值 为 (nums[i] + nums[i+1]) % 10 ，% 表示取余运算。
> 将 newNums 替换 数组 nums 。
> 从步骤 1 开始 重复 整个过程。
> 请你返回 nums 的三角和。
>
>  
>
> 示例 1：
>
> 
>
> 输入：nums = [1,2,3,4,5]
> 输出：8
> 解释：
> 上图展示了得到数组三角和的过程。
> 示例 2：
>
> 输入：nums = [5]
> 输出：5
> 解释：
> 由于 nums 中只有一个元素，数组的三角和为这个元素自己。
>
>
> 提示：
>
> 1 <= nums.length <= 1000
> 0 <= nums[i] <= 9

```java
class Solution {
    public int triangularSum(int[] nums) {
    	if(nums.length==1) return nums[0];
    	int[][] a=new int[nums.length][nums.length];
    	int t=nums.length;
        for(int i=0;i<t;i++) a[0][i]=nums[i];
    	for(int i=1;i<nums.length;i++) {
    		t--;
    		for(int j=0;j<t;j++) {
    			a[i][j]=(a[i-1][j]+a[i-1][j+1])%10;
    		}
    	}
    	return a[nums.length-1][0];
    }
}
```

### [6035. 选择建筑的方案数](https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/)

> 给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：
>
> s[i] = '0' 表示第 i 栋建筑是一栋办公楼，
> s[i] = '1' 表示第 i 栋建筑是一间餐厅。
> 作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。
>
> 比方说，给你 s = "001101" ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 "011" ，有相邻两栋建筑是同一类型，所以 不合 题意。
> 请你返回可以选择 3 栋建筑的 有效方案数 。
>
>  
>
> 示例 1：
>
> 输入：s = "001101"
> 输出：6
> 解释：
> 以下下标集合是合法的：
> - [0,2,4] ，从 "001101" 得到 "010"
> - [0,3,4] ，从 "001101" 得到 "010"
> - [1,2,4] ，从 "001101" 得到 "010"
> - [1,3,4] ，从 "001101" 得到 "010"
> - [2,4,5] ，从 "001101" 得到 "101"
> - [3,4,5] ，从 "001101" 得到 "101"
> 没有别的合法选择，所以总共有 6 种方法。
> 示例 2：
>
> 输入：s = "11100"
> 输出：0
> 解释：没有任何符合题意的选择。
>
>
> 提示：
>
> 3 <= s.length <= 105
> s[i] 要么是 '0' ，要么是 '1' 。

```java\
class Solution {
    public long numberOfWays(String s) {
    	char[] a=s.toCharArray();
    	int n=a.length;
    	int[] count=new int[n];
    	
    	int one_count=0;
    	int zero_count=0;
    	//求出1和0各自的个数
    	for(int i=0;i<n;i++) {
    		if(a[i]=='1') one_count++;
    		else zero_count++;
    	}
    	
    	long ans=0;
    	int t1=a[0]=='1'?1:0;
    	int t0=a[0]=='0'?1:0;
    	for(int i=1;i<n;i++) {
    		if(a[i]=='1') {
    			ans+=1L*t0*(zero_count-t0);
    			t1++;
    		}else {
    			ans+=1L*t1*(one_count-t1);
    			t0++;
    		}
    	}
    	
    	return ans;
    }
}
```

1. [前缀和思想](https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/solution/by-baoya_uncle-qsr8/)，这个是我参照的博主
2. 计算当前位置是‘1’还是‘0’
   1. 如果是‘1’，也就是能够形成“010”，能形成的组合：左边0的个数*右边0的个数
   2. 如果是’0‘，也就是能够形成“101”，能形成的组合：左边1的个数*右边1的个数

## 第 287 场周赛

### [6055. 转化时间需要的最少操作数](https://leetcode-cn.com/problems/minimum-number-of-operations-to-convert-time/)

> 给你两个字符串 current 和 correct ，表示两个 24 小时制时间 。
>
> 24 小时制时间 按 "HH:MM" 进行格式化，其中 HH 在 00 和 23 之间，而 MM 在 00 和 59 之间。最早的 24 小时制时间为 00:00 ，最晚的是 23:59 。
>
> 在一步操作中，你可以将 current 这个时间增加 1、5、15 或 60 分钟。你可以执行这一操作 任意 次数。
>
> 返回将 current 转化为 correct 需要的 最少操作数 。
>
>  
>
> 示例 1：
>
> 输入：current = "02:30", correct = "04:35"
> 输出：3
> 解释：
> 可以按下述 3 步操作将 current 转换为 correct ：
> - 为 current 加 60 分钟，current 变为 "03:30" 。
> - 为 current 加 60 分钟，current 变为 "04:30" 。 
> - 为 current 加 5 分钟，current 变为 "04:35" 。
> 可以证明，无法用少于 3 步操作将 current 转化为 correct 。
> 示例 2：
>
> 输入：current = "11:00", correct = "11:01"
> 输出：1
> 解释：只需要为 current 加一分钟，所以最小操作数是 1 。
>
>
> 提示：
>
> current 和 correct 都符合 "HH:MM" 格式
> current <= correct

```java
class Solution {
    public int convertTime(String current, String correct) {
        StringBuilder s1=new StringBuilder(current);
        StringBuilder s2=new StringBuilder(correct);
        int a=Integer.parseInt(s1.substring(0,2));
        int b=Integer.parseInt(s1.substring(3,5));
        int c=Integer.parseInt(s2.substring(0,2));
        int d=Integer.parseInt(s2.substring(3,5));
        int ans=0;
        int temp=(d-b)+Math.abs(a-c)*60;
        while (temp>=60){
            int t1=temp/60;
            temp%=60;
            ans+=t1;
        }
        while(temp>=15) {
            int t1=temp/15;
            temp%=15;
            ans+=t1;
        }
        while(temp>=5) {
            int t1=temp/5;
            temp%=5;
            ans+=t1;
        }
        ans+=temp;
        return ans;
    }
}
```

### [5235. 找出输掉零场或一场比赛的玩家](https://leetcode-cn.com/problems/find-players-with-zero-or-one-losses/)

> 给你一个整数数组 matches 其中 matches[i] = [winneri, loseri] 表示在一场比赛中 winneri 击败了 loseri 。
>
> 返回一个长度为 2 的列表 answer ：
>
> answer[0] 是所有 没有 输掉任何比赛的玩家列表。
> answer[1] 是所有恰好输掉 一场 比赛的玩家列表。
> 两个列表中的值都应该按 递增 顺序返回。
>
> 注意：
>
> 只考虑那些参与 至少一场 比赛的玩家。
> 生成的测试用例保证 不存在 两场比赛结果 相同 。
>
>
> 示例 1：
>
> 输入：matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]
> 输出：[[1,2,10],[4,5,7,8]]
> 解释：
> 玩家 1、2 和 10 都没有输掉任何比赛。
> 玩家 4、5、7 和 8 每个都输掉一场比赛。
> 玩家 3、6 和 9 每个都输掉两场比赛。
> 因此，answer[0] = [1,2,10] 和 answer[1] = [4,5,7,8] 。
> 示例 2：
>
> 输入：matches = [[2,3],[1,3],[5,4],[6,4]]
> 输出：[[1,2,5,6],[]]
> 解释：
> 玩家 1、2、5 和 6 都没有输掉任何比赛。
> 玩家 3 和 4 每个都输掉两场比赛。
> 因此，answer[0] = [1,2,5,6] 和 answer[1] = [] 。
>
> ![image-20220405125137279](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220405125137279.png)

```java
class Solution {
    public List<List<Integer>> findWinners(int[][] matches) {
    	HashSet<Integer> h1=new HashSet<>();
    	HashMap<Integer, Integer> h2=new HashMap<>();
    	List<Integer> l1=new ArrayList<>();
    	List<Integer> l2=new ArrayList<>();
    	List<List<Integer>> ans=new ArrayList<>();
    	for(int i=0;i<matches.length;i++) {
    		h1.add(matches[i][0]);
    	}
    	for(int i=0;i<matches.length;i++) {
    		h2.put(matches[i][1], h2.getOrDefault(matches[i][1], 0)+1);
    	}
    	for(int i:h1) {
    		if(!h2.containsKey(i)) {
    			l1.add(i);
    		}
    	}
    	for(int i:h2.keySet()) {
    		if(h2.get(i)==1) {
    			l2.add(i);
    		}
    	}
    	Collections.sort(l1);
    	Collections.sort(l2);
    	ans.add(l1);
    	ans.add(l2);
    	
    	return ans;
    }
}
```

### [2226. 每个小孩最多能分到多少糖果](https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/)

> 给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。
>
> 另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。
>
> 返回每个小孩可以拿走的 最大糖果数目 。
>
>  
>
> 示例 1：
>
> 输入：candies = [5,8,6], k = 3
> 输出：5
> 解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。
> 示例 2：
>
> 输入：candies = [2,5], k = 11
> 输出：0
> 解释：总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。
>
> ![image-20220405125246031](C:\Users\Demon Night\AppData\Roaming\Typora\typora-user-images\image-20220405125246031.png)

```java
class Solution {
    public int maximumCandies(int[] candies, long k) {
    	long sum=0;
    	for(int i:candies) sum+=i;
    	if(sum<k) return 0;
    	if(sum==k) return 1;
    	
    	long temp=1;
    	long max=sum/k;
    	long l=1,r=max;
    	while(l<=r) {
    		long mid=(l+r)/2;
    		
    		long cnt=0;
    		for(int i:candies) {
    			cnt+=(long)(i/mid);
    		}
    		
    		if(cnt>=k) {
    			temp=mid;
    			l=mid+1;
    		}else {
    			r=mid-1;
    		}
    	}
    	return (int)(temp);
    }
}
```

- 当结果在一个范围内，就可以使用二分法去避免一个一个的遍历，从而减少计算量
- 要算的是能生成多少个max_糖果

## 第 82 场双周赛

### [6116. 计算布尔二叉树的值](https://leetcode.cn/problems/evaluate-boolean-binary-tree/)

> 给你一棵 完整二叉树 的根，这棵树有以下特征：
>
> 叶子节点 要么值为 0 要么值为 1 ，其中 0 表示 False ，1 表示 True 。
> 非叶子节点 要么值为 2 要么值为 3 ，其中 2 表示逻辑或 OR ，3 表示逻辑与 AND 。
> 计算 一个节点的值方式如下：
>
> 如果节点是个叶子节点，那么节点的 值 为它本身，即 True 或者 False 。
> 否则，计算 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 运算 。
> 返回根节点 root 的布尔运算值。
>
> 完整二叉树 是每个节点有 0 个或者 2 个孩子的二叉树。
>
> 叶子节点 是没有孩子的节点。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2022/05/16/example1drawio1.png)
>
> 输入：root = [2,1,3,null,null,0,1]
> 输出：true
> 解释：上图展示了计算过程。
> AND 与运算节点的值为 False AND True = False 。
> OR 运算节点的值为 True OR False = True 。
> 根节点的值为 True ，所以我们返回 true 。
> 示例 2：
>
> 输入：root = [0]
> 输出：false
> 解释：根节点是叶子节点，且值为 false，所以我们返回 false 。
>
>
> 提示：
>
> 树中节点数目在 [1, 1000] 之间。
> 0 <= Node.val <= 3
> 每个节点的孩子数为 0 或 2 。
> 叶子节点的值为 0 或 1 。
> 非叶子节点的值为 2 或 3 。

自己写的

```java
class Solution {
    public boolean evaluateTree(TreeNode root) {
        return bl(root);
    }
    public boolean bl(TreeNode root) {
        if(root.val==0) return false;
        if(root.val==1) return true;
        if(root.val==2) return bl(root.left)||bl(root.right);
        else if(root.val==3) return bl(root.left)&&bl(root.right);
        return true;
    }
}
```

yxc

```java
class Solution {
    public boolean evaluateTree(TreeNode root) {
        return bl(root);
    }
    public boolean bl(TreeNode root) {
        if(root.left==null) return root.val==0 ? false:true;
        if(root.val==2) return bl(root.left)||bl(root.right);
        return bl(root.left)&&bl(root.right);
    }
}
```

### [6117. 坐上公交的最晚时间](https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/)

> 给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。
>
> 给你一个整数 capacity ，表示每辆公交车 最多 能容纳的乘客数目。
>
> 每位乘客都会搭乘下一辆有座位的公交车。如果你在 y 时刻到达，公交在 x 时刻出发，满足 y <= x  且公交没有满，那么你可以搭乘这一辆公交。最早 到达的乘客优先上车。
>
> 返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。
>
> 注意：数组 buses 和 passengers 不一定是有序的。
>
>  
>
> 示例 1：
>
> 输入：buses = [10,20], passengers = [2,17,18,19], capacity = 2
> 输出：16
> 解释：
> 第 1 辆公交车载着第 1 位乘客。
> 第 2 辆公交车载着你和第 2 位乘客。
> 注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。
> 示例 2：
>
> 输入：buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2
> 输出：20
> 解释：
> 第 1 辆公交车载着第 4 位乘客。
> 第 2 辆公交车载着第 6 位和第 2 位乘客。
> 第 3 辆公交车载着第 1 位乘客和你。
>
> ![image-20220710065454472](https://cdn.jsdelivr.net/gh/yzk656/image/202212241930062.png)

```java
class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        Arrays.sort(buses);//公交车到达排序
        Arrays.sort(passengers);//乘客到达时间排序
        int index = 0, num = 0;//初始化自己的下标、车内剩余座位
        for (int i = 0; i < buses.length; i++) {
            num = capacity;//每次车到达就重置时间
            while (num > 0 && index < passengers.length && passengers[index] <= buses[i]) {
                index++;//位置向后移动一位
                num--;//剩余座位-1
            }
        }
        index--;//删除最后一个人，最后一个位置留给自己【更新人物】
        int ans = num > 0 ? buses[buses.length - 1] : passengers[index];//如果有空余座位，说明自己还有选择，可以选择汽车到达时，自己到达；如果没有空位，则自己必须在最后一个人前面
        while (index >= 0 && passengers[index--] == ans) --ans;//如果有重复的，就一直往前找
        return ans;
    }
}
```

### [6118. 最小差值平方和](https://leetcode.cn/problems/minimum-sum-of-squared-difference/)

> 给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度为 n 。
>
> 数组 nums1 和 nums2 的 差值平方和 定义为所有满足 0 <= i < n 的 (nums1[i] - nums2[i])2 之和。
>
> 同时给你两个正整数 k1 和 k2 。你可以将 nums1 中的任意元素 +1 或者 -1 至多 k1 次。类似的，你可以将 nums2 中的任意元素 +1 或者 -1 至多 k2 次。
>
> 请你返回修改数组 nums1 至多 k1 次且修改数组 nums2 至多 k2 次后的最小 差值平方和 。
>
> 注意：你可以将数组中的元素变成 负 整数。
>
>  
>
> 示例 1：
>
> 输入：nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0
> 输出：579
> 解释：nums1 和 nums2 中的元素不能修改，因为 k1 = 0 和 k2 = 0 。
> 差值平方和为：(1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579 。
> 示例 2：
>
> 输入：nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1
> 输出：43
> 解释：一种得到最小差值平方和的方式为：
> - 将 nums1[0] 增加一次。
> - 将 nums2[2] 增加一次。
> 最小差值平方和为：
> (2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43 。
> 注意，也有其他方式可以得到最小差值平方和，但没有得到比 43 更小答案的方案。
>
> ![image-20220710203747749](https://cdn.jsdelivr.net/gh/yzk656/image/202212241930605.png)

```java
```

## 第 85 场周赛

### [836. 矩形重叠](https://leetcode.cn/problems/rectangle-overlap/)

> 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。
>
> 如果相交的面积为 正 ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
>
> 给出两个矩形 rec1 和 rec2 。如果它们重叠，返回 true；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
> 输出：true
> 示例 2：
>
> 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
> 输出：false
> 示例 3：
>
> 输入：rec1 = [0,0,1,1], rec2 = [2,2,3,3]
> 输出：false
>
> ![image-20220710231335964](https://cdn.jsdelivr.net/gh/yzk656/image/202212241931296.png)

```java
class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
    return Math.max(rec1[0], rec2[0]) < Math.min(rec1[2], rec2[2]) && Math.max(rec1[1], rec2[1]) < Math.min(rec1[3], rec2[3]);
    }
}
```

![image-20220710231402333](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220710231402333.png)

第一个矩形：（x1,y1),(x2,y2)
第二个矩形：  (x3,y3),(x4,y4)
如果满足max（x1, x3）<=min(x2, x4) && max(y1, y3)<=min(y2, y4)，则相交。

### \838. 推多米诺

> `n` 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。
>
> 每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。
>
> 如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。
>
> 就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。
>
> 给你一个字符串 `dominoes` 表示这一行多米诺骨牌的初始状态，其中：
>
> - `dominoes[i] = 'L'`，表示第 `i` 张多米诺骨牌被推向左侧，
> - `dominoes[i] = 'R'`，表示第 `i` 张多米诺骨牌被推向右侧，
> - `dominoes[i] = '.'`，表示没有推动第 `i` 张多米诺骨牌。
>
> 返回表示最终状态的字符串。
>
>  
>
> **示例 1：**
>
> ```
> 输入：dominoes = "RR.L"
> 输出："RR.L"
> 解释：第一张多米诺骨牌没有给第二张施加额外的力。
> ```
>
> **示例 2：**
>
> ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png)
>
> ```
> 输入：dominoes = ".L.R...LR..L.."
> 输出："LL.RR.LLRRLL.."
> ```
>
> **提示：**
>
> - `n == dominoes.length`
> - `1 <= n <= 10^5`
> - `dominoes[i]` 为 `'L'`、`'R'` 或 `'.'`

```java
class Solution {
    public String pushDominoes(String dominoes) {
        int len=dominoes.length(),i=0;
        char l='L';//假设遇到的第一个是L
        char[] temp=dominoes.toCharArray();
        while (i<len){
            int j=i;//初始化j
            while (j<len&&temp[j]=='.'){
                j++;//寻找要变化的区间
            }
            char r=j<len ? temp[j]:'R';//如果超过了字符串长度，，就默认最后一个是R
            if(l==r){//如果相等，就把区间内全换成一样的
                while (i<j){
                    temp[i++]=r;
                }
            } else if (l=='R'&&r=='L') {//如果不一样
                int k=j-1;//copy右边界，j的值不能变
                while (i<k){
                    temp[i++]='R';
                    temp[k--]='L';
                }
            }
            l=r;//右边界变成左边界
            i=j+1;//继续寻找可以改变的区间
        }

        return new String(temp);
    }
}
```

## 第 301 场周赛

### [6112. 装满杯子需要的最短总时长](https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/)

> 现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。
>
> 给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。
>
>  
>
> 示例 1：
>
> 输入：amount = [1,4,2]
> 输出：4
> 解释：下面给出一种方案：
> 第 1 秒：装满一杯冷水和一杯温水。
> 第 2 秒：装满一杯温水和一杯热水。
> 第 3 秒：装满一杯温水和一杯热水。
> 第 4 秒：装满一杯温水。
> 可以证明最少需要 4 秒才能装满所有杯子。
> 示例 2：
>
> 输入：amount = [5,4,4]
> 输出：7
> 解释：下面给出一种方案：
> 第 1 秒：装满一杯冷水和一杯热水。
> 第 2 秒：装满一杯冷水和一杯温水。
> 第 3 秒：装满一杯冷水和一杯温水。
> 第 4 秒：装满一杯温水和一杯热水。
> 第 5 秒：装满一杯冷水和一杯热水。
> 第 6 秒：装满一杯冷水和一杯温水。
> 第 7 秒：装满一杯热水。
> 示例 3：
>
> 输入：amount = [5,0,0]
> 输出：5
> 解释：每秒装满一杯冷水。
>
>
> 提示：
>
> amount.length == 3
> 0 <= amount[i] <= 100

```java
class Solution {
    public int fillCups(int[] amount) {
        int ans=0;
        Arrays.sort(amount);
        while (amount[0]>0||amount[1]>0||amount[2]>0){
            Arrays.sort(amount);
            if(amount[2]>0&&amount[1]>0){
                ans++;
                amount[2]--;
                amount[1]--;
            }else{
                ans++;
                amount[2]--;
            }
        }

        return ans;
    }
}
```

### [6113. 无限集中的最小数字](https://leetcode.cn/problems/smallest-number-in-infinite-set/)

> 现有一个包含所有正整数的集合 [1, 2, 3, 4, 5, ...] 。
>
> 实现 SmallestInfiniteSet 类：
>
> SmallestInfiniteSet() 初始化 SmallestInfiniteSet 对象以包含 所有 正整数。
> int popSmallest() 移除 并返回该无限集中的最小整数。
> void addBack(int num) 如果正整数 num 不 存在于无限集中，则将一个 num 添加 到该无限集中。
>
>
> 示例：
>
> 输入
> ["SmallestInfiniteSet", "addBack", "popSmallest", "popSmallest", "popSmallest", "addBack", "popSmallest", "popSmallest", "popSmallest"]
> [[], [2], [], [], [], [1], [], [], []]
> 输出
> [null, null, 1, 2, 3, null, 1, 4, 5]
>
> 解释
> SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();
> smallestInfiniteSet.addBack(2);    // 2 已经在集合中，所以不做任何变更。
> smallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 是最小的整数，并将其从集合中移除。
> smallestInfiniteSet.popSmallest(); // 返回 2 ，并将其从集合中移除。
> smallestInfiniteSet.popSmallest(); // 返回 3 ，并将其从集合中移除。
> smallestInfiniteSet.addBack(1);    // 将 1 添加到该集合中。
> smallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 在上一步中被添加到集合中，
>                                    // 且 1 是最小的整数，并将其从集合中移除。
> smallestInfiniteSet.popSmallest(); // 返回 4 ，并将其从集合中移除。
> smallestInfiniteSet.popSmallest(); // 返回 5 ，并将其从集合中移除。
>
>
> 提示：
>
> 1 <= num <= 1000
> 最多调用 popSmallest 和 addBack 方法 共计 1000 次

```java
class SmallestInfiniteSet {
    Set<Integer> s;
    PriorityQueue<Integer> q;
    int min_index=0;

    public SmallestInfiniteSet() {
        s=new LinkedHashSet<>();
        q=new PriorityQueue<>();
        for(int i=1;i<=1000;i++){
            s.add(i);
            q.add(i);
        }
    }

    public int popSmallest() {
        int num=q.poll();
        s.remove(num);
        return num;
    }

    public void addBack(int num) {
        if(!s.contains(num)){
            q.add(num);
            s.add(num);
        }
    }
}
```

1. 优先队列：PriorityQueue
2. PriorityQueue的排序方式分为两种，一种是自然排序，这是按照加入元素的大小从小到大排序的。第二种是定制排序，是使用comparator类来重写compare(Object o1,Object o2)方法来实现定制排序的。

```java
import java.util.PriorityQueue;  
public class PriorityQueueTest3   
{  
    public static void main(String[] args)   
    {  
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.offer(6);
        pq.offer(-3);
        pq.offer(0);
        pq.offer(9);
        for(int i:pq){
            System.out.println(i);
        }
    }  
}  
```

​	输出结果：[-3,6,0,9]

​	原因是堆排序只会保证第一个元素也就是根节点的元素是当前优先队列里最小（或者最大）的元素，而且每一次变化之后，比如offer()或者poll()之后，都会进行堆重排

```java
PriorityQueue pq = new PriorityQueue();
pq.offer(6);
pq.offer(-3);
pq.offer(0);
pq.offer(9);
while (!pq.isEmpty()){
    System.out.println(pq.poll());
}
```

### [2337. 移动片段得到字符串](https://leetcode.cn/problems/move-pieces-to-obtain-a-string/)

> 给你两个字符串 start 和 target ，长度均为 n 。每个字符串 仅 由字符 'L'、'R' 和 '_' 组成，其中：
>
> 字符 'L' 和 'R' 表示片段，其中片段 'L' 只有在其左侧直接存在一个 空位 时才能向 左 移动，而片段 'R' 只有在其右侧直接存在一个 空位 时才能向 右 移动。
> 字符 '_' 表示可以被 任意 'L' 或 'R' 片段占据的空位。
> 如果在移动字符串 start 中的片段任意次之后可以得到字符串 target ，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：start = "_L__R__R_", target = "L______RR"
> 输出：true
> 解释：可以从字符串 start 获得 target ，需要进行下面的移动：
> - 将第一个片段向左移动一步，字符串现在变为 "L___R__R_" 。
> - 将最后一个片段向右移动一步，字符串现在变为 "L___R___R" 。
> - 将第二个片段向右移动散步，字符串现在变为 "L______RR" 。
> 可以从字符串 start 得到 target ，所以返回 true 。
> 示例 2：
>
> 输入：start = "R_L_", target = "__LR"
> 输出：false
> 解释：字符串 start 中的 'R' 片段可以向右移动一步得到 "_RL_" 。
> 但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到 target 。
> 示例 3：
>
> 输入：start = "_R", target = "R_"
> 输出：false
> 解释：字符串 start 中的片段只能向右移动，所以无法从字符串 start 得到 target 。
>
>
> 提示：
>
> n == start.length == target.length
> 1 <= n <= 10^5
> start 和 target 由字符 'L'、'R' 和 '_' 组成

```java
class Solution {
    public boolean canChange(String start, String target) {
        if(!start.replaceAll("_","").equals(target.replaceAll("_",""))){
            return false;//如果可以相同的话，去掉_后的字符串应该相同
        }
        int len=start.length();
        int i=0,j=0;
        //L:i>=j  R:i<=j；如果字符串相同，那么就需要检验`_`的位置了。对于start字符串，如果找到L的话，由于L只能往左移动，因此start的L必须在target的右边；对于R同样如此分析
        for(;i<len;i++){
            if(start.charAt(i)=='_') continue;
            while (target.charAt(j)=='_'){
                j++;
            }
            if(start.charAt(i)=='L'){
                if(i<j) return false;
            } else if (start.charAt(i)=='R') {
                if(i>j) return false;
            }
            j++;
        }

        return true;
    }
}
```

## 第 249 场周赛

### [1929. 数组串联](https://leetcode.cn/problems/concatenation-of-array/)

> 给你一个长度为 n 的整数数组 nums 。请你构建一个长度为 2n 的答案数组 ans ，数组下标 从 0 开始计数 ，对于所有 0 <= i < n 的 i ，满足下述所有要求：
>
> ans[i] == nums[i]
> ans[i + n] == nums[i]
> 具体而言，ans 由两个 nums 数组 串联 形成。
>
> 返回数组 ans 。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,2,1]
> 输出：[1,2,1,1,2,1]
> 解释：数组 ans 按下述方式形成：
> - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
> - ans = [1,2,1,1,2,1]
> 示例 2：
>
> 输入：nums = [1,3,2,1]
> 输出：[1,3,2,1,1,3,2,1]
> 解释：数组 ans 按下述方式形成：
> - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
> - ans = [1,3,2,1,1,3,2,1]
>
>
> 提示：
>
> n == nums.length
> 1 <= n <= 1000
> 1 <= nums[i] <= 1000

```java
class Solution {
    public int[] getConcatenation(int[] nums) {
        int[] ans=new int[nums.length*2];
        for(int i=0;i<nums.length;i++){
            ans[i]=ans[i+nums.length]=nums[i];
        }
        
        return ans;
    }
}
```

### [1930. 长度为 3 的不同回文子序列](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/)

> 给你一个字符串 s ，返回 s 中 长度为 3 的不同回文子序列 的个数。
>
> 即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。
>
> 回文 是正着读和反着读一样的字符串。
>
> 子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。
>
> 例如，"ace" 是 "abcde" 的一个子序列。
>
>
> 示例 1：
>
> 输入：s = "aabca"
> 输出：3
> 解释：长度为 3 的 3 个回文子序列分别是：
> - "aba" ("aabca" 的子序列)
> - "aaa" ("aabca" 的子序列)
> - "aca" ("aabca" 的子序列)
> 示例 2：
>
> 输入：s = "adc"
> 输出：0
> 解释："adc" 不存在长度为 3 的回文子序列。
> 示例 3：
>
> 输入：s = "bbcbaba"
> 输出：4
> 解释：长度为 3 的 4 个回文子序列分别是：
> - "bbb" ("bbcbaba" 的子序列)
> - "bcb" ("bbcbaba" 的子序列)
> - "bab" ("bbcbaba" 的子序列)
> - "aba" ("bbcbaba" 的子序列)
>
>
> 提示：
>
> 3 <= s.length <= 10^5
> s 仅由小写英文字母组成

```java
class Solution {
    public int countPalindromicSubsequence(String s) {
        int ans=0,n=s.length();
        for(int i=0;i<26;i++){
            int[] array=new int[26];
            char c=(char) (97+i);
            int left=s.indexOf(c);
            int right=s.lastIndexOf(c);
            for(int j=left+1;j<right;j++) array[s.charAt(j)-97]++;
            for(int j=0;j<26;j++)
                if(array[j]>0) ans++;
        }

        return ans;
    }
}
```

## 第 233 场周赛

### [1800. 最大升序子数组和](https://leetcode.cn/problems/maximum-ascending-subarray-sum/)

> 给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。
>
> 子数组是数组中的一个连续数字序列。
>
> 已知子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，若对所有 i（l <= i < r），numsi < numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。
>
>  
>
> 示例 1：
>
> 输入：nums = [10,20,30,5,10,50]
> 输出：65
> 解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。
> 示例 2：
>
> 输入：nums = [10,20,30,40,50]
> 输出：150
> 解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 
> 示例 3：
>
> 输入：nums = [12,17,15,13,10,11,12]
> 输出：33
> 解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 
> 示例 4：
>
> 输入：nums = [100,10,1]
> 输出：100
>
>
> 提示：
>
> 1 <= nums.length <= 100
> 1 <= nums[i] <= 100

```java
class Solution {
    public int maxAscendingSum(int[] nums) {
        int ans=nums[0],temp=nums[0];
        for(int i=1;i<nums.length;i++){
            if(nums[i-1]<nums[i]) {
                temp+=nums[i];
                ans=Math.max(temp,ans);
            }
            else temp=nums[i];
        }

        return ans;
    }
}
```

### [1801. 积压订单中的订单总数](https://leetcode.cn/problems/number-of-orders-in-the-backlog/)

> 给你一个二维整数数组 orders ，其中每个 orders[i] = [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。
>
> 订单类型 orderTypei 可以分为两种：
>
> 0 表示这是一批采购订单 buy
> 1 表示这是一批销售订单 sell
> 注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。
>
> 存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：
>
> 如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。
> 反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。
> 输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex1.png)
>
>
> 输入：orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]
> 输出：6
> 解释：输入订单后会发生下述情况：
> - 提交 5 笔采购订单，价格为 10 。没有销售订单，所以这 5 笔订单添加到积压订单中。
> - 提交 2 笔销售订单，价格为 15 。没有采购订单的价格大于或等于 15 ，所以这 2 笔订单添加到积压订单中。
> - 提交 1 笔销售订单，价格为 25 。没有采购订单的价格大于或等于 25 ，所以这 1 笔订单添加到积压订单中。
> - 提交 4 笔采购订单，价格为 30 。前 2 笔采购订单与价格最低（价格为 15）的 2 笔销售订单匹配，从积压订单中删除这 2 笔销售订单。第 3 笔采购订单与价格最低的 1 笔销售订单匹配，销售订单价格为 25 ，从积压订单中删除这 1 笔销售订单。积压订单中不存在更多销售订单，所以第 4 笔采购订单需要添加到积压订单中。
> 最终，积压订单中有 5 笔价格为 10 的采购订单，和 1 笔价格为 30 的采购订单。所以积压订单中的订单总数为 6 。
> 示例 2：
> - ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex2.png)
>
>
> 输入：orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]
> 输出：999999984
> 解释：输入订单后会发生下述情况：
> - 提交 109 笔销售订单，价格为 7 。没有采购订单，所以这 109 笔订单添加到积压订单中。
> - 提交 3 笔采购订单，价格为 15 。这些采购订单与价格最低（价格为 7 ）的 3 笔销售订单匹配，从积压订单中删除这 3 笔销售订单。
> - 提交 999999995 笔采购订单，价格为 5 。销售订单的最低价为 7 ，所以这 999999995 笔订单添加到积压订单中。
> - 提交 1 笔销售订单，价格为 5 。这笔销售订单与价格最高（价格为 5 ）的 1 笔采购订单匹配，从积压订单中删除这 1 笔采购订单。
> 最终，积压订单中有 (1000000000-3) 笔价格为 7 的销售订单，和 (999999995-1) 笔价格为 5 的采购订单。所以积压订单中的订单总数为 1999999991 ，等于 999999984 % (109 + 7) 。
>
>
> 提示：
>
> 1 <= orders.length <= 10^5
> orders[i].length == 3
> 1 <= pricei, amounti <= 10^9
> orderTypei 为 0 或 1

```java
class Solution {
    public int getNumberOfBacklogOrders(int[][] orders) {
        PriorityQueue<int[]> buy = new PriorityQueue<>((a,b)->b[0]-a[0]);
        PriorityQueue<int[]> sell = new PriorityQueue<>((a,b)->a[0]-b[0]);
        long ans = 0l;
        for (int[] i : orders) {
            int price = i[0];
            int num = i[1];
            if (i[2] == 0) {
                while (num > 0 && sell.size() > 0 && price >= sell.peek()[0]) {
                    if (num >= sell.peek()[1]) {
                        ans -= sell.peek()[1];
                        num -= sell.peek()[1];
                        sell.poll();
                    } else {
                        ans -= num;
                        sell.peek()[1] -= num;
                        num = 0;
                    }
                }
                if (num > 0) buy.offer(new int[]{price, num});
                ans += num;
            } else if (i[2] == 1) {
                while (num > 0 && buy.size() > 0 && price <= buy.peek()[0]) {
                    if (num >= buy.peek()[1]) {
                        ans -= buy.peek()[1];
                        num -= buy.peek()[1];
                        buy.poll();
                    } else {
                        ans -= num;
                        buy.peek()[1] -= num;
                        num = 0;
                    }
                }
                if (num > 0) sell.offer(new int[]{price, num});
                ans += num;
            }
        }

        return (int) (ans % ((int) 1e9 + 7));
    }
}
```

1. 优先队列可以在之前定义好规则
2. 排序也是需要需要时间的，因此最好不要把sort写在for循环里面

## 第 246 场周赛

### [1903. 字符串中的最大奇数](https://leetcode.cn/problems/largest-odd-number-in-string/)

> 给你一个字符串 num ，表示一个大整数。请你在字符串 num 的所有 非空子字符串 中找出 值最大的奇数 ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 "" 。
>
> 子字符串 是字符串中的一个连续的字符序列。
>
>  
>
> 示例 1：
>
> 输入：num = "52"
> 输出："5"
> 解释：非空子字符串仅有 "5"、"2" 和 "52" 。"5" 是其中唯一的奇数。
> 示例 2：
>
> 输入：num = "4206"
> 输出：""
> 解释：在 "4206" 中不存在奇数。
> 示例 3：
>
> 输入：num = "35427"
> 输出："35427"
> 解释："35427" 本身就是一个奇数。
>
>
> 提示：
>
> 1 <= num.length <= 10^5
> num 仅由数字组成且不含前导零

```java
class Solution {
    public String largestOddNumber(String num) {
        int n=num.length();
        int index=n-1;
        while (index>=0){
            if((num.charAt(index)-'0')%2==1) break;
            index--;
        }

        return index==-1 ? "":num.substring(0,index+1);
    }
}
```

### [1904. 你完成的完整对局数](https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/)

> 一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。这意味着，在 HH:00、HH:15、HH:30 和 HH:45 ，将会开始一个新的对局，其中 HH 用一个从 00 到 23 的整数表示。游戏中使用 24 小时制的时钟 ，所以一天中最早的时间是 00:00 ，最晚的时间是 23:59 。
>
> 给你两个字符串 startTime 和 finishTime ，均符合 "HH:MM" 格式，分别表示你 进入 和 退出 游戏的确切时间，请计算在整个游戏会话期间，你完成的 完整对局的对局数 。
>
> 例如，如果 startTime = "05:20" 且 finishTime = "05:59" ，这意味着你仅仅完成从 05:30 到 05:45 这一个完整对局。而你没有完成从 05:15 到 05:30 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 05:45 到 06:00 的完整对局，因为你是在对局结束前退出的游戏。
> 如果 finishTime 早于 startTime ，这表示你玩了个通宵（也就是从 startTime 到午夜，再从午夜到 finishTime）。
>
> 假设你是从 startTime 进入游戏，并在 finishTime 退出游戏，请计算并返回你完成的 完整对局的对局数 。
>
>  
>
> 示例 1：
>
> 输入：startTime = "12:01", finishTime = "12:44"
> 输出：1
> 解释：你完成了从 12:15 到 12:30 的一个完整对局。
> 你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。
> 你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。
> 示例 2：
>
> 输入：startTime = "20:00", finishTime = "06:00"
> 输出：40
> 解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。
> 16 + 24 = 40
> 示例 3：
>
> 输入：startTime = "00:00", finishTime = "23:59"
> 输出：95
> 解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。
>
>
> 提示：
>
> startTime 和 finishTime 的格式为 HH:MM
> 00 <= HH <= 23
> 00 <= MM <= 59
> startTime 和 finishTime 不相等

```java
class Solution {
    public int numberOfRounds(String loginTime, String logoutTime) {
        int start_h = Integer.parseInt(loginTime.substring(0, 2));//小时
        int end_h = Integer.parseInt(logoutTime.substring(0, 2));//分钟
        int start_m = Integer.parseInt(loginTime.substring(3, 5));//小时
        int end_m = Integer.parseInt(logoutTime.substring(3, 5));//分钟
        int ans = 0;
        if (start_h > end_h || (start_h == end_h && end_m < start_m)) {//如果结束时间小于开始时间或者时间相等，结束分钟小于开始分钟
            ans += (23 - start_h + end_h) * 4;//差一些，就满一圈了圈数不满
        } else {
            ans += (end_h - start_h - 1) * 4;//少算一圈，用于相减
        }
        ans += (60 - start_m) / 15;//得到走完全部还需要几次
        ans += end_m / 15;//得到回到最初需要几次
        return ans >= 0 ? ans : 0;//如果小于0则为0
    }
}
```

### [2249. 统计圆内格点数目](https://leetcode.cn/problems/count-lattice-points-inside-a-circle/)

> 给你一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示网格上圆心为 (xi, yi) 且半径为 ri 的第 i 个圆，返回出现在 至少一个 圆内的 格点数目 。
>
> 注意：
>
> 格点 是指整数坐标对应的点。
> 圆周上的点 也被视为出现在圆内的点。
>
>
> 示例 1：
>
> <img src="https://assets.leetcode.com/uploads/2022/03/02/exa-11.png" alt="img" style="zoom:50%;" />
>
> 输入：circles = [[2,2,1]]
> 输出：5
> 解释：
> 给定的圆如上图所示。
> 出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。
> 像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。
> 因此，出现在至少一个圆内的格点数目是 5 。
> 示例 2：
>
> <img src="https://assets.leetcode.com/uploads/2022/03/02/exa-22.png" alt="img" style="zoom: 33%;" />
>
> 输入：circles = [[2,2,2],[3,4,1]]
> 输出：16
> 解释：
> 给定的圆如上图所示。
> 共有 16 个格点出现在至少一个圆内。
> 其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4) 。
>
>
> 提示：
>
> 1 <= circles.length <= 200
> circles[i].length == 3
> 1 <= xi, yi <= 100
> 1 <= ri <= min(xi, yi)

```java
class Solution {
    public int countLatticePoints(int[][] circles) {
        int[][] grid=new int[410][410];
        for (int[] i : circles) {
            int x = i[0], y = i[1], r = i[2];
            for (int j = y - r, temp = 0; j <= y + r; j++, temp++) {
                int m=(int) Math.ceil(x - Math.sqrt(r * r - (r - temp) * (r - temp))),n=(int) Math.floor(x + (int) Math.sqrt(r * r - (r - temp) * (r - temp)));
                for (int k = m; k<=n; k++) {
                    grid[k+200][j+200]=1;
                }
            }
        }

        int ans=0;
        for(int[] i:grid){
            for(int j:i){
                if(j==1) ans++;
            }
        }
        return ans;
    }
}
```

1. ceil：向上取整
2. floor：向下取整

## 第 261 场周赛

### [2027. 转换字符串的最少操作次数](https://leetcode.cn/problems/minimum-moves-to-convert-string/)

> 给你一个字符串 s ，由 n 个字符组成，每个字符不是 'X' 就是 'O' 。
>
> 一次 操作 定义为从 s 中选出 三个连续字符 并将选中的每个字符都转换为 'O' 。注意，如果字符已经是 'O' ，只需要保持 不变 。
>
> 返回将 s 中所有字符均转换为 'O' 需要执行的 最少 操作次数。
>
>  
>
> 示例 1：
>
> 输入：s = "XXX"
> 输出：1
> 解释：XXX -> OOO
> 一次操作，选中全部 3 个字符，并将它们转换为 'O' 。
> 示例 2：
>
> 输入：s = "XXOX"
> 输出：2
> 解释：XXOX -> OOOX -> OOOO
> 第一次操作，选择前 3 个字符，并将这些字符转换为 'O' 。
> 然后，选中后 3 个字符，并执行转换。最终得到的字符串全由字符 'O' 组成。
> 示例 3：
>
> 输入：s = "OOOO"
> 输出：0
> 解释：s 中不存在需要转换的 'X' 。
>
>
> 提示：
>
> 3 <= s.length <= 1000
> s[i] 为 'X' 或 'O'

```java
class Solution {
    public int minimumMoves(String s) {
        int ans=0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='X'){
                ans++;
                i+=2;
            }
        }
        
        return ans;
    }
}
```

### [2028. 找出缺失的观测数据](https://leetcode.cn/problems/find-missing-observations/)

> 现有一份 n + m 次投掷单个 六面 骰子的观测数据，骰子的每个面从 1 到 6 编号。观测数据中缺失了 n 份，你手上只拿到剩余 m 次投掷的数据。幸好你有之前计算过的这 n + m 次投掷数据的 平均值 。
>
> 给你一个长度为 m 的整数数组 rolls ，其中 rolls[i] 是第 i 次观测的值。同时给你两个整数 mean 和 n 。
>
> 返回一个长度为 n 的数组，包含所有缺失的观测数据，且满足这 n + m 次投掷的 平均值 是 mean 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。
>
> k 个数字的 平均值 为这些数字求和后再除以 k 。
>
> 注意 mean 是一个整数，所以 n + m 次投掷的总和需要被 n + m 整除。
>
>  
>
> 示例 1：
>
> 输入：rolls = [3,2,4,3], mean = 4, n = 2
> 输出：[6,6]
> 解释：所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4 。
> 示例 2：
>
> 输入：rolls = [1,5,6], mean = 3, n = 4
> 输出：[2,3,2,2]
> 解释：所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3 。
> 示例 3：
>
> 输入：rolls = [1,2,3,4], mean = 6, n = 4
> 输出：[]
> 解释：无论丢失的 4 次数据是什么，平均值都不可能是 6 。
> 示例 4：
>
> 输入：rolls = [1], mean = 3, n = 1
> 输出：[5]
> 解释：所有 n + m 次投掷的平均值是 (1 + 5) / 2 = 3 。
>
>
> 提示：
>
> m == rolls.length
> 1 <= n, m <= 10^5
> 1 <= rolls[i], mean <= 6

```java
class Solution {
    public int[] missingRolls(int[] rolls, int mean, int n) {
        int sum_pre=0;
        for(int i:rolls) sum_pre+=i;
        int num=mean*(rolls.length+n)-sum_pre;

        if(num<n||num>n*6) return new int[]{};

        int[] ans=new int[n];
        while (n!=0){
            for(int i=0;i<ans.length&&num>0;i++){
                ans[i]++;
                num--;
            }
            if(num==0) break;
        }

        return ans;
    }
}
```

1. 通过不断地给数组值+1
2. return new int[1];返回结果是[0]
3. return new int[]{};返回结果是{};

### [2029. 石子游戏 IX](https://leetcode.cn/problems/stone-game-ix/)

> Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。
>
> Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。
>
> 如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。
> 如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。
> 假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：stones = [2,1]
> 输出：true
> 解释：游戏进行如下：
> - 回合 1：Alice 可以移除任意一个石子。
> - 回合 2：Bob 移除剩下的石子。 
> 已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。
> 示例 2：
>
> 输入：stones = [2]
> 输出：false
> 解释：Alice 会移除唯一一个石子，已移除石子的值总和为 2 。 
> 由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。
> 示例 3：
>
> 输入：stones = [5,1,2,4,3]
> 输出：false
> 解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：
> - 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。
> - 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。
> - 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。
> - 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.
> - 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15.
> Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。
>
>
> 提示：
>
> 1 <= stones.length <= 10^5
> 1 <= stones[i] <= 10^4

```java
```

## 第 215 场周赛

### [1656. 设计有序流](https://leetcode.cn/problems/design-an-ordered-stream/)

> 有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。
>
> 设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。
>
> 实现 OrderedStream 类：
>
> OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。
> String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后：
> 如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个  id + 1 。
> 否则，返回一个空列表。
>
>  
>
> 示例：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/15/q1.gif)
>
> 输入
> ["OrderedStream", "insert", "insert", "insert", "insert", "insert"]
> [[5], [3, "ccccc"], [1, "aaaaa"], [2, "bbbbb"], [5, "eeeee"], [4, "ddddd"]]
> 输出
> [null, [], ["aaaaa"], ["bbbbb", "ccccc"], [], ["ddddd", "eeeee"]]
>
> 解释
> OrderedStream os= new OrderedStream(5);
> os.insert(3, "ccccc"); // 插入 (3, "ccccc")，返回 []
> os.insert(1, "aaaaa"); // 插入 (1, "aaaaa")，返回 ["aaaaa"]
> os.insert(2, "bbbbb"); // 插入 (2, "bbbbb")，返回 ["bbbbb", "ccccc"]
> os.insert(5, "eeeee"); // 插入 (5, "eeeee")，返回 []
> os.insert(4, "ddddd"); // 插入 (4, "ddddd")，返回 ["ddddd", "eeeee"]
>
>
> 提示：
>
> 1 <= n <= 1000
> 1 <= id <= n
> value.length == 5
> value 仅由小写字母组成
> 每次调用 insert 都会使用一个唯一的 id
> 恰好调用 n 次 insert

```java
class OrderedStream {

    List<String> l;
    int ptr;

    public OrderedStream(int n) {
        l=new ArrayList<>();

        for(int i=0;i<n;i++) l.add("");

        ptr=0;
    }

    public List<String> insert(int idKey, String value) {
        if(l.get(idKey-1).equals("")) {
            l.remove(idKey-1);
            l.add(idKey-1,value);
        }

        List<String> ans=new ArrayList<>(){};
        if(idKey-1==ptr){
            for(;ptr<l.size();ptr++){
                if(!l.get(ptr).equals("")) ans.add(l.get(ptr));
                else break;
            }
        }else return ans;

        return ans;
    }
}
```

1. 集合指定大小后并不会开辟空间，需要赋值为其分配空间

### [1657. 确定两个字符串是否接近](https://leetcode.cn/problems/determine-if-two-strings-are-close/)

> 如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：
>
> 操作 1：交换任意两个 现有 字符。
> 例如，abcde -> aecdb
> 操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。
> 例如，aacabb -> bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）
> 你可以根据需要对任意一个字符串多次使用这两种操作。
>
> 给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：word1 = "abc", word2 = "bca"
> 输出：true
> 解释：2 次操作从 word1 获得 word2 。
> 执行操作 1："abc" -> "acb"
> 执行操作 1："acb" -> "bca"
> 示例 2：
>
> 输入：word1 = "a", word2 = "aa"
> 输出：false
> 解释：不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。
> 示例 3：
>
> 输入：word1 = "cabbba", word2 = "abbccc"
> 输出：true
> 解释：3 次操作从 word1 获得 word2 。
> 执行操作 1："cabbba" -> "caabbb"
> 执行操作 2："caabbb" -> "baaccc"
> 执行操作 2："baaccc" -> "abbccc"
> 示例 4：
>
> 输入：word1 = "cabbba", word2 = "aabbss"
> 输出：false
> 解释：不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。
>
>
> 提示：
>
> 1 <= word1.length, word2.length <= 10^5
> word1 和 word2 仅包含小写英文字母

```java
class Solution {
    public boolean closeStrings(String word1, String word2) {
        if (word1.length() != word2.length()) return false;
        boolean flag = true;
        HashMap<Character, Integer> h1 = new HashMap<>();
        HashMap<Character, Integer> h2 = new HashMap<>();
        for (int i = 0; i < word1.length(); i++) h1.put(word1.charAt(i), h1.getOrDefault(word1.charAt(i), 0) + 1);
        for (int i = 0; i < word2.length(); i++) h2.put(word2.charAt(i), h2.getOrDefault(word2.charAt(i), 0) + 1);
        for (int i = 0; i < word1.length(); i++) {
            if (!h1.containsKey(word1.charAt(i)) && h2.containsKey(word1.charAt(i)) || h1.containsKey(word1.charAt(i)) && !h2.containsKey(word1.charAt(i)))
                flag = false;
        }
        if (flag == false) return false;

        HashMap<Integer, Integer> h3 = new HashMap<>();
        HashMap<Integer, Integer> h4 = new HashMap<>();

        Set<Character> s0 = h1.keySet();
        for (Character i : s0) {
            h3.put(h1.get(i), h3.getOrDefault(h1.get(i), 0) + 1);
        }

        Set<Character> s1 = h2.keySet();
        for (Character i : s1) {
            h4.put(h2.get(i), h4.getOrDefault(h2.get(i), 0) + 1);
        }

        Set<Integer> s2 = h3.keySet();
        for (int i : s2) {
            if (h3.get(i) != h4.get(i)) return false;
        }

        return true;
    }
}
```

正确解法

![image-20220716000329457](C:/Users/Demon%20Night/AppData/Roaming/Typora/typora-user-images/image-20220716000329457.png)

### [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

> 给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。
>
> 如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,1,4,2,3], x = 5
> 输出：2
> 解释：最佳解决方案是移除后两个元素，将 x 减到 0 。
> 示例 2：
>
> 输入：nums = [5,6,7,8,9], x = 4
> 输出：-1
> 示例 3：
>
> 输入：nums = [3,2,20,1,1,3], x = 10
> 输出：5
> 解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。
>
>
> 提示：
>
> 1 <= nums.length <= 10^5
> 1 <= nums[i] <= 10^4
> 1 <= x <= 10^9

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        int sum = 0;
        for (int i : nums) sum += i;
        int num = sum - x;
        int l = 0, r = 0;
        if (num < 0) return -1;

        int temp = 0;
        int ans = -1;
        while (r < nums.length) {
            temp += nums[r];
            while (temp > num) {
                temp -= nums[l];
                l++;
            }
            if (temp == num) ans = Math.max(ans, r - l + 1);
            r++;
        }

        if(ans==-1) return -1;
        else return nums.length-ans;
    }
}
```

1. 滑动窗口

## 第 182 场周赛

### [1394. 找出数组中的幸运数](https://leetcode.cn/problems/find-lucky-integer-in-an-array/)

> 在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。
>
> 给你一个整数数组 arr，请你从中找出并返回一个幸运数。
>
> 如果数组中存在多个幸运数，只需返回 最大 的那个。
> 如果数组中不含幸运数，则返回 -1 。
>
>
> 示例 1：
>
> 输入：arr = [2,2,3,4]
> 输出：2
> 解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。
> 示例 2：
>
> 输入：arr = [1,2,2,3,3,3]
> 输出：3
> 解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。
> 示例 3：
>
> 输入：arr = [2,2,2,3,3]
> 输出：-1
> 解释：数组中不存在幸运数。
> 示例 4：
>
> 输入：arr = [5]
> 输出：-1
> 示例 5：
>
> 输入：arr = [7,7,7,7,7,7,7]
> 输出：7
>
>
> 提示：
>
> 1 <= arr.length <= 500
> 1 <= arr[i] <= 500

```java
class Solution {
    public int findLucky(int[] arr) {
        int[] a=new int[510];
        for(int i:arr) a[i]++;

        int ans=-1;
        for(int i=0;i<a.length;i++){
            if(a[i]==i&&i>0){
                ans=Math.max(ans,a[i]);
            }
        }
        
        return ans;
    }
}
```

### [1395. 统计作战单位数](https://leetcode.cn/problems/count-number-of-teams/)

>  n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。
>
> 每 3 个士兵可以组成一个作战单位，分组规则如下：
>
> 从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k]
> 作战单位需满足： rating[i] < rating[j] < rating[k] 或者 rating[i] > rating[j] > rating[k] ，其中  0 <= i < j < k < n
> 请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。
>
>  
>
> 示例 1：
>
> 输入：rating = [2,5,3,4,1]
> 输出：3
> 解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。
> 示例 2：
>
> 输入：rating = [2,1,3]
> 输出：0
> 解释：根据题目条件，我们无法组建作战单位。
> 示例 3：
>
> 输入：rating = [1,2,3,4]
> 输出：4
>
>
> 提示：
>
> n == rating.length
> 3 <= n <= 1000
> 1 <= rating[i] <= 10^5
> rating 中的元素都是唯一的

```java
class Solution {
    public int numTeams(int[] rating) {
        int n=rating.length;

        int a=n,b=0,c=0;
        int ans=0;
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n-1;j++) {
                for(int k=j+1;k<n;k++){
                    if ((rating[i] < rating[j] && rating[j] < rating[k]) || (rating[i] > rating[j] && rating[j] > rating[k])) {
                        ++ans;
                    }
                }
            }
        }
        
        return ans;
    }
}
```

### [1396. 设计地铁系统](https://leetcode.cn/problems/design-underground-system/)

> 地铁系统跟踪不同车站之间的乘客出行时间，并使用这一数据来计算从一站到另一站的平均时间。
>
> 实现 UndergroundSystem 类：
>
> void checkIn(int id, string stationName, int t)
> 通行卡 ID 等于 id 的乘客，在时间 t ，从 stationName 站进入
> 乘客一次只能从一个站进入
> void checkOut(int id, string stationName, int t)
> 通行卡 ID 等于 id 的乘客，在时间 t ，从 stationName 站离开
> double getAverageTime(string startStation, string endStation)
> 返回从 startStation 站到 endStation 站的平均时间
> 平均时间会根据截至目前所有从 startStation 站 直接 到达 endStation 站的行程进行计算，也就是从 startStation 站进入并从 endStation 离开的行程
> 从 startStation 到 endStation 的行程时间与从 endStation 到 startStation 的行程时间可能不同
> 在调用 getAverageTime 之前，至少有一名乘客从 startStation 站到达 endStation 站
> 你可以假设对 checkIn 和 checkOut 方法的所有调用都是符合逻辑的。如果一名乘客在时间 t1 进站、时间 t2 出站，那么 t1 < t2 。所有时间都按时间顺序发生。
>
>
> 示例 1：
>
> 输入
> ["UndergroundSystem","checkIn","checkIn","checkIn","checkOut","checkOut","checkOut","getAverageTime","getAverageTime","checkIn","getAverageTime","checkOut","getAverageTime"]
> [[],[45,"Leyton",3],[32,"Paradise",8],[27,"Leyton",10],[45,"Waterloo",15],[27,"Waterloo",20],[32,"Cambridge",22],["Paradise","Cambridge"],["Leyton","Waterloo"],[10,"Leyton",24],["Leyton","Waterloo"],[10,"Waterloo",38],["Leyton","Waterloo"]]
>
> 输出
> [null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]
>
> 解释
> UndergroundSystem undergroundSystem = new UndergroundSystem();
> undergroundSystem.checkIn(45, "Leyton", 3);
> undergroundSystem.checkIn(32, "Paradise", 8);
> undergroundSystem.checkIn(27, "Leyton", 10);
> undergroundSystem.checkOut(45, "Waterloo", 15);  // 乘客 45 "Leyton" -> "Waterloo" ，用时 15-3 = 12
> undergroundSystem.checkOut(27, "Waterloo", 20);  // 乘客 27 "Leyton" -> "Waterloo" ，用时 20-10 = 10
> undergroundSystem.checkOut(32, "Cambridge", 22); // 乘客 32 "Paradise" -> "Cambridge" ，用时 22-8 = 14
> undergroundSystem.getAverageTime("Paradise", "Cambridge"); // 返回 14.00000 。只有一个 "Paradise" -> "Cambridge" 的行程，(14) / 1 = 14
> undergroundSystem.getAverageTime("Leyton", "Waterloo");    // 返回 11.00000 。有两个 "Leyton" -> "Waterloo" 的行程，(10 + 12) / 2 = 11
> undergroundSystem.checkIn(10, "Leyton", 24);
> undergroundSystem.getAverageTime("Leyton", "Waterloo");    // 返回 11.00000
> undergroundSystem.checkOut(10, "Waterloo", 38);  // 乘客 10 "Leyton" -> "Waterloo" ，用时 38-24 = 14
> undergroundSystem.getAverageTime("Leyton", "Waterloo");    // 返回 12.00000 。有三个 "Leyton" -> "Waterloo" 的行程，(10 + 12 + 14) / 3 = 12
> 示例 2：
>
> 输入
> ["UndergroundSystem","checkIn","checkOut","getAverageTime","checkIn","checkOut","getAverageTime","checkIn","checkOut","getAverageTime"]
> [[],[10,"Leyton",3],[10,"Paradise",8],["Leyton","Paradise"],[5,"Leyton",10],[5,"Paradise",16],["Leyton","Paradise"],[2,"Leyton",21],[2,"Paradise",30],["Leyton","Paradise"]]
>
> 输出
> [null,null,null,5.00000,null,null,5.50000,null,null,6.66667]
>
> 解释
> UndergroundSystem undergroundSystem = new UndergroundSystem();
> undergroundSystem.checkIn(10, "Leyton", 3);
> undergroundSystem.checkOut(10, "Paradise", 8); // 乘客 10 "Leyton" -> "Paradise" ，用时 8-3 = 5
> undergroundSystem.getAverageTime("Leyton", "Paradise"); // 返回 5.00000 ，(5) / 1 = 5
> undergroundSystem.checkIn(5, "Leyton", 10);
> undergroundSystem.checkOut(5, "Paradise", 16); // 乘客 5 "Leyton" -> "Paradise" ，用时 16-10 = 6
> undergroundSystem.getAverageTime("Leyton", "Paradise"); // 返回 5.50000 ，(5 + 6) / 2 = 5.5
> undergroundSystem.checkIn(2, "Leyton", 21);
> undergroundSystem.checkOut(2, "Paradise", 30); // 乘客 2 "Leyton" -> "Paradise" ，用时 30-21 = 9
> undergroundSystem.getAverageTime("Leyton", "Paradise"); // 返回 6.66667 ，(5 + 6 + 9) / 3 = 6.66667
>
>
> 提示：
>
> 1 <= id, t <= 10^6
> 1 <= stationName.length, startStation.length, endStation.length <= 10 次
> 所有字符串由大小写英文字母与数字组成
> 总共最多调用 checkIn、checkOut 和 getAverageTime 方法 2 * 10^4
> 与标准答案误差在 10-5 以内的结果都被视为正确结果

```java
class UndergroundSystem {
    public class node{
        private String station;
        private int time;

        public node(String station,int time){
            this.station=station;
            this.time=time;
        }

        public String getStation(){
            return station;
        }

        public int getTime(){
            return time;
        }
    }

    HashMap<Integer,node> check;
    HashMap<String,int[]> time;

    public UndergroundSystem() {
        check=new HashMap<>();
        time=new HashMap<>();
    }

    public void checkIn(int id, String stationName, int t) {
        node node=new node(stationName,t);
        check.put(id,node);
    }

    public void checkOut(int id, String stationName, int t) {
        node start_node=check.get(id);
        String start_station=start_node.getStation();
        int start_time=start_node.getTime();
        String key=start_station+","+stationName;
        time.putIfAbsent(key,new int[2]);
        int[] temp=time.get(key);
        temp[0]+=t-start_time;
        temp[1]++;
    }

    public double getAverageTime(String startStation, String endStation) {
        String key=startStation+","+endStation;
        int[] temp=time.get(key);
        return 1.0*temp[0]/temp[1];
    }
}
```

1. 注意类的使用
2. 注意哈希表putIfAbset()方法的使用

## 第 302 场周赛

### [6120. 数组能形成多少数对](https://leetcode.cn/problems/maximum-number-of-pairs-in-array/)

> 给你一个下标从 0 开始的整数数组 nums 。在一步操作中，你可以执行以下步骤：
>
> 从 nums 选出 两个 相等的 整数
> 从 nums 中移除这两个整数，形成一个 数对
> 请你在 nums 上多次执行此操作直到无法继续执行。
>
> 返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目，answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,3,2,1,3,2,2]
> 输出：[3,1]
> 解释：
> nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。
> nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。
> nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。
> 无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。
> 示例 2：
>
> 输入：nums = [1,1]
> 输出：[1,0]
> 解释：nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [] 。
> 无法形成更多数对。总共形成 1 个数对，nums 中剩下 0 个数字。
> 示例 3：
>
> 输入：nums = [0]
> 输出：[0,1]
> 解释：无法形成数对，nums 中剩下 1 个数字。
>
>
> 提示：
>
> 1 <= nums.length <= 100
> 0 <= nums[i] <= 100

```java
class Solution {
    public int[] numberOfPairs(int[] nums) {
        int[] a=new int[110];
        for(int i:nums) a[i]++;
        int[] ans=new int[2];
        for(int i:a){
            if(i>=2){
                ans[0]+=i/2;
                ans[1]+=i%2;
            }else ans[1]+=i;
        }
        
        return ans;
    }
}
```

### [6164. 数位和相等数对的最大和](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/)

> 给你一个下标从 0 开始的数组 nums ，数组中的元素都是 正 整数。请你选出两个下标 i 和 j（i != j），且 nums[i] 的数位和 与  nums[j] 的数位和相等。
>
> 请你找出所有满足条件的下标 i 和 j ，找出并返回 nums[i] + nums[j] 可以得到的 最大值 。
>
>  
>
> 示例 1：
>
> 输入：nums = [18,43,36,13,7]
> 输出：54
> 解释：满足条件的数对 (i, j) 为：
> - (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。
> - (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。
> 所以可以获得的最大和是 54 。
> 示例 2：
>
> 输入：nums = [10,12,19,14]
> 输出：-1
> 解释：不存在满足条件的数对，返回 -1 。
>
>
> 提示：
>
> 1 <= nums.length <= 10^5
> 1 <= nums[i] <= 10^9

```java
class Solution {
    public int maximumSum(int[] nums) {
        Arrays.sort(nums);
        int[] a=new int[nums.length];

        int index=-1;
        for(int i:nums){
            int temp=0;
            while (i>0){
                temp+=i%10;
                i/=10;
            }
            a[++index]=temp;
        }
        List<List<Integer>> l=new ArrayList<>();
        for(int i=0;i<100;i++){
            l.add(new ArrayList<>());
        }
        for(int i=0;i<a.length;i++){
            int num=a[i];
            l.get(num).add(nums[i]);
        }

        int ans=-1;
        for(List<Integer> i:l){
            Collections.sort(i);
            if(i.size()>1)
            ans=Math.max(i.get(i.size()-1)+i.get(i.size()-2),ans);
        }

        return ans;
    }
}
```

### [6121. 裁剪数字后查询第 K 小的数字](https://leetcode.cn/problems/query-kth-smallest-trimmed-number/)

> 给你一个下标从 0 开始的字符串数组 nums ，其中每个字符串 长度相等 且只包含数字。
>
> 再给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [ki, trimi] 。对于每个 queries[i] ，你需要：
>
> 将 nums 中每个数字 裁剪 到剩下 最右边 trimi 个数位。
> 在裁剪过后的数字中，找到 nums 中第 ki 小数字对应的 下标 。如果两个裁剪后数字一样大，那么下标 更小 的数字视为更小的数字。
> 将 nums 中每个数字恢复到原本字符串。
> 请你返回一个长度与 queries 相等的数组 answer，其中 answer[i]是第 i 次查询的结果。
>
> 提示：
>
> 裁剪到剩下 x 个数位的意思是不断删除最左边的数位，直到剩下 x 个数位。
> nums 中的字符串可能会有前导 0 。
>
>
> 示例 1：
>
> 输入：nums = ["102","473","251","814"], queries = [[1,1],[2,3],[4,2],[1,2]]
> 输出：[2,2,1,0]
> 解释：
> 1. 裁剪到只剩 1 个数位后，nums = ["2","3","1","4"] 。最小的数字是 1 ，下标为 2 。
> 2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。
> 3. 裁剪到剩 2 个数位后，nums = ["02","73","51","14"] 。第 4 小的数字是 73 ，下标为 1 。
> 4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。
>    注意，裁剪后数字 "02" 值为 2 。
>    示例 2：
>
> 输入：nums = ["24","37","96","04"], queries = [[2,1],[2,2]]
> 输出：[3,0]
> 解释：
> 1. 裁剪到剩 1 个数位，nums = ["4","7","6","4"] 。第 2 小的数字是 4 ，下标为 3 。
>    有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。
> 2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。
>
>
> 提示：
>
> 1 <= nums.length <= 100
> 1 <= nums[i].length <= 100
> nums[i] 只包含数字。
> 所有 nums[i].length 的长度 相同 。
> 1 <= queries.length <= 100
> queries[i].length == 2
> 1 <= ki <= nums.length
> 1 <= trimi <= nums[0].length

```java
class Solution {
    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {
        List<Integer> trim = new ArrayList<>();
        List<String> result = new ArrayList<>();
        int n = nums.length;
        for (int[] i : queries) trim.add(i[1]);
        int[] ans = new int[queries.length];

        for (int i = 0; i < trim.size(); i++) {
            result.clear();
            int tr = queries[i][1];
            int wei = queries[i][0];

            //找到比较数字
            for (int j = 0; j < n; j++) {
                int l = tr > nums[j].length() ? 0 : nums[j].length() - tr;
                int r = nums[j].length();
                result.add(nums[j].substring(l, r));
            }

            //值——下标
            HashMap<String, List<Integer>> num_wei = new HashMap<>();
            for (int k = 0; k < result.size(); k++) {
                num_wei.putIfAbsent(result.get(k), new ArrayList<>());
                List<Integer> temp = num_wei.get(result.get(k));
                temp.add(k);
            }

            //将键存放在集合中排序
            Set<String> key = num_wei.keySet();
            List<String> key_l = new ArrayList<>();
            for (String k : key) key_l.add(k);
            Collections.sort(key_l);

            int cur_len = 0;
            int pre_len = 0;
            for (int k = 0; k < key_l.size(); k++) {
                cur_len += num_wei.get(key_l.get(k)).size();
                if (cur_len >= wei) {
                    ans[i] = num_wei.get(key_l.get(k)).get(wei - pre_len - 1);
                    break;
                } else {
                    pre_len = cur_len;
                }
            }

        }

        return ans;
    }
}
```

## 第 154 场周赛

### [1189. “气球” 的最大数量](https://leetcode.cn/problems/maximum-number-of-balloons/)

> 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 "balloon"（气球）。
>
> 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 "balloon"。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex1_upd.jpeg)
>
> 输入：text = "nlaebolko"
> 输出：1
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex2_upd.jpeg)
>
> 输入：text = "loonbalxballpoon"
> 输出：2
> 示例 3：
>
> 输入：text = "leetcode"
> 输出：0
>
>
> 提示：
>
> 1 <= text.length <= 10^4
> text 全部由小写英文字

```java
class Solution {
    public int maxNumberOfBalloons(String text) {
        int a=0,b=0,l=0,o=0,n=0;
        int min=Integer.MAX_VALUE;
        for(int i=0;i<text.length();i++){
            if(text.charAt(i)=='a') a++;
            if(text.charAt(i)=='b') b++;
            if(text.charAt(i)=='l') l++;
            if(text.charAt(i)=='o') o++;
            if(text.charAt(i)=='n') n++;
        }

        int[] temp=new int[]{a,b,l/2,o/2,n};
        Arrays.sort(temp);
        return temp[0];
    }
}
```

### [1190. 反转每对括号间的子串](https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/)

> 给出一个字符串 s（仅含有小写英文字母和括号）。
>
> 请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。
>
> 注意，您的结果中 不应 包含任何括号。
>
>  
>
> 示例 1：
>
> 输入：s = "(abcd)"
> 输出："dcba"
> 示例 2：
>
> 输入：s = "(u(love)i)"
> 输出："iloveu"
> 解释：先反转子字符串 "love" ，然后反转整个字符串。
> 示例 3：
>
> 输入：s = "(ed(et(oc))el)"
> 输出："leetcode"
> 解释：先反转子字符串 "oc" ，接着反转 "etco" ，然后反转整个字符串。
> 示例 4：
>
> 输入：s = "a(bcdefghijkl(mno)p)q"
> 输出："apmnolkjihgfedcbq"
>
>
> 提示：
>
> 0 <= s.length <= 2000
> s 中只有小写英文字母和括号
> 题目测试用例确保所有括号都是成对出现的

```java
class Solution {
    public String reverseParentheses(String s) {
        Stack<String> queue = new Stack<>();//栈
        int n = s.length();//数据长度

        StringBuilder temp=new StringBuilder();//字符串
        for (int i = 0; i < n; i++) {//遍历每一个字符
            if(s.charAt(i)=='('){//如果遇到‘（’，就将连续子字符串放进栈内
                queue.push(temp.toString());//将当前层字符串加入到栈中
                temp=new StringBuilder("");//重置
            } else if (s.charAt(i)==')') {//如果遇到，就进行翻转
                temp.reverse();
                temp.insert(0,queue.pop());//当前层遍历完了
            }else {
                temp.append(s.charAt(i));//字符串进行拼接
            }
        }
        return temp.toString();
    }
}
```

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

> 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 子数组 是数组中的一个连续部分。
>
>  
>
> 示例 1：
>
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> 示例 2：
>
> 输入：nums = [1]
> 输出：1
> 示例 3：
>
> 输入：nums = [5,4,-1,7,8]
> 输出：23
>
>
> 提示：
>
> 1 <= nums.length <= 10^5
> -104 <= nums[i] <= 10^4

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        if(n==0) return 0;

        int[] dp=new int[n];
        dp[0]=nums[0];
        int ans=nums[0];
        for(int i=1;i<n;i++){
            dp[i]=Math.max(nums[i],nums[i]+dp[i-1]);
            ans=Math.max(dp[i],ans);
        }

        return ans;
    }
}
```



### [1191. K 次串联后最大子数组之和](https://leetcode.cn/problems/k-concatenation-maximum-sum/)

> 给定一个整数数组 arr 和一个整数 k ，通过重复 k 次来修改数组。
>
> 例如，如果 arr = [1, 2] ， k = 3 ，那么修改后的数组将是 [1, 2, 1, 2, 1, 2] 。
>
> 返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 0，在这种情况下它的总和也是 0。
>
> 由于 结果可能会很大，需要返回的 109 + 7 的 模 。
>
>  
>
> 示例 1：
>
> 输入：arr = [1,2], k = 3
> 输出：9
> 示例 2：
>
> 输入：arr = [1,-2,1], k = 5
> 输出：2
> 示例 3：
>
> 输入：arr = [-1,-2], k = 7
> 输出：0
>
>
> 提示：
>
> 1 <= arr.length <= 10^5
> 1 <= k <= 10^5
> -10^4 <= arr[i] <= 10^4

```java
```

## 第 37 场双周赛

### [1619. 删除某些元素后的数组均值](https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/)

> 给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。
>
> 与 标准答案 误差在 10-5 的结果都被视为正确结果。
>
>  
>
> 示例 1：
>
> 输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]
> 输出：2.00000
> 解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。
> 示例 2：
>
> 输入：arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]
> 输出：4.00000
> 示例 3：
>
> 输入：arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]
> 输出：4.77778
> 示例 4：
>
> 输入：arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]
> 输出：5.27778
> 示例 5：
>
> 输入：arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]
> 输出：5.29167
>
>
> 提示：
>
> 20 <= arr.length <= 1000
> arr.length 是 20 的 倍数 
> 0 <= arr[i] <= 10^5

```java
class Solution {
    public double trimMean(int[] arr) {
        Arrays.sort(arr);
        int len = arr.length;
        int l = (int) (len * 0.05);
        int r=len-(int) (len*0.05)-1;

        int sum=0;
        for(int i=l;i<=r;i++){
            sum+=arr[i];
        }

        return 1.0*sum/(r-l+1);
    }
}
```

### [1620. 网络信号最好的坐标](https://leetcode.cn/problems/coordinate-with-maximum-network-quality/)

> 给你一个数组 towers 和一个整数 radius ，数组中包含一些网络信号塔，其中 towers[i] = [xi, yi, qi] 表示第 i 个网络信号塔的坐标是 (xi, yi) 且信号强度参数为 qi 。所有坐标都是在  X-Y 坐标系内的 整数 坐标。两个坐标之间的距离用 欧几里得距离 计算。
>
> 整数 radius 表示一个塔 能到达 的 最远距离 。如果一个坐标跟塔的距离在 radius 以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 radius 以外的距离该塔是 不能到达的 。
>
> 如果第 i 个塔能到达 (x, y) ，那么该塔在此处的信号为 ⌊qi / (1 + d)⌋ ，其中 d 是塔跟此坐标的距离。一个坐标的 网络信号 是所有 能到达 该坐标的塔的信号强度之和。
>
> 请你返回 网络信号 最大的整数坐标点。如果有多个坐标网络信号一样大，请你返回字典序最小的一个坐标。
>
> 注意：
>
> 坐标 (x1, y1) 字典序比另一个坐标 (x2, y2) 小：要么 x1 < x2 ，要么 x1 == x2 且 y1 < y2 。
> ⌊val⌋ 表示小于等于 val 的最大整数（向下取整函数）。
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/untitled-diagram.png)
>
>
> 输入：towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2
> 输出：[2,1]
> 解释：
> 坐标 (2, 1) 信号强度之和为 13
> - 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7
> - 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2
> - 塔 (3, 1) 强度参数为 9 ，在该点强度为 ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4
> 没有别的坐标有更大的信号强度。
> 示例 2：
>
> 输入：towers = [[23,11,21]], radius = 9
> 输出：[23,11]
> 示例 3：
>
> 输入：towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2
> 输出：[1,2]
> 示例 4：
>
> 输入：towers = [[2,1,9],[0,1,9]], radius = 2
> 输出：[0,1]
> 解释：坐标 (0, 1) 和坐标 (2, 1) 都是强度最大的位置，但是 (0, 1) 字典序更小。
>
>
> 提示：
>
> 1 <= towers.length <= 50
> towers[i].length == 3
> 0 <= xi, yi, qi <= 50
> 1 <= radius <= 50

```java
class Solution {
    public int[] bestCoordinate(int[][] towers, int radius) {
        int ax = Integer.MAX_VALUE, ay = Integer.MAX_VALUE, bx = 0, by = 0;
        for (int[] tower : towers) {
            ax = Math.min(tower[0], ax);
            bx = Math.max(tower[0], bx);
            ay = Math.min(tower[1], ay);
            by = Math.max(tower[1], by);

        }

        int max = 0;
        int max_index_x = 0, max_index_y = 0;
        for (int i=ax;i<=bx;i++) {
            for(int k=ay;k<=by;k++){
                int sum = 0;
                for (int[] j : towers) {
                    if (Math.sqrt(Math.pow(j[0] - i, 2) + Math.pow(j[1] -k, 2)) <=radius )
                        sum += (int)( j[2] / (1 + Math.sqrt(Math.pow(j[0] -i, 2) + Math.pow(j[1] - k, 2))));
                }
                if (sum > max) {
                    max = sum;
                    max_index_x = i;
                    max_index_y = k;
                }
            }
        }

        return new int[]{max_index_x, max_index_y};
    }
}
```

### [1621. 大小为 K 的不重叠线段的数目](https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/)

> 给你一维空间的 n 个点，其中第 i 个点（编号从 0 到 n-1）位于 x = i 处，请你找到 恰好 k 个不重叠 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 整数坐标 。这 k 个线段不需要全部覆盖全部 n 个点，且它们的端点 可以 重合。
>
> 请你返回 k 个不重叠线段的方案数。由于答案可能很大，请将结果对 109 + 7 取余 后返回。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/ex1.png)
>
> 输入：n = 4, k = 2
> 输出：5
> 解释：
> 如图所示，两个线段分别用红色和蓝色标出。
> 上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，{(1,2),(2,3)}，{(0,1),(1,2)} 。
> 示例 2：
>
> 输入：n = 3, k = 1
> 输出：3
> 解释：总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。
> 示例 3：
>
> 输入：n = 30, k = 7
> 输出：796297179
> 解释：画 7 条线段的总方案数为 3796297200 种。将这个数对 109 + 7 取余得到 796297179 。
> 示例 4：
>
> 输入：n = 5, k = 3
> 输出：7
> 示例 5：
>
> 输入：n = 3, k = 2
> 输出：1
>
>
> 提示：
>
> 2 <= n <= 1000
> 1 <= k <= n-1

```java
```

## 第 125 场周赛 

### \997. 找到小镇的法官

> 小镇里有 `n` 个人，按从 `1` 到 `n` 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。
>
> 如果小镇法官真的存在，那么：
>
> 1. 小镇法官不会信任任何人。
> 2. 每个人（除了小镇法官）都信任这位小镇法官。
> 3. 只有一个人同时满足属性 **1** 和属性 **2** 。
>
> 给你一个数组 `trust` ，其中 `trust[i] = [ai, bi]` 表示编号为 `ai` 的人信任编号为 `bi` 的人。
>
> 如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 `-1` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 2, trust = [[1,2]]
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 3, trust = [[1,3],[2,3]]
> 输出：3
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 3, trust = [[1,3],[2,3],[3,1]]
> 输出：-1
> ```
>
>  
>
> **提示：**
>
> - `1 <= n <= 1000`
> - `0 <= trust.length <= 10^4`
> - `trust[i].length == 2`
> - `trust` 中的所有`trust[i] = [ai, bi]` **互不相同**
> - `ai != bi`
> - `1 <= ai, bi <= n`

```java
class Solution {
    public int findJudge(int n, int[][] trust) {
        int[] a=new int[n+1];
        for(int[] i:trust) {
            a[i[1]]++;
        }
        
        int ans=-1;
        outer:for(int i=0;i<a.length;i++){
            if(a[i]==n-1){
                for(int[] j:trust){
                    if(j[0]==i)break outer;
                }
                ans=i;
            }
        }

        return ans;
    }
}
```

### \999. 可以被一步捕获的棋子数

> 在一个 8 x 8 的棋盘上，有一个白色的车（`Rook`），用字符 `'R'` 表示。棋盘上还可能存在空方块，白色的象（`Bishop`）以及黑色的卒（`pawn`），分别用字符 `'.'`，`'B'` 和 `'p'` 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。
>
> 车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：
>
> - 棋手选择主动停下来。
> - 棋子因到达棋盘的边缘而停下。
> - 棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
> - 车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。
>
> 你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG)
>
> ```
> 输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
> 输出：3
> 解释：
> 在本例中，车能够捕获所有的卒。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_2_improved.PNG)
>
> ```
> 输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
> 输出：0
> 解释：
> 象阻止了车捕获任何卒。
> ```
>
> **示例 3：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_3_improved.PNG)
>
> ```
> 输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
> 输出：3
> 解释： 
> 车可以捕获位置 b5，d6 和 f5 的卒。
> ```
>
>  
>
> **提示：**
>
> 1. `board.length == board[i].length == 8`
> 2. `board[i][j]` 可以是 `'R'`，`'.'`，`'B'` 或 `'p'`
> 3. 只有一个格子上存在 `board[i][j] == 'R'`

```java
class Solution {
    public int numRookCaptures(char[][] board) {
        int index_x=0,index_y=0;
        int m=board.length,n=board[0].length;

        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]=='R'){
                    index_x=i;
                    index_y=j;
                }
            }
        }

        int ans=0;
        for(int i=index_y-1;i>=0;i--){
            if(board[index_x][i]=='B'||board[index_x][i]=='P') break;
            if(board[index_x][i]=='b'||board[index_x][i]=='p'){
                ans++;
                break;
            }
        }
        for(int i=index_x-1;i>=0;i--){
            if(board[i][index_y]=='B'||board[i][index_y]=='P') break;
            if(board[i][index_y]=='b'||board[i][index_y]=='p'){
                ans++;
                break;
            }
        }
        for(int i=index_y+1;i<n;i++){
            if(board[index_x][i]=='B'||board[index_x][i]=='P') break;
            if(board[index_x][i]=='b'||board[index_x][i]=='p'){
                ans++;
                break;
            }
        }
        for(int i=index_x+1;i<m;i++){
            if(board[i][index_y]=='B'||board[i][index_y]=='P') break;
            if(board[i][index_y]=='b'||board[i][index_y]=='p'){
                ans++;
                break;
            }
        }

        return ans;
    }
}
```

## 第 256 场周赛

### [1984. 学生分数的最小差值](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)

> 给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。
>
> 从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。
>
> 返回可能的 最小差值 。
>
>  
>
> 示例 1：
>
> 输入：nums = [90], k = 1
> 输出：0
> 解释：选出 1 名学生的分数，仅有 1 种方法：
> - [90] 最高分和最低分之间的差值是 90 - 90 = 0
> 可能的最小差值是 0
> 示例 2：
>
> 输入：nums = [9,4,1,7], k = 2
> 输出：2
> 解释：选出 2 名学生的分数，有 6 种方法：
> - [9,4,1,7] 最高分和最低分之间的差值是 9 - 4 = 5
> - [9,4,1,7] 最高分和最低分之间的差值是 9 - 1 = 8
> - [9,4,1,7] 最高分和最低分之间的差值是 9 - 7 = 2
> - [9,4,1,7] 最高分和最低分之间的差值是 4 - 1 = 3
> - [9,4,1,7] 最高分和最低分之间的差值是 7 - 4 = 3
> - [9,4,1,7] 最高分和最低分之间的差值是 7 - 1 = 6
> 可能的最小差值是 2
>
>
> 提示：
>
> 1 <= k <= nums.length <= 1000
> 0 <= nums[i] <= 10^5

```java
class Solution {
    public int minimumDifference(int[] nums, int k) {
        int n = nums.length;
        if (n == 1) return 0;

        Arrays.sort(nums);
        int ans=Integer.MAX_VALUE;
        for (int i = 0; i+k-1<n; i++) {
            ans=Math.min(nums[i+k-1]-nums[i],ans);
        }

        return ans;
    }
}
```

### [1985. 找出数组中的第 K 大整数](https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/)

> 给你一个字符串数组 nums 和一个整数 k 。nums 中的每个字符串都表示一个不含前导零的整数。
>
> 返回 nums 中表示第 k 大整数的字符串。
>
> 注意：重复的数字在统计时会视为不同元素考虑。例如，如果 nums 是 ["1","2","2"]，那么 "2" 是最大的整数，"2" 是第二大的整数，"1" 是第三大的整数。
>
>  
>
> 示例 1：
>
> 输入：nums = ["3","6","7","10"], k = 4
> 输出："3"
> 解释：
> nums 中的数字按非递减顺序排列为 ["3","6","7","10"]
> 其中第 4 大整数是 "3"
> 示例 2：
>
> 输入：nums = ["2","21","12","1"], k = 3
> 输出："2"
> 解释：
> nums 中的数字按非递减顺序排列为 ["1","2","12","21"]
> 其中第 3 大整数是 "2"
> 示例 3：
>
> 输入：nums = ["0","0"], k = 2
> 输出："0"
> 解释：
> nums 中的数字按非递减顺序排列为 ["0","0"]
> 其中第 2 大整数是 "0"
>
>
> 提示：
>
> 1 <= k <= nums.length <= 10^4
> 1 <= nums[i].length <= 100
> nums[i] 仅由数字组成
> nums[i] 不含任何前导零

```java
class Solution {
    public String kthLargestNumber(String[] nums, int k) {
        List<String> l=new ArrayList<>();
        for(String i:nums) l.add(i);
        Collections.sort(l, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                if(o1.length()==o2.length()) return o1.compareTo(o2);
                else return o1.length()-o2.length();
            }
        });



        return l.get(nums.length-k);
    }
}
```

## 第 172 场周赛

### [1323. 6 和 9 组成的最大数字](https://leetcode.cn/problems/maximum-69-number/)

> 给你一个仅由数字 6 和 9 组成的正整数 num。
>
> 你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。
>
> 请返回你可以得到的最大数字。
>
>  
>
> 示例 1：
>
> 输入：num = 9669
> 输出：9969
> 解释：
> 改变第一位数字可以得到 6669 。
> 改变第二位数字可以得到 9969 。
> 改变第三位数字可以得到 9699 。
> 改变第四位数字可以得到 9666 。
> 其中最大的数字是 9969 。
> 示例 2：
>
> 输入：num = 9996
> 输出：9999
> 解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。
> 示例 3：
>
> 输入：num = 9999
> 输出：9999
> 解释：无需改变就已经是最大的数字了。
>
>
> 提示：
>
> 1 <= num <= 10^4
> num 每一位上的数字都是 6 或者 9 。

```java
class Solution {
    public int maximum69Number (int num) {
        List<Integer> l=new ArrayList<>();
        while (num>0){
            l.add(num%10);
            num/=10;
        }
        int[] arr=new int[l.size()];
        for(int i=0;i<l.size();i++) arr[i]=l.get(i);

        int ans=0;
        int n=1;
        for(int i=l.size()-1;i>=0;i--){
            if(arr[i]==6&&n==1) {
                arr[i]=9;
                n--;
            }
            ans=ans*10+arr[i];
        }

        return ans;
    }
}
```

### [1324. 竖直打印单词](https://leetcode.cn/problems/print-words-vertically/)

> 给你一个字符串 s。请你按照单词在 s 中的出现顺序将它们全部竖直返回。
> 单词应该以字符串列表的形式返回，必要时用空格补位，但输出尾部的空格需要删除（不允许尾随空格）。
> 每个单词只能放在一列上，每一列中也只能有一个单词。
>
>  
>
> 示例 1：
>
> 输入：s = "HOW ARE YOU"
> 输出：["HAY","ORO","WEU"]
> 解释：每个单词都应该竖直打印。 
>  "HAY"
>  "ORO"
>  "WEU"
> 示例 2：
>
> 输入：s = "TO BE OR NOT TO BE"
> 输出：["TBONTB","OEROOE","   T"]
> 解释：题目允许使用空格补位，但不允许输出末尾出现空格。
> "TBONTB"
> "OEROOE"
> "   T"
> 示例 3：
>
> 输入：s = "CONTEST IS COMING"
> 输出：["CIC","OSO","N M","T I","E N","S G","T"]
>
>
> 提示：
>
> 1 <= s.length <= 200
> s 仅含大写英文字母。
> 题目数据保证两个单词之间只有一个空格。

```java
class Solution {
    public List<String> printVertically(String s) {
        String[] s1 = s.split(" ");

        int max_len = 0;
        for (String i : s1) max_len = Math.max(max_len, i.length());
        StringBuilder[] ans = new StringBuilder[max_len];
        for (int i = 0; i < ans.length; i++) ans[i] = new StringBuilder("");
        int temp=-1;
        for (int i = 0; i < max_len; i++) {//容器的位置
            temp++;//字符的位置
            for (int k = 0; k < s1.length; k++) {//哪个字符串
                if ( temp< s1[k].length()) ans[i].append(String.valueOf(s1[k].charAt(temp)));
                else ans[i].append(" ");
            }
        }
        List<String> temp1 = new ArrayList<>();
        for (StringBuilder i : ans) {
            int index=i.length();
            for(int j=i.length()-1;j>=0;j--){
                if(i.charAt(j)==' ')index--;
                else break;
            }
            temp1.add(i.substring(0,index).toString());
        }
        return temp1;
    }
}
```

### [1325. 删除给定值的叶子节点](https://leetcode.cn/problems/delete-leaves-with-a-given-value/)

> 给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。
>
> 注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。
>
> 也就是说，你需要重复此过程直到不能继续删除。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_1_1684.png)
>
> 输入：root = [1,2,3,2,null,2,4], target = 2
> 输出：[1,null,3,null,4]
> 解释：
> 上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。
> 有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_2_1684.png)
>
> 输入：root = [1,3,3,3,2], target = 3
> 输出：[1,3,null,null,2]
> 示例 3：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_3_1684.png)
>
> 输入：root = [1,2,null,2,null,2], target = 2
> 输出：[1]
> 解释：每一步都删除一个绿色的叶子节点（值为 2）。
> 示例 4：
>
> 输入：root = [1,1,1], target = 1
> 输出：[]
> 示例 5：
>
> 输入：root = [1,2,3], target = 1
> 输出：[1,2,3]
>
>
> 提示：
>
> 1 <= target <= 1000
> 每一棵树最多有 3000 个节点。
> 每一个节点值的范围是 [1, 1000] 。

```java
class Solution {
    public TreeNode removeLeafNodes(TreeNode root, int target) {
        return dfs(root,target);
    }

    public TreeNode dfs(TreeNode root,int target){
        if(root==null) return null;
        root.left=dfs(root.left,target);
        root.right=dfs(root.right,target);
        if (root.left==null&&root.right==null&&root.val==target) return null;
        return root;
    }
}
```

## 第 212 场周赛

### \1629. 按键持续时间最长的键

> LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 `n` 个），每次一个。
>
> 给你一个长度为 `n` 的字符串 `keysPressed` ，其中 `keysPressed[i]` 表示测试序列中第 `i` 个被按下的键。`releaseTimes` 是一个升序排列的列表，其中 `releaseTimes[i]` 表示松开第 `i` 个键的时间。字符串和数组的 **下标都从 0 开始** 。第 `0` 个键在时间为 `0` 时被按下，接下来每个键都 **恰好** 在前一个键松开时被按下。
>
> 测试人员想要找出按键 **持续时间最长** 的键。第 `i` 次按键的持续时间为 `releaseTimes[i] - releaseTimes[i - 1]` ，第 `0` 次按键的持续时间为 `releaseTimes[0]` 。
>
> 注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。
>
> 请返回单次按键 **持续时间最长** 的键，如果有多个这样的键，则返回 **按字母顺序排列最大** 的那个键。
>
>  
>
> **示例 1：**
>
> ```
> 输入：releaseTimes = [9,29,49,50], keysPressed = "cbcd"
> 输出："c"
> 解释：按键顺序和持续时间如下：
> 按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）
> 按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）
> 按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）
> 按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）
> 按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20
> 'c' 按字母顺序排列比 'b' 大，所以答案是 'c'
> ```
>
> **示例 2：**
>
> ```
> 输入：releaseTimes = [12,23,36,46,62], keysPressed = "spuda"
> 输出："a"
> 解释：按键顺序和持续时间如下：
> 按下 's' ，持续时间 12
> 按下 'p' ，持续时间 23 - 12 = 11
> 按下 'u' ，持续时间 36 - 23 = 13
> 按下 'd' ，持续时间 46 - 36 = 10
> 按下 'a' ，持续时间 62 - 46 = 16
> 按键持续时间最长的键是 'a' ，持续时间 16
> ```
>
>  
>
> **提示：**
>
> - `releaseTimes.length == n`
> - `keysPressed.length == n`
> - `2 <= n <= 1000`
> - `1 <= releaseTimes[i] <= 10^9`
> - `releaseTimes[i] < releaseTimes[i+1]`
> - `keysPressed` 仅由小写英文字母组成

```java
class Solution {
    public char slowestKey(int[] releaseTimes, String keysPressed) {
        int n = releaseTimes.length;
        char ans = keysPressed.charAt(0);
        int maxTime = releaseTimes[0];
        for (int i = 1; i < n; i++) {
            char key = keysPressed.charAt(i);
            int time = releaseTimes[i] - releaseTimes[i - 1];
            if (time > maxTime || (time == maxTime && key > ans)) {
                ans = key;
                maxTime = time;
            }
        }
        return ans;
    }
}
```

### \1630. 等差子数组

> 如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 **等差数列** 。更正式地，数列 `s` 是等差数列，只需要满足：对于每个有效的 `i` ， `s[i+1] - s[i] == s[1] - s[0]` 都成立。
>
> 例如，下面这些都是 **等差数列** ：
>
> ```
> 1, 3, 5, 7, 9
> 7, 7, 7, 7
> 3, -1, -5, -9
> ```
>
> 下面的数列 **不是等差数列** ：
>
> ```
> 1, 1, 2, 5, 7
> ```
>
> 给你一个由 `n` 个整数组成的数组 `nums`，和两个由 `m` 个整数组成的数组 `l` 和 `r`，后两个数组表示 `m` 组范围查询，其中第 `i` 个查询对应范围 `[l[i], r[i]]` 。所有数组的下标都是 **从 0 开始** 的。
>
> 返回 `boolean` 元素构成的答案列表 `answer` 。如果子数组 `nums[l[i]], nums[l[i]+1], ... , nums[r[i]]` 可以 **重新排列** 形成 **等差数列** ，`answer[i]` 的值就是 `true`；否则`answer[i]` 的值就是 `false` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
> 输出：[true,false,true]
> 解释：
> 第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。
> 第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。
> 第 2 个查询，对应子数组 [5,9,3,7] 。可以重新排列为等差数列 [3,5,7,9] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
> 输出：[false,true,false,false,true,true]
> ```
>
>  
>
> **提示：**
>
> - `n == nums.length`
> - `m == l.length`
> - `m == r.length`
> - `2 <= n <= 500`
> - `1 <= m <= 500`
> - `0 <= l[i] < r[i] < n`
> - `-105 <= nums[i] <= 10^5`

```java
class Solution {
    public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {
        int len=l.length;
        List<Boolean> ans=new ArrayList<>();
        outer:for(int i=0;i<len;i++){
            List<Integer> temp=new ArrayList<>();
            int left=l[i],right=r[i];
            for(int j=left;j<=right;j++){
                temp.add(nums[j]);
            }

            Collections.sort(temp);
            for(int j=0;j<temp.size()-2&&temp.size()>=3;j++){
                if(temp.get(j+2)-temp.get(j+1)!=temp.get(j+1)-temp.get(j)){
                    ans.add(false);
                    continue outer;
                }
            }
            ans.add(true);
        }
        
        return ans;
    }
}
```

## 第 83 场双周赛

### [6128. 最好的扑克手牌](https://leetcode.cn/problems/best-poker-hand/)

> 给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。
>
> 下述是从好到坏你可能持有的 手牌类型 ：
>
> "Flush"：同花，五张相同花色的扑克牌。
> "Three of a Kind"：三条，有 3 张大小相同的扑克牌。
> "Pair"：对子，两张大小一样的扑克牌。
> "High Card"：高牌，五张大小互不相同的扑克牌。
> 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。
>
> 注意：返回的字符串 大小写 需与题目描述相同。
>
>  
>
> 示例 1：
>
> 输入：ranks = [13,2,3,1,9], suits = ["a","a","a","a","a"]
> 输出："Flush"
> 解释：5 张扑克牌的花色相同，所以返回 "Flush" 。
> 示例 2：
>
> 输入：ranks = [4,4,2,4,4], suits = ["d","a","a","b","c"]
> 输出："Three of a Kind"
> 解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 "Three of a Kind" 。
> 注意我们也可以得到 "Pair" ，但是 "Three of a Kind" 是更好的手牌类型。
> 有其他的 3 张牌也可以组成 "Three of a Kind" 手牌类型。
> 示例 3：
>
> 输入：ranks = [10,10,2,12,9], suits = ["a","b","c","a","d"]
> 输出："Pair"
> 解释：第一和第二张牌大小相同，所以得到 "Pair" 。
> 我们无法得到 "Flush" 或者 "Three of a Kind" 。
>
>
> 提示：
>
> ranks.length == suits.length == 5
> 1 <= ranks[i] <= 13
> 'a' <= suits[i] <= 'd'
> 任意两张扑克牌不会同时有相同的大小和花色。

```java
class Solution {
    public String bestHand(int[] ranks, char[] suits) {
        int[] r=new int[14];
        for(int i:ranks) r[i]++;
        for(int i=1;i<suits.length;i++){
            if(suits[i]!=suits[i-1]) break;
            if(i==suits.length-1) return "Flush";
        }
        for(int i:r){
            if(i>=3) return "Three of a Kind";
        }
        for(int i:r){
            if(i==2) return "Pair";
        }
        return "High Card";
    }
}
```

### [6129. 全 0 子数组的数目](https://leetcode.cn/problems/number-of-zero-filled-subarrays/)

> 给你一个整数数组 nums ，返回全部为 0 的 子数组 数目。
>
> 子数组 是一个数组中一段连续非空元素组成的序列。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,3,0,0,2,0,0,4]
> 输出：6
> 解释：
> 子数组 [0] 出现了 4 次。
> 子数组 [0,0] 出现了 2 次。
> 不存在长度大于 2 的全 0 子数组，所以我们返回 6 。
> 示例 2：
>
> 输入：nums = [0,0,0,2,0,0]
> 输出：9
> 解释：
> 子数组 [0] 出现了 5 次。
> 子数组 [0,0] 出现了 3 次。
> 子数组 [0,0,0] 出现了 1 次。
> 不存在长度大于 3 的全 0 子数组，所以我们返回 9 。
> 示例 3：
>
> 输入：nums = [2,10,2019]
> 输出：0
> 解释：没有全 0 子数组，所以我们返回 0 。
>
>
> 提示：
>
> 1 <= nums.length <= 10^5
> -109 <= nums[i] <= 10^9

```java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long ans=0;
        int n=nums.length;
        int l=0,r=0;
        for (int i=0;i<n;i++){
            while (i<n&&nums[i]!=0){
                i++;
            }
            l=i;
            while (i<n&&nums[i]==0){
                i++;
            }
            r=i-1;
            ans+=(r-l+1)*1l*(1+r-l+1)/2;
        }

        return ans;
    }
}
```

### [6130. 设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/)

> 设计一个数字容器系统，可以实现以下功能：
>
> 在系统中给定下标处 插入 或者 替换 一个数字。
> 返回 系统中给定数字的最小下标。
> 请你实现一个 NumberContainers 类：
>
> NumberContainers() 初始化数字容器系统。
> void change(int index, int number) 在下标 index 处填入 number 。如果该下标 index 处已经有数字了，那么用 number 替换该数字。
> int find(int number) 返回给定数字 number 在系统中的最小下标。如果系统中没有 number ，那么返回 -1 。
>
>
> 示例：
>
> 输入：
> ["NumberContainers", "find", "change", "change", "change", "change", "find", "change", "find"]
> [[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]
> 输出：
> [null, -1, null, null, null, null, 1, null, 2]
>
> 解释：
> NumberContainers nc = new NumberContainers();
> nc.find(10); // 没有数字 10 ，所以返回 -1 。
> nc.change(2, 10); // 容器中下标为 2 处填入数字 10 。
> nc.change(1, 10); // 容器中下标为 1 处填入数字 10 。
> nc.change(3, 10); // 容器中下标为 3 处填入数字 10 。
> nc.change(5, 10); // 容器中下标为 5 处填入数字 10 。
> nc.find(10); // 数字 10 所在的下标为 1 ，2 ，3 和 5 。因为最小下标为 1 ，所以返回 1 。
> nc.change(1, 20); // 容器中下标为 1 处填入数字 20 。注意，下标 1 处之前为 10 ，现在被替换为 20 。
> nc.find(10); // 数字 10 所在下标为 2 ，3 和 5 。最小下标为 2 ，所以返回 2 。
>
>
> 提示：
>
> 1 <= index, number <= 10^9
> 调用 change 和 find 的 总次数 不超过 10^5 次。

```java
class NumberContainers {
    HashMap<Integer,Integer> h_c;
    HashMap<Integer,Set<Integer>> h_f;


    public NumberContainers() {
        h_c=new HashMap<>();
        h_f=new HashMap<>();
    }

    public void change(int index, int number) {
        if(h_c.containsKey(index)){
            int num=h_c.get(index);
            Set<Integer> temp=h_f.get(num);
            temp.remove(index);
        }
        h_c.put(index,number);
        if(!h_f.containsKey(number)){
            Set<Integer> set=new TreeSet<>(new Comparator<Integer>() {
                @Override
                public int compare(Integer o1, Integer o2) {
                    return o1-o2;
                }
            });
            set.add(index);
            h_f.put(number,set);
        }
        else {
            Set<Integer> temp=h_f.get(number);
            temp.add(index);
            h_f.put(number,temp);
        }
    }

    public int find(int number) {
        if(!h_f.containsKey(number)) return -1;
        else{
            Set<Integer> h=h_f.get(number);
            int ans=-1;
            for(int i:h){
                ans= i;
                break;
            }
            return ans;
        }
    }
}
```

改良版

```java
class NumberContainers {
    HashMap<Integer,Integer> h_c;
    HashMap<Integer,TreeSet<Integer>> h_f;


    public NumberContainers() {
        h_c=new HashMap<>();
        h_f=new HashMap<>();
    }

    public void change(int index, int number) {
        if(h_c.containsKey(index)){
            int num=h_c.get(index);
            h_f.get(num).remove(index);
        }
        h_c.put(index,number);
        h_f.computeIfAbsent(number,key->new TreeSet<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1-o2;
            }
        })).add(index);
    }

    public int find(int number) {
        TreeSet<Integer> treeSet=h_f.get(number);
        if(treeSet==null||treeSet.size()==0) return -1;
        return treeSet.first();
    }
}
```

1. 尽量使用computeIfAbsent方法进行哈希表添加数据

2. TreeSet才有first方法
3. TreeSet是可以自定义排序的

### [6131. 不可能得到的最短骰子序列](https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/)

> 给你一个长度为 n 的整数数组 rolls 和一个整数 k 。你扔一个 k 面的骰子 n 次，骰子的每个面分别是 1 到 k ，其中第 i 次扔得到的数字是 rolls[i] 。
>
> 请你返回 无法 从 rolls 中得到的 最短 骰子子序列的长度。
>
> 扔一个 k 面的骰子 len 次得到的是一个长度为 len 的 骰子子序列 。
>
> 注意 ，子序列只需要保持在原数组中的顺序，不需要连续。
>
>  
>
> 示例 1：
>
> 输入：rolls = [4,2,1,2,3,3,2,4,1], k = 4
> 输出：3
> 解释：所有长度为 1 的骰子子序列 [1] ，[2] ，[3] ，[4] 都可以从原数组中得到。
> 所有长度为 2 的骰子子序列 [1, 1] ，[1, 2] ，... ，[4, 4] 都可以从原数组中得到。
> 子序列 [1, 4, 2] 无法从原数组中得到，所以我们返回 3 。
> 还有别的子序列也无法从原数组中得到。
> 示例 2：
>
> 输入：rolls = [1,1,2,2], k = 2
> 输出：2
> 解释：所有长度为 1 的子序列 [1] ，[2] 都可以从原数组中得到。
> 子序列 [2, 1] 无法从原数组中得到，所以我们返回 2 。
> 还有别的子序列也无法从原数组中得到，但 [2, 1] 是最短的子序列。
> 示例 3：
>
> 输入：rolls = [1,1,3,2,2,2,3,3], k = 4
> 输出：1
> 解释：子序列 [4] 无法从原数组中得到，所以我们返回 1 。
> 还有别的子序列也无法从原数组中得到，但 [4] 是最短的子序列。
>
>
> 提示：
>
> n == rolls.length
> 1 <= n <= 10^5
> 1 <= rolls[i] <= k <= 10^5

```java
class Solution {
    public int shortestSequence(int[] rolls, int k) {
        int n=rolls.length;
        boolean[] vis=new boolean[k+1];
        int cnt=0,ans=0;
        for (int x:rolls){
            if(!vis[x]){
                cnt++;
                vis[x]=true;
            }
            if(cnt==k){
                ans++;
                vis=new boolean[k+1];
                cnt=0;
            }
        }

        return ans+1;
    }
}
```

## 第 303 场周赛

### [6124. 第一个出现两次的字母](https://leetcode.cn/problems/first-letter-to-appear-twice/)

> 给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。
>
> 注意：
>
> 如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。
> s 包含至少一个出现两次的字母。
>
>
> 示例 1：
>
> 输入：s = "abccbaacz"
> 输出："c"
> 解释：
> 字母 'a' 在下标 0 、5 和 6 处出现。
> 字母 'b' 在下标 1 和 4 处出现。
> 字母 'c' 在下标 2 、3 和 7 处出现。
> 字母 'z' 在下标 8 处出现。
> 字母 'c' 是第一个出现两次的字母，因为在所有字母中，'c' 第二次出现的下标是最小的。
> 示例 2：
>
> 输入：s = "abcdd"
> 输出："d"
> 解释：
> 只有字母 'd' 出现两次，所以返回 'd' 。
>
>
> 提示：
>
> 2 <= s.length <= 100
> s 由小写英文字母组成
> s 包含至少一个重复字母

```java
class Solution {
    public char repeatedCharacter(String s) {
        int[] a=new int[26];
        for(int i=0;i<s.length();i++){
            a[s.charAt(i)-'a']++;
            if(a[s.charAt(i)-'a']==2) return s.charAt(i);
        }
        
        return 'a';
    }
}
```



### [6125. 相等行列对](https://leetcode.cn/problems/equal-row-and-column-pairs/)

> 给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。
>
> 如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2022/06/01/ex1.jpg)
>
> 输入：grid = [[3,2,1],[1,7,6],[2,7,7]]
> 输出：1
> 解释：存在一对相等行列对：
> - (第 2 行，第 1 列)：[2,7,7]
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2022/06/01/ex2.jpg)
>
> 输入：grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
> 输出：3
> 解释：存在三对相等行列对：
> - (第 0 行，第 0 列)：[3,1,2,2]
> - (第 2 行, 第 2 列)：[2,4,2,2]
> - (第 3 行, 第 2 列)：[2,4,2,2]
>
>
> 提示：
>
> n == grid.length == grid[i].length
> 1 <= n <= 200
> 1 <= grid[i][j] <= 10^5

```java
class Solution {
    public int equalPairs(int[][] grid) {
        int ans=0,m=grid.length,n=grid[0].length;
        int[][] temp=new int[n][m];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                temp[i][j]=grid[j][i];
            }
        }
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(Arrays.equals(grid[i],temp[j]))ans++;
            }
        }

        return ans;
    }
}
```

1. Arrays.equals能够比较两个数组里面的内容是否相同

### [6126. 设计食物评分系统](https://leetcode.cn/problems/design-a-food-rating-system/)

> 设计一个支持下述操作的食物评分系统：
>
> 修改 系统中列出的某种食物的评分。
> 返回系统中某一类烹饪方式下评分最高的食物。
> 实现 FoodRatings 类：
>
> FoodRatings(String[] foods, String[] cuisines, int[] ratings) 初始化系统。食物由 foods、cuisines 和 ratings 描述，长度均为 n 。
> foods[i] 是第 i 种食物的名字。
> cuisines[i] 是第 i 种食物的烹饪方式。
> ratings[i] 是第 i 种食物的最初评分。
> void changeRating(String food, int newRating) 修改名字为 food 的食物的评分。
> String highestRated(String cuisine) 返回指定烹饪方式 cuisine 下评分最高的食物的名字。如果存在并列，返回 字典序较小 的名字。
> 注意，字符串 x 的字典序比字符串 y 更小的前提是：x 在字典中出现的位置在 y 之前，也就是说，要么 x 是 y 的前缀，或者在满足 x[i] != y[i] 的第一个位置 i 处，x[i] 在字母表中出现的位置在 y[i] 之前。
>
>  
>
> 示例：
>
> 输入
> ["FoodRatings", "highestRated", "highestRated", "changeRating", "highestRated", "changeRating", "highestRated"]
> [[["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]], ["korean"], ["japanese"], ["sushi", 16], ["japanese"], ["ramen", 16], ["japanese"]]
> 输出
> [null, "kimchi", "ramen", null, "sushi", null, "ramen"]
>
> 解释
> FoodRatings foodRatings = new FoodRatings(["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]);
> foodRatings.highestRated("korean"); // 返回 "kimchi"
>                                     // "kimchi" 是分数最高的韩式料理，评分为 9 。
> foodRatings.highestRated("japanese"); // 返回 "ramen"
>                                       // "ramen" 是分数最高的日式料理，评分为 14 。
> foodRatings.changeRating("sushi", 16); // "sushi" 现在评分变更为 16 。
> foodRatings.highestRated("japanese"); // 返回 "sushi"
>                                       // "sushi" 是分数最高的日式料理，评分为 16 。
> foodRatings.changeRating("ramen", 16); // "ramen" 现在评分变更为 16 。
> foodRatings.highestRated("japanese"); // 返回 "ramen"
>                                       // "sushi" 和 "ramen" 的评分都是 16 。
>                                       // 但是，"ramen" 的字典序比 "sushi" 更小。
>
>
> 提示：
>
> 1 <= n <= 2 * 104
> n == foods.length == cuisines.length == ratings.length
> 1 <= foods[i].length, cuisines[i].length <= 10
> foods[i]、cuisines[i] 由小写英文字母组成
> 1 <= ratings[i] <= 108
> foods 中的所有字符串 互不相同
> 在对 changeRating 的所有调用中，food 是系统中食物的名字。
> 在对 highestRated 的所有调用中，cuisine 是系统中 至少一种 食物的烹饪方式。

```java
class FoodRatings {
    HashMap<String,node1>f_r;
    HashMap<String, TreeSet<node1>> f_c;

    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        f_r=new HashMap<>();
        f_c=new HashMap<>();
        int num=foods.length;
        for(int i=0;i<num;i++){
            f_r.put(foods[i],new node1(cuisines[i],ratings[i]));
            f_c.computeIfAbsent(cuisines[i],k->new TreeSet<>(new Comparator<node1>() {
                @Override
                public int compare(node1 o1, node1 o2) {
                    if(o1.rate!=o2.rate) return o2.rate-o1.rate;
                    else return o1.str.compareTo(o2.str);
                }
            })).add(new node1(foods[i],ratings[i]));
        }
    }

    public void changeRating(String food, int newRating) {
        node1 nodef_r=f_r.get(food);
        String cui=nodef_r.str;
        
        node1 node_pre=new node1(food,nodef_r.rate);
        f_c.get(cui).remove(node_pre);

        f_r.put(food,new node1(cui,newRating));
        f_c.get(cui).add(new node1(food,newRating));
    }

    public String highestRated(String cuisine) {
        return f_c.get(cuisine).first().str;
    }

    public class node1{
        public String str;
        public int rate;

        public node1(String str,int rate){
            this.str=str;
            this.rate=rate;
        }
    }
}
```

自己写的

```java
class FoodRatings {
    HashMap<String,node1>f_r;
    HashMap<String,TreeSet<node>> f_c;

    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        f_r=new HashMap<>();
        f_c=new HashMap<>();
        int num=foods.length;
        for(int i=0;i<num;i++){
            f_r.put(foods[i],new node1(cuisines[i],ratings[i]));
            f_c.computeIfAbsent(cuisines[i],key->new TreeSet<>(new Comparator<node>() {
                @Override
                public int compare(node o1, node o2) {
                    if(o1.rate==o2.rate) return o1.food.compareTo(o2.food);
                    return o2.rate-o1.rate;
                }
            })).add(new node(ratings[i],foods[i]));
        }
    }

    public void changeRating(String food, int newRating) {
        String cui=f_r.get(food).cui;
        f_c.get(cui).remove(new node(f_r.get(food).rate,food));
        f_r.put(food,new node1(cui,newRating));
        f_c.computeIfAbsent(cui,key->new TreeSet<>()).add(new node(newRating,food));
    }

    public String highestRated(String cuisine) {
        TreeSet<node> temp=f_c.get(cuisine);
        return temp.first().food;
    }

    public class node{
        int rate;
        String food;

        public node(int rate,String food){
            this.rate=rate;
            this.food=food;
        }
    }

    public class node1{
        public String cui;
        public int rate;

        public node1(String cui,int rate){
            this.cui=cui;
            this.rate=rate;
        }
    }
}
```

## 第 36 场双周赛

### [1603. 设计停车系统](https://leetcode.cn/problems/design-parking-system/)

> 请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。
>
> 请你实现 ParkingSystem 类：
>
> ParkingSystem(int big, int medium, int small) 初始化 ParkingSystem 类，三个参数分别对应每种停车位的数目。
> bool addCar(int carType) 检查是否有 carType 对应的停车位。 carType 有三种类型：大，中，小，分别用数字 1， 2 和 3 表示。一辆车只能停在  carType 对应尺寸的停车位中。如果没有空车位，请返回 false ，否则将该车停入车位并返回 true 。
>
>
> 示例 1：
>
> 输入：
> ["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]
> [[1, 1, 0], [1], [2], [3], [1]]
> 输出：
> [null, true, true, false, false]
>
> 解释：
> ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
> parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位
> parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位
> parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位
> parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了
>
>
> 提示：
>
> 0 <= big, medium, small <= 1000
> carType 取值为 1， 2 或 3
> 最多会调用 addCar 函数 1000 次

```java
class ParkingSystem {
    int big;
    int mid;
    int small;

    public ParkingSystem(int big, int medium, int small) {
        this.big=big;
        this.mid=medium;
        this.small=small;
    }

    public boolean addCar(int carType) {
        if(carType==1){
            if(big>0) {
                big--;
                return true;
            }else return false;
        } else if (carType==2) {
            if(mid>0){
                mid--;
                return true;
            }else return false;
        } else if (carType==3) {
            if(small>0){
                small--;
                return true;
            }else return false;
        }
        return false;
    }
}
```

### [1604. 警告一小时内使用相同员工卡大于等于三次的人](https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/)

> 力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。
>
> 给你字符串数组 keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。
>
> 使用时间的格式是 24小时制 ，形如 "HH:MM" ，比方说 "23:51" 和 "09:49" 。
>
> 请你返回去重后的收到系统警告的员工名字，将它们按 字典序升序 排序后返回。
>
> 请注意 "10:00" - "11:00" 视为一个小时时间范围内，而 "23:51" - "00:10" 不被视为一小时内，因为系统记录的是某一天内的使用情况。
>
>  
>
> 示例 1：
>
> 输入：keyName = ["daniel","daniel","daniel","luis","luis","luis","luis"], keyTime = ["10:00","10:40","11:00","09:00","11:00","13:00","15:00"]
> 输出：["daniel"]
> 解释："daniel" 在一小时内使用了 3 次员工卡（"10:00"，"10:40"，"11:00"）。
> 示例 2：
>
> 输入：keyName = ["alice","alice","alice","bob","bob","bob","bob"], keyTime = ["12:01","12:00","18:00","21:00","21:20","21:30","23:00"]
> 输出：["bob"]
> 解释："bob" 在一小时内使用了 3 次员工卡（"21:00"，"21:20"，"21:30"）。
> 示例 3：
>
> 输入：keyName = ["john","john","john"], keyTime = ["23:58","23:59","00:01"]
> 输出：[]
> 示例 4：
>
> 输入：keyName = ["leslie","leslie","leslie","clare","clare","clare","clare"], keyTime = ["13:00","13:20","14:00","18:00","18:51","19:30","19:49"]
> 输出：["clare","leslie"]
>
>
> 提示：
>
> 1 <= keyName.length, keyTime.length <= 10^5
> keyName.length == keyTime.length
> keyTime 格式为 "HH:MM" 。
> 保证 [keyName[i], keyTime[i]] 形成的二元对 互不相同 。
> 1 <= keyName[i].length <= 10
> keyName[i] 只包含小写英文字母。

```java
class Solution {
    public List<String> alertNames(String[] keyName, String[] keyTime) {
        HashMap<String,LinkedList<String>> k_t=new HashMap<>();
        int n=keyName.length;
        for(int i=0;i<n;i++){
            if(k_t.containsKey(keyName[i])){
                LinkedList<String> temp=k_t.get(keyName[i]);
                temp.add(keyTime[i]);
                Collections.sort(temp);
                k_t.put(keyName[i],temp);
            }else{
                LinkedList<String> temp=new LinkedList<>();
                temp.add(keyTime[i]);
                k_t.put(keyName[i],temp);
            }
        }

        List<String> ans=new ArrayList<>();

        Set<String> s=k_t.keySet();
        for(String i:s){
            List<String> temp=k_t.get(i);
            int len=temp.size();
            if(len<3) continue;
            int temp_num=3;
            for (int j=1;j<len-1;j++){

                int pre_h=Integer.parseInt(temp.get(j-1).substring(0,2));
                int pre_m=Integer.parseInt(temp.get(j-1).substring(3,5));
                int h=Integer.parseInt(temp.get(j).substring(0,2));
                int m=Integer.parseInt(temp.get(j).substring(3,5));
                int next_h=Integer.parseInt(temp.get(j+1).substring(0,2));
                int next_m=Integer.parseInt(temp.get(j+1).substring(3,5));

                int num=(h-pre_h+next_h-h)*60+m-pre_m+next_m-m;

                if(num<=60&&num>0) {
                    ans.add(i);
                    break;
                }
            }
        }

        Collections.sort(ans,((o1, o2) -> o1.compareTo(o2)));
        return ans;
    }
}
```

### [1605. 给定行和列的和求可行矩阵](https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/)

> 给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。
>
> 请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，且该矩阵满足 rowSum 和 colSum 的要求。
>
> 请你返回任意一个满足题目要求的二维矩阵，题目保证存在 至少一个 可行矩阵。
>
>  
>
> 示例 1：
>
> 输入：rowSum = [3,8], colSum = [4,7]
> 输出：[[3,0],
>       [1,7]]
> 解释：
> 第 0 行：3 + 0 = 3 == rowSum[0]
> 第 1 行：1 + 7 = 8 == rowSum[1]
> 第 0 列：3 + 1 = 4 == colSum[0]
> 第 1 列：0 + 7 = 7 == colSum[1]
> 行和列的和都满足题目要求，且所有矩阵元素都是非负的。
> 另一个可行的矩阵为：[[1,2],
>                   [3,5]]
> 示例 2：
>
> 输入：rowSum = [5,7,10], colSum = [8,6,8]
> 输出：[[0,5,0],
>       [6,1,0],
>       [2,0,8]]
> 示例 3：
>
> 输入：rowSum = [14,9], colSum = [6,9,8]
> 输出：[[0,9,5],
>       [6,0,3]]
> 示例 4：
>
> 输入：rowSum = [1,0], colSum = [1]
> 输出：[[1],
>       [0]]
> 示例 5：
>
> 输入：rowSum = [0], colSum = [0]
> 输出：[[0]]
>
>
> 提示：
>
> 1 <= rowSum.length, colSum.length <= 500
> 0 <= rowSum[i], colSum[i] <= 10^8
> sum(rows) == sum(columns)

```java
class Solution {
    public int[][] restoreMatrix(int[] rowSum, int[] colSum) {
        int m=rowSum.length;
        int n=colSum.length;
        int[][] ans=new int[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                ans[i][j]=Math.min(rowSum[i],colSum[j]);
                rowSum[i]-=ans[i][j];
                colSum[j]-=ans[i][j];
            }
        }
        
        return ans;
    }
}
```

### [1606. 找到处理最多请求的服务器](https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/)

> 你有 k 个服务器，编号为 0 到 k-1 ，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 不能同时处理超过一个请求 。请求分配到服务器的规则如下：
>
> 第 i （序号从 0 开始）个请求到达。
> 如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。
> 如果第 (i % k) 个服务器空闲，那么对应服务器会处理该请求。
> 否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 i 个服务器在忙，那么会查看第 (i+1) 个服务器，第 (i+2) 个服务器等等。
> 给你一个 严格递增 的正整数数组 arrival ，表示第 i 个任务的到达时间，和另一个数组 load ，其中 load[i] 表示第 i 个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 最繁忙的服务器 。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。
>
> 请你返回包含所有 最繁忙服务器 序号的列表，你可以以任意顺序返回这个列表。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/03/load-1.png)
>
> 输入：k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] 
> 输出：[1] 
> 解释：
> 所有服务器一开始都是空闲的。
> 前 3 个请求分别由前 3 台服务器依次处理。
> 请求 3 进来的时候，服务器 0 被占据，所以它被安排到下一台空闲的服务器，也就是服务器 1 。
> 请求 4 进来的时候，由于所有服务器都被占据，该请求被舍弃。
> 服务器 0 和 2 分别都处理了一个请求，服务器 1 处理了两个请求。所以服务器 1 是最忙的服务器。
> 示例 2：
>
> 输入：k = 3, arrival = [1,2,3,4], load = [1,2,1,2]
> 输出：[0]
> 解释：
> 前 3 个请求分别被前 3 个服务器处理。
> 请求 3 进来，由于服务器 0 空闲，它被服务器 0 处理。
> 服务器 0 处理了两个请求，服务器 1 和 2 分别处理了一个请求。所以服务器 0 是最忙的服务器。
> 示例 3：
>
> 输入：k = 3, arrival = [1,2,3], load = [10,12,11]
> 输出：[0,1,2]
> 解释：每个服务器分别处理了一个请求，所以它们都是最忙的服务器。
> 示例 4：
>
> 输入：k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]
> 输出：[1]
> 示例 5：
>
> 输入：k = 1, arrival = [1], load = [1]
> 输出：[0]
>
>
> 提示：
>
> 1 <= k <= 105
> 1 <= arrival.length, load.length <= 10^5
> arrival.length == load.length
> 1 <= arrival[i], load[i] <= 10^9
> arrival 保证 严格递增 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {
        int[] load_num=new int[k];
        Arrays.fill(load_num,0);
        PriorityQueue<int[]> busy=new PriorityQueue<>((o1,o2)->o1[1]-o2[1]);
        TreeSet<Integer> free=new TreeSet<>();
        for(int i=0;i<k;i++) free.add(i);
        int len=load.length;
        int max=0;
        for(int i=0;i<len;i++){
            int start_time=arrival[i],end_time=start_time+load[i];
            while (!busy.isEmpty()&&busy.peek()[1]<=start_time) free.add(busy.poll()[0]);
            Integer temp=free.ceiling(i%k);
            if(temp==null) temp=free.ceiling(0);
            if(temp==null) continue;
            busy.add(new int[]{temp,end_time});
            free.remove(temp);
            max=Math.max(max,++load_num[temp]);
        }
        List<Integer> ans=new ArrayList<>();
        for(int i=0;i<k;i++){
            if(load_num[i]==max) ans.add(i);
        }

        return ans;
    }
}
```

## 第 242 场周赛

### [1869. 哪种连续子字符串更长](https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/)

> 给你一个二进制字符串 s 。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 true ；否则，返回 false 。
>
> 例如，s = "110100010" 中，由 1 组成的最长连续子字符串的长度是 2 ，由 0 组成的最长连续子字符串的长度是 3 。
> 注意，如果字符串中不存在 0 ，此时认为由 0 组成的最长连续子字符串的长度是 0 。字符串中不存在 1 的情况也适用此规则。
>
>  
>
> 示例 1：
>
> 输入：s = "1101"
> 输出：true
> 解释：
> 由 1 组成的最长连续子字符串的长度是 2："1101"
> 由 0 组成的最长连续子字符串的长度是 1："1101"
> 由 1 组成的子字符串更长，故返回 true 。
> 示例 2：
>
> 输入：s = "111000"
> 输出：false
> 解释：
> 由 1 组成的最长连续子字符串的长度是 3："111000"
> 由 0 组成的最长连续子字符串的长度是 3："111000"
> 由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。
> 示例 3：
>
> 输入：s = "110100010"
> 输出：false
> 解释：
> 由 1 组成的最长连续子字符串的长度是 2："110100010"
> 由 0 组成的最长连续子字符串的长度是 3："110100010"
> 由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。
>
>
> 提示：
>
> 1 <= s.length <= 100
> s[i] 不是 '0' 就是 '1'
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean checkZeroOnes(String s) {
        int ans_1=0,ans_0=0,n=s.length();

        int l=0,r=0;
        for(int i=0;i<n;i++){
            while (i<n&&s.charAt(i)!='1'){
                i++;
            }
            l=i;
            while (i<n&&s.charAt(i)=='1'){
                i++;
            }
            r=i;
            ans_1=Math.max(r-l,ans_1);
        }

        for(int i=0;i<n;i++){
            while (i<n&&s.charAt(i)!='0'){
                i++;
            }
            l=i;
            while (i<n&&s.charAt(i)=='0'){
                i++;
            }
            r=i;
            ans_0=Math.max(r-l,ans_0);
        }

        return ans_1>ans_0;
    }
}
```

### [1870. 准时到达的列车最小时速](https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/)

> 给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。
>
> 每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。
>
> 例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。
> 返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。
>
> 生成的测试用例保证答案不超过 107 ，且 hour 的 小数点后最多存在两位数字 。
>
>  
>
> 示例 1：
>
> 输入：dist = [1,3,2], hour = 6
> 输出：1
> 解释：速度为 1 时：
> - 第 1 趟列车运行需要 1/1 = 1 小时。
> - 由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3/1 = 3 小时。
> - 由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2/1 = 2 小时。
> - 你将会恰好在第 6 小时到达。
> 示例 2：
>
> 输入：dist = [1,3,2], hour = 2.7
> 输出：3
> 解释：速度为 3 时：
> - 第 1 趟列车运行需要 1/3 = 0.33333 小时。
> - 由于不是在整数时间到达，故需要等待至第 1 小时才能搭乘列车。第 2 趟列车运行需要 3/3 = 1 小时。
> - 由于是在整数时间到达，可以立即换乘在第 2 小时发车的列车。第 3 趟列车运行需要 2/3 = 0.66667 小时。
> - 你将会在第 2.66667 小时到达。
> 示例 3：
>
> 输入：dist = [1,3,2], hour = 1.9
> 输出：-1
> 解释：不可能准时到达，因为第 3 趟列车最早是在第 2 小时发车。
>
>
> 提示：
>
> n == dist.length
> 1 <= n <= 10^5
> 1 <= dist[i] <= 10^5
> 1 <= hour <= 10^9
> hours 中，小数点后最多存在两位数字
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimum-speed-to-arrive-on-time
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int minSpeedOnTime(int[] dist, double hour) {
        int i = 1;//最小速度
        int j = Arrays.stream(dist).max().getAsInt()*100;//最大速度
        while(i <= j){
            int m = i + (j-i)/2;
            if(costtime(m, dist) > hour){i = m+1;}
            else{j = m-1;}
        }
        return i > Arrays.stream(dist).max().getAsInt()*100 ? -1:i;
    }

    public double costtime(double speed, int[] dist){
        int len = dist.length;
        double result = 0;
        for(int i = 0; i < len-1; i++){
            result += Math.ceil(dist[i]/speed);
        }
        return result + dist[len-1]/speed;
    }
}
```

## 第 273 场周赛

### [2119. 反转两次的数字](https://leetcode.cn/problems/a-number-after-a-double-reversal/)

> 反转 一个整数意味着倒置它的所有位。
>
> 例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。
> 给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：num = 526
> 输出：true
> 解释：反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。
> 示例 2：
>
> 输入：num = 1800
> 输出：false
> 解释：反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。 
> 示例 3：
>
> 输入：num = 0
> 输出：true
> 解释：反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。
>
>
> 提示：
>
> 0 <= num <= 10^6
>

```java
class Solution {
    public boolean isSameAfterReversals(int num) {
        StringBuilder str=new StringBuilder(String.valueOf(num));
        Integer num1=Integer.parseInt(str.reverse().toString());
        str=new StringBuilder(String.valueOf(num1));
        Integer num2=Integer.parseInt(str.reverse().toString());
        return num==num2;
    }
}	
```

### [2120. 执行所有后缀指令](https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/)

> 现有一个 n x n 大小的网格，左上角单元格坐标 (0, 0) ，右下角单元格坐标 (n - 1, n - 1) 。给你整数 n 和一个整数数组 startPos ，其中 startPos = [startrow, startcol] 表示机器人最开始在坐标为 (startrow, startcol) 的单元格上。
>
> 另给你一个长度为 m 、下标从 0 开始的字符串 s ，其中 s[i] 是对机器人的第 i 条指令：'L'（向左移动），'R'（向右移动），'U'（向上移动）和 'D'（向下移动）。
>
> 机器人可以从 s 中的任一第 i 条指令开始执行。它将会逐条执行指令直到 s 的末尾，但在满足下述条件之一时，机器人将会停止：
>
> 下一条指令将会导致机器人移动到网格外。
> 没有指令可以执行。
> 返回一个长度为 m 的数组 answer ，其中 answer[i] 是机器人从第 i 条指令 开始 ，可以执行的 指令数目 。
>
>  
>
> 示例 1：
>
> 
>
> 输入：n = 3, startPos = [0,1], s = "RRDDLU"
> 输出：[1,5,4,3,1,0]
> 解释：机器人从 startPos 出发，并从第 i 条指令开始执行：
> - 0: "RRDDLU" 在移动到网格外之前，只能执行一条 "R" 指令。
> - 1:  "RDDLU" 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。
> - 2:   "DDLU" 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。
> - 3:    "DLU" 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。
> - 4:     "LU" 在移动到网格外之前，只能执行一条 "L" 指令。
> - 5:      "U" 如果向上移动，将会移动到网格外。
> 示例 2：
>
> 
>
> 输入：n = 2, startPos = [1,1], s = "LURD"
> 输出：[4,1,0,0]
> 解释：
> - 0: "LURD"
> - 1:  "URD"
> - 2:   "RD"
> - 3:    "D"
> 示例 3：
>
> 
>
> 输入：n = 1, startPos = [0,0], s = "LRUD"
> 输出：[0,0,0,0]
> 解释：无论机器人从哪条指令开始执行，都会移动到网格外。
>
>
> 提示：
>
> m == s.length
> 1 <= n, m <= 500
> startPos.length == 2
> 0 <= startrow, startcol < n
> s 由 'L'、'R'、'U' 和 'D' 组成

```java
class Solution {
    public int[] executeInstructions(int n, int[] startPos, String s) {
        int m=s.length();
        int[] ans=new int[m];

        HashMap<Character,int[]> h=new HashMap<>();
        h.put('L',new int[]{0,-1});
        h.put('R',new int[]{0,1});
        h.put('U',new int[]{-1,0});
        h.put('D',new int[]{1,0});
        int start_x=startPos[0],start_y=startPos[1];
        
        for(int i=0;i<m;i++){
            int num=0;
            int temp_x=start_x,temp_y=start_y;
            for(int j=i;j<m;j++){
                int[] temp=h.get(s.charAt(j));
                int x=temp_x+temp[0];
                int y=temp_y+temp[1];
                
                if(x>=0&&x<n&&y>=0&&y<n){
                    temp_x=x;
                    temp_y=y;
                    num++;
                }else break;
                
            }
            
            ans[i]=num;
        }

        return ans;
    }
}
```

### [2121. 相同元素的间隔之和](https://leetcode.cn/problems/intervals-between-identical-elements/)

> 给你一个下标从 0 开始、由 n 个整数组成的数组 arr 。
>
> arr 中两个元素的 间隔 定义为它们下标之间的 绝对差 。更正式地，arr[i] 和 arr[j] 之间的间隔是 |i - j| 。
>
> 返回一个长度为 n 的数组 intervals ，其中 intervals[i] 是 arr[i] 和 arr 中每个相同元素（与 arr[i] 的值相同）的 间隔之和 。
>
> 注意：|x| 是 x 的绝对值。
>
>  
>
> 示例 1：
>
> 输入：arr = [2,1,3,1,2,3,3]
> 输出：[4,2,7,2,4,4,5]
> 解释：
> - 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4
> - 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2
> - 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7
> - 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2
> - 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4
> - 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4
> - 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5
> 示例 2：
>
> 输入：arr = [10,5,10,10]
> 输出：[5,0,3,4]
> 解释：
> - 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5
> - 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0
> - 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3
> - 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4
>
>
> 提示：
>
> n == arr.length
> 1 <= n <= 10^5
> 1 <= arr[i] <= 10^5

```java
class Solution {
    public long[] getDistances(int[] arr) {
        int n=arr.length;
        long[] ans=new long[n];
        HashMap<Integer,List<Integer>> hashMap=new HashMap<>();

        for(int i=0;i<n;i++){
            int num=arr[i];
            if(hashMap.containsKey(num)){
                List<Integer> temp=hashMap.get(num);
                temp.add(i);
                hashMap.put(num,temp);
            }else{
                List<Integer> temp=new ArrayList<>();
                temp.add(i);
                hashMap.put(num,temp);
            }
        }

        for(Map.Entry<Integer,List<Integer>> entry:hashMap.entrySet()){
            List<Integer> temp=entry.getValue();
            int len=temp.size();
            long[] left=new long[len],right=new long[len];
            for(int i=1,j=len-2;i<len;i++,j--){
                left[i]=left[i-1]+i*(temp.get(i)-temp.get(i-1));
                right[j]=right[j+1]+(len-j-1)*(temp.get(j+1)-temp.get(j));
            }
            for(int i=0;i<len;i++){
                ans[temp.get(i)]=left[i]+right[i];
            }
        }

        return ans;
    }
}
```

1. 前缀和+后缀和能够求任一位置的区间和

```java
long[] left=new long[len],right=new long[len];
for(int i=1,j=len-2;i<len;i++,j--){
    left[i]=left[i-1]+i*(temp.get(i)-temp.get(i-1));
    right[j]=right[j+1]+(len-j-1)*(temp.get(j+1)-temp.get(j));
}
```

### [149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/)

> 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)
>
> 输入：points = [[1,1],[2,2],[3,3]]
> 输出：3
> 示例 2：
>
> <img src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" alt="img" style="zoom:50%;" />
>
> 输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
> 输出：4
>
>
> 提示：
>
> 1 <= points.length <= 300
> points[i].length == 2
> -104 <= xi, yi <= 104
> points 中的所有点 互不相同

```java
class Solution {
    public int maxPoints(int[][] points) {
        int n=points.length;
        if(n<=2) return n;
        int ans=2;
        int temp_ans=2;
        for(int i=0;i<n;i++){
            int[] temp1=points[i];
            for(int j=i+1;j<n;j++){
                int[] temp2=points[j];

                temp_ans=2;
                for(int k=j+1;k<n;k++){
                    int[] temp3=points[k];
                    int x1=temp1[0],y1=temp1[1];
                    int x2=temp2[0],y2=temp2[1];
                    int k1_x=(x2-x1),k1_y=y2-y1;
                    int x3=temp3[0],y3=temp3[1];
                    int k2_x=x3-x2,k2_y=y3-y2;
                    if(k1_x*k2_y==k1_y*k2_x){
                        temp_ans++;
                        ans=Math.max(ans,temp_ans);
                    }
                }
            }
        }
        
        return ans;
    }
}
```

## 第 225 场周赛

### \1736. 替换隐藏数字得到的最晚时间

> 给你一个字符串 `time` ，格式为 `hh:mm`（小时：分钟），其中某几位数字被隐藏（用 `?` 表示）。
>
> 有效的时间为 `00:00` 到 `23:59` 之间的所有时间，包括 `00:00` 和 `23:59` 。
>
> 替换 `time` 中隐藏的数字，返回你可以得到的最晚有效时间。
>
>  
>
> **示例 1：**
>
> ```
> 输入：time = "2?:?0"
> 输出："23:50"
> 解释：以数字 '2' 开头的最晚一小时是 23 ，以 '0' 结尾的最晚一分钟是 50 。
> ```
>
> **示例 2：**
>
> ```
> 输入：time = "0?:3?"
> 输出："09:39"
> ```
>
> **示例 3：**
>
> ```
> 输入：time = "1?:22"
> 输出："19:22"
> ```
>
>  
>
> **提示：**
>
> - `time` 的格式为 `hh:mm`
> - 题目数据保证你可以由输入的字符串生成有效的时间

```java
class Solution {
    public String maximumTime(String time) {
        int temp=-1;
        int[] index=new int[5];
        for (int i=0;i<5;i++){
            if(time.charAt(i)=='?')
            index[++temp]=i;
        }

        StringBuilder ans=new StringBuilder();
        if(time.charAt(0)!='?'){
            ans.append(time.charAt(0));
        }else{
            if(time.charAt(1)<='3'||time.charAt(1)=='?'){
                ans.append('2');
            }else{
                ans.append('1');
            }
        }
        if(time.charAt(1)=='?'){
            if(ans.charAt(0)=='2') ans.append('3');
            else ans.append('9');
        }else ans.append(time.charAt(1));
        
        ans.append(':');
        
        if(time.charAt(3)=='?') ans.append('5');
        else ans.append(time.charAt(3));
        
        if(time.charAt(4)=='?') ans.append('9');
        else ans.append(time.charAt(4));

        return ans.toString();
    }
}
```

### \1737. 满足三条件之一需改变的最少字符数

> 给你两个字符串 `a` 和 `b` ，二者均由小写字母组成。一步操作中，你可以将 `a` 或 `b` 中的 **任一字符** 改变为 **任一小写字母** 。
>
> 操作的最终目标是满足下列三个条件 **之一** ：
>
> - `a` 中的 **每个字母** 在字母表中 **严格小于** `b` 中的 **每个字母** 。
> - `b` 中的 **每个字母** 在字母表中 **严格小于** `a` 中的 **每个字母** 。
> - `a` 和 `b` **都** 由 **同一个** 字母组成。
>
> 返回达成目标所需的 **最少** 操作数*。*
>
>  
>
> **示例 1：**
>
> ```
> 输入：a = "aba", b = "caa"
> 输出：2
> 解释：满足每个条件的最佳方案分别是：
> 1) 将 b 变为 "ccc"，2 次操作，满足 a 中的每个字母都小于 b 中的每个字母；
> 2) 将 a 变为 "bbb" 并将 b 变为 "aaa"，3 次操作，满足 b 中的每个字母都小于 a 中的每个字母；
> 3) 将 a 变为 "aaa" 并将 b 变为 "aaa"，2 次操作，满足 a 和 b 由同一个字母组成。
> 最佳的方案只需要 2 次操作（满足条件 1 或者条件 3）。
> ```
>
> **示例 2：**
>
> ```
> 输入：a = "dabadd", b = "cda"
> 输出：3
> 解释：满足条件 1 的最佳方案是将 b 变为 "eee" 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= a.length, b.length <= 105`
> - `a` 和 `b` 只由小写字母组成

```java
class Solution {
    public int minCharacters(String a, String b) {
        int n=a.length(),m=b.length(),ans=Integer.MAX_VALUE;
        int[] temp1=new int[26],temp2=new int[26];
        for(char c:a.toCharArray()) temp1[c-'a']++;
        for(char c:b.toCharArray()) temp2[c-'a']++;
        for(int i=0;i<26;i++){
            int c_a=n-temp1[i],c_b=m-temp2[i];
            ans=Math.min(c_a+c_b,ans);

            if(i==0) continue;
            int r1=0,r2=0;
            for(int j=i;j<26;j++) r1+=temp1[j];
            for(int j=0;j<i;j++) r1+=temp2[j];

            for(int j=i;j<26;j++) r2+=temp2[j];
            for(int j=0;j<i;j++) r2+=temp1[j];
            ans=Math.min(ans,Math.min(r1,r2));
        }

        return ans;
    }
}
```

1. 以某一个字母为大小的参照

### \1738. 找出第 K 大的异或坐标值

> 给你一个二维矩阵 `matrix` 和一个整数 `k` ，矩阵大小为 `m x n` 由非负整数组成。
>
> 矩阵中坐标 `(a, b)` 的 **值** 可由对所有满足 `0 <= i <= a < m` 且 `0 <= j <= b < n` 的元素 `matrix[i][j]`（**下标从 0 开始计数**）执行异或运算得到。
>
> 请你找出 `matrix` 的所有坐标中第 `k` 大的值（**`k` 的值从 1 开始计数**）。
>
>  
>
> **示例 1：**
>
> ```
> 输入：matrix = [[5,2],[1,6]], k = 1
> 输出：7
> 解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。
> ```
>
> **示例 2：**
>
> ```
> 输入：matrix = [[5,2],[1,6]], k = 2
> 输出：5
> 解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。
> ```
>
> **示例 3：**
>
> ```
> 输入：matrix = [[5,2],[1,6]], k = 3
> 输出：4
> 解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。
> ```
>
> **示例 4：**
>
> ```
> 输入：matrix = [[5,2],[1,6]], k = 4
> 输出：0
> 解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。
> ```
>
>  
>
> **提示：**
>
> - `m == matrix.length`
> - `n == matrix[i].length`
> - `1 <= m, n <= 1000`
> - `0 <= matrix[i][j] <= 10^6`
> - `1 <= k <= m * n`

```java
class Solution {
    public int kthLargestValue(int[][] matrix, int k) {
        int m=matrix.length,n=matrix[0].length;
        int[][] sum=new int[m+1][n+1];
        PriorityQueue<Integer> q=new PriorityQueue<>(k,((o1, o2) -> o1-o2));
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                sum[i][j]=sum[i-1][j]^sum[i][j-1]^sum[i-1][j-1]^matrix[i-1][j-1];
                if(q.size()<k){
                    q.add(sum[i][j]);
                }else {
                    if(sum[i][j]>q.peek()){
                        q.poll();
                        q.add(sum[i][j]);
                    }
                }
            }
        }
        
        System.out.print(5^2);

        return q.peek();
    }
}
```

1. 前缀和+优先队列

## 第 262 场周赛

### [2032. 至少在两个数组中出现的值](https://leetcode.cn/problems/two-out-of-three/)

> 给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 元素各不相同的 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。
>
>
> 示例 1：
>
> 输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]
> 输出：[3,2]
> 解释：至少在两个数组中出现的所有值为：
> - 3 ，在全部三个数组中都出现过。
> - 2 ，在数组 nums1 和 nums2 中出现过。
> 示例 2：
>
> 输入：nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]
> 输出：[2,3,1]
> 解释：至少在两个数组中出现的所有值为：
> - 2 ，在数组 nums2 和 nums3 中出现过。
> - 3 ，在数组 nums1 和 nums2 中出现过。
> - 1 ，在数组 nums1 和 nums3 中出现过。
> 示例 3：
>
> 输入：nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]
> 输出：[]
> 解释：不存在至少在两个数组中出现的值。
>
>
> 提示：
>
> 1 <= nums1.length, nums2.length, nums3.length <= 100
> 1 <= nums1[i], nums2[j], nums3[k] <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/two-out-of-three
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {
        List<Integer> ans=new ArrayList<>();
        Set<Integer> set1=new HashSet<>();
        Set<Integer> set2=new HashSet<>();
        Set<Integer> set3=new HashSet<>();
        int[] arr=new int[101];
        for(int i:nums1) set1.add(i);
        for(int i:nums2) set2.add(i);
        for(int i:nums3) set3.add(i);
        
        for(int i:set1) arr[i]++;
        for(int i:set2) arr[i]++;
        for(int i:set3) arr[i]++;

        for(int i=0;i<101;i++){
            if(arr[i]>=2) ans.add(i);
        }
        return ans;
    }
}
```

### [2033. 获取单值网格的最小操作数](https://leetcode.cn/problems/minimum-operations-to-make-a-uni-value-grid/)

> 给你一个大小为 m x n 的二维整数网格 grid 和一个整数 x 。每一次操作，你可以对 grid 中的任一元素 加 x 或 减 x 。
>
> 单值网格 是全部元素都相等的网格。
>
> 返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 -1 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png)
>
> 输入：grid = [[2,4],[6,8]], x = 2
> 输出：4
> 解释：可以执行下述操作使所有元素都等于 4 ： 
> - 2 加 x 一次。
> - 6 减 x 一次。
> - 8 减 x 两次。
> 共计 4 次操作。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png)
>
> 输入：grid = [[1,5],[2,3]], x = 1
> 输出：5
> 解释：可以使所有元素都等于 3 。
> 示例 3：
>
> ![img](https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png)
>
> 输入：grid = [[1,2],[3,4]], x = 2
> 输出：-1
> 解释：无法使所有元素相等。
>
>
> 提示：
>
> m == grid.length
> n == grid[i].length
> 1 <= m, n <= 105
> 1 <= m * n <= 105
> 1 <= x, grid[i][j] <= 104

```java
class Solution {
    public int minOperations(int[][] grid, int x) {
        int m=grid.length,n=grid[0].length;
        int[] arr=new int[m*n];
        int i=0;
        for(int[] a:grid){
            for(int b:a){
                arr[i++]=b;
            }
        }
        
        Arrays.sort(arr);
        int j=arr[(n*m)/2];
        int sum=0;
        for(int a:arr){
            int l=Math.abs(j-a);
            if(l%x!=0) return -1;
            sum+=l/x;
        }
        
        return sum;
    }
}
```

### \2034. 股票价格波动

> 给你一支股票价格的数据流。数据流中每一条记录包含一个 **时间戳** 和该时间点股票对应的 **价格** 。
>
> 不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 **更正** 前一条错误的记录。
>
> 请你设计一个算法，实现：
>
> - **更新** 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 **更正** 之前的错误价格。
> - 找到当前记录里 **最新股票价格** 。**最新股票价格** 定义为时间戳最晚的股票价格。
> - 找到当前记录里股票的 **最高价格** 。
> - 找到当前记录里股票的 **最低价格** 。
>
> 请你实现 `StockPrice` 类：
>
> - `StockPrice()` 初始化对象，当前无股票价格记录。
> - `void update(int timestamp, int price)` 在时间点 `timestamp` 更新股票价格为 `price` 。
> - `int current()` 返回股票 **最新价格** 。
> - `int maximum()` 返回股票 **最高价格** 。
> - `int minimum()` 返回股票 **最低价格** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：
> ["StockPrice", "update", "update", "current", "maximum", "update", "maximum", "update", "minimum"]
> [[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]
> 输出：
> [null, null, null, 5, 10, null, 5, null, 2]
> 
> 解释：
> StockPrice stockPrice = new StockPrice();
> stockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。
> stockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。
> stockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。
> stockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。
> stockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。
>                           // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。
> stockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。
> stockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。
> stockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= timestamp, price <= 109`
> - `update`，`current`，`maximum` 和 `minimum` **总** 调用次数不超过 `105` 。
> - `current`，`maximum` 和 `minimum` 被调用时，`update` 操作 **至少** 已经被调用过 **一次** 。

```java
class StockPrice {
    int curren_time;
    HashMap<Integer,Integer> hashMap;
    TreeMap<Integer,List<Integer>> treeMap;

    public StockPrice() {
        curren_time=0;//最新时间
        hashMap=new HashMap<>();//时间——价格
        treeMap=new TreeMap<>();//价格——时间
    }

    public void update(int timestamp, int price) {
        curren_time=Math.max(timestamp,curren_time);
        if(hashMap.containsKey(timestamp)){
            Integer pre_price=hashMap.get(timestamp);
            treeMap.get(pre_price).remove(Integer.valueOf(timestamp));
            if(treeMap.get(pre_price).size()==0) treeMap.remove(pre_price);
        }

        hashMap.put(timestamp,price);
        if(treeMap.containsKey(price)){
            List<Integer> temp=treeMap.get(price);
            temp.add(timestamp);
            treeMap.put(price,temp);
        }else {
            List<Integer> temp=new ArrayList<>();
            temp.add(timestamp);
            treeMap.put(price,temp);
        }
    }

    public int current() {
        return hashMap.get(curren_time);
    }

    public int maximum() {
        return treeMap.lastKey();
    }

    public int minimum() {
        return treeMap.firstKey();
    }
}
```



## 第 230 场周赛

### [1773. 统计匹配检索规则的物品数量](https://leetcode.cn/problems/count-items-matching-a-rule/)

> 给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。
>
> 另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。
>
> 如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：
>
> ruleKey == "type" 且 ruleValue == typei 。
> ruleKey == "color" 且 ruleValue == colori 。
> ruleKey == "name" 且 ruleValue == namei 。
> 统计并返回 匹配检索规则的物品数量 。
>
>  
>
> 示例 1：
>
> 输入：items = [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], ruleKey = "color", ruleValue = "silver"
> 输出：1
> 解释：只有一件物品匹配检索规则，这件物品是 ["computer","silver","lenovo"] 。
> 示例 2：
>
> 输入：items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], ruleKey = "type", ruleValue = "phone"
> 输出：2
> 解释：只有两件物品匹配检索规则，这两件物品分别是 ["phone","blue","pixel"] 和 ["phone","gold","iphone"] 。注意，["computer","silver","phone"] 未匹配检索规则。
>
>
> 提示：
>
> 1 <= items.length <= 104
> 1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10
> ruleKey 等于 "type"、"color" 或 "name"
> 所有字符串仅由小写字母组成
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/count-items-matching-a-rule
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        HashMap<String,HashMap<String,Integer>> hashMap=new HashMap<>();
        for(List<String> i:items){
            HashMap<String,Integer> temp=hashMap.getOrDefault("type",new HashMap<>());
            temp.put(i.get(0),temp.getOrDefault(i.get(0), 0) + 1);
            hashMap.put("type",temp);

            HashMap<String,Integer> temp1=hashMap.getOrDefault("color",new HashMap<>());
            temp1.put(i.get(1),temp1.getOrDefault(i.get(1), 0) + 1);
            hashMap.put("color",temp1);

            HashMap<String,Integer> temp2=hashMap.getOrDefault("name",new HashMap<>());
            temp2.put(i.get(2),temp2.getOrDefault(i.get(2), 0) + 1);
            hashMap.put("name",temp2);
        }

        if(!hashMap.get(ruleKey).containsKey(ruleValue)) return 0;
        return hashMap.get(ruleKey).get(ruleValue);
    }
}
```

### [1775. 通过最少操作次数使数组的和相等](https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/)

> 你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：
>
> 必须选择 一种 冰激凌基料。
> 可以添加 一种或多种 配料，也可以不添加任何配料。
> 每种类型的配料 最多两份 。
> 给你以下三个输入：
>
> baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。
> toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。
> target ，一个整数，表示你制作甜点的目标价格。
> 你希望自己做的甜点总成本尽可能接近目标价格 target 。
>
> 返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。
>
>  
>
> 示例 1：
>
> 输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10
> 输出：10
> 解释：考虑下面的方案组合（所有下标均从 0 开始）：
> - 选择 1 号基料：成本 7
> - 选择 1 份 0 号配料：成本 1 x 3 = 3
> - 选择 0 份 1 号配料：成本 0 x 4 = 0
> 总成本：7 + 3 + 0 = 10 。
> 示例 2：
>
> 输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18
> 输出：17
> 解释：考虑下面的方案组合（所有下标均从 0 开始）：
> - 选择 1 号基料：成本 3
> - 选择 1 份 0 号配料：成本 1 x 4 = 4
> - 选择 2 份 1 号配料：成本 2 x 5 = 10
> - 选择 0 份 2 号配料：成本 0 x 100 = 0
> 总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。
> 示例 3：
>
> 输入：baseCosts = [3,10], toppingCosts = [2,5], target = 9
> 输出：8
> 解释：可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。
> 示例 4：
>
> 输入：baseCosts = [10], toppingCosts = [1], target = 1
> 输出：10
> 解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。
>
>
> 提示：
>
> n == baseCosts.length
> m == toppingCosts.length
> 1 <= n, m <= 10
> 1 <= baseCosts[i], toppingCosts[i] <= 104
> 1 <= target <= 104
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/closest-dessert-cost
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int ans;
    int m,n;
    public void dfs(int[] top,int target,int u,int sum){
        if(u>=n){
            if(Math.abs(sum-target)<Math.abs(ans-target)){
                ans=sum;
            }else if(Math.abs(sum-target)==Math.abs(ans-target)){
                ans=Math.min(ans,sum);
            }
            return;
        }
        dfs(top,target,u+1,sum);
        dfs(top,target,u+1,sum+top[u]);
        dfs(top,target,u+1,sum+2*top[u]);
    }
    public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {
        ans=Integer.MAX_VALUE;
        m=baseCosts.length;
        n=toppingCosts.length;
        for(int i:baseCosts){
            dfs(toppingCosts,target,0,i);
        }

        return ans;
    }
}
```

## 第 237 场周赛

### \1832. 判断句子是否为全字母句

> **全字母句** 指包含英语字母表中每个字母至少一次的句子。
>
> 给你一个仅由小写英文字母组成的字符串 `sentence` ，请你判断 `sentence` 是否为 **全字母句** 。
>
> 如果是，返回 `true` ；否则，返回 `false` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：sentence = "thequickbrownfoxjumpsoverthelazydog"
> 输出：true
> 解释：sentence 包含英语字母表中每个字母至少一次。
> ```
>
> **示例 2：**
>
> ```
> 输入：sentence = "leetcode"
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - `1 <= sentence.length <= 1000`
> - `sentence` 由小写英语字母组成

```java
class Solution {
    public boolean checkIfPangram(String sentence) {
        int n=sentence.length();
        if(n<26) return false;
        int[] temp=new int[26];
        for(int i=0;i<n;i++){
            temp[sentence.charAt(i)-'a']++;
        }
        for(int i=0;i<26;i++)
            if(temp[i]==0) return false;
        return true;
    }
}
```

### \1833. 雪糕的最大数量

> 夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。
>
> 商店中新到 `n` 支雪糕，用长度为 `n` 的数组 `costs` 表示雪糕的定价，其中 `costs[i]` 表示第 `i` 支雪糕的现金价格。Tony 一共有 `coins` 现金可以用于消费，他想要买尽可能多的雪糕。
>
> 给你价格数组 `costs` 和现金量 `coins` ，请你计算并返回 Tony 用 `coins` 现金能够买到的雪糕的 **最大数量** 。
>
> **注意：**Tony 可以按任意顺序购买雪糕。
>
>  
>
> **示例 1：**
>
> ```
> 输入：costs = [1,3,2,4,1], coins = 7
> 输出：4
> 解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7
> ```
>
> **示例 2：**
>
> ```
> 输入：costs = [10,6,8,7,7,8], coins = 5
> 输出：0
> 解释：Tony 没有足够的钱买任何一支雪糕。
> ```
>
> **示例 3：**
>
> ```
> 输入：costs = [1,6,3,1,2,5], coins = 20
> 输出：6
> 解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。
> ```
>
>  
>
> **提示：**
>
> - `costs.length == n`
> - `1 <= n <= 10`^`5`
> - `1 <= costs[i] <= 10`^`5`
> - `1 <= coins <= 10^8`

```java
class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int ans=0,n=costs.length;
        Arrays.sort(costs);
        for(int i=0;i<n;i++){
            if(coins>=costs[i]){
                ans++;
                coins-=costs[i];
            }
        }

        return ans;
    }
}
```

### \1834. 单线程 CPU

> 给你一个二维数组 `tasks` ，用于表示 `n` 项从 `0` 到 `n - 1` 编号的任务。其中 `tasks[i] = [enqueueTimei, processingTimei]` 意味着第 `i` 项任务将会于 `enqueueTimei` 时进入任务队列，需要 `processingTimei` 的时长完成执行。
>
> 现有一个单线程 CPU ，同一时间只能执行 **最多一项** 任务，该 CPU 将会按照下述方式运行：
>
> - 如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。
> - 如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 **执行时间最短** 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。
> - 一旦某项任务开始执行，CPU 在 **执行完整个任务** 前都不会停止。
> - CPU 可以在完成一项任务后，立即开始执行一项新任务。
>
> 返回 CPU 处理任务的顺序。
>
>  
>
> **示例 1：**
>
> ```
> 输入：tasks = [[1,2],[2,4],[3,2],[4,1]]
> 输出：[0,2,3,1]
> 解释：事件按下述流程运行： 
> - time = 1 ，任务 0 进入任务队列，可执行任务项 = {0}
> - 同样在 time = 1 ，空闲状态的 CPU 开始执行任务 0 ，可执行任务项 = {}
> - time = 2 ，任务 1 进入任务队列，可执行任务项 = {1}
> - time = 3 ，任务 2 进入任务队列，可执行任务项 = {1, 2}
> - 同样在 time = 3 ，CPU 完成任务 0 并开始执行队列中用时最短的任务 2 ，可执行任务项 = {1}
> - time = 4 ，任务 3 进入任务队列，可执行任务项 = {1, 3}
> - time = 5 ，CPU 完成任务 2 并开始执行队列中用时最短的任务 3 ，可执行任务项 = {1}
> - time = 6 ，CPU 完成任务 3 并开始执行任务 1 ，可执行任务项 = {}
> - time = 10 ，CPU 完成任务 1 并进入空闲状态
> ```
>
> **示例 2：**
>
> ```
> 输入：tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
> 输出：[4,3,2,0,1]
> 解释：事件按下述流程运行： 
> - time = 7 ，所有任务同时进入任务队列，可执行任务项  = {0,1,2,3,4}
> - 同样在 time = 7 ，空闲状态的 CPU 开始执行任务 4 ，可执行任务项 = {0,1,2,3}
> - time = 9 ，CPU 完成任务 4 并开始执行任务 3 ，可执行任务项 = {0,1,2}
> - time = 13 ，CPU 完成任务 3 并开始执行任务 2 ，可执行任务项 = {0,1}
> - time = 18 ，CPU 完成任务 2 并开始执行任务 0 ，可执行任务项 = {1}
> - time = 28 ，CPU 完成任务 0 并开始执行任务 1 ，可执行任务项 = {}
> - time = 40 ，CPU 完成任务 1 并进入空闲状态
> ```
>
>  
>
> **提示：**
>
> - `tasks.length == n`
> - `1 <= n <= 10^5`
> - `1 <= enqueueTimei, processingTimei <= 10^9`

```java
class Solution {
    public int[] getOrder(int[][] tasks) {
        int n=tasks.length;
        int[][] arr=new int[n][3];
        for(int i=0;i<n;i++) arr[i]=new int[]{tasks[i][0],tasks[i][1],i};
        Arrays.sort(arr,(o1,o2)->o1[0]-o2[0]);
        PriorityQueue<int[]> q=new PriorityQueue<>((o1,o2)->o1[1]==o2[1]?o1[2]-o2[2]:o1[1]-o2[1]);
        int[] ans=new int[n];
        for(int time=1,j=0,idx=0;idx<n;){
            while (j<n&&arr[j][0]<=time) q.add(arr[j++]);
            if(q.isEmpty()){
                time=arr[j][0];
            }else{
                int[] cur=q.poll();
                ans[idx++]=cur[2];
                time+=cur[1];
            }
        }
        return ans;
    }
}
```

## 第 210 场周赛

### [1614. 括号的最大嵌套深度](https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/)

> 如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：
>
> 字符串是一个空字符串 ""，或者是一个不为 "(" 或 ")" 的单字符。
> 字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
> 字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。
> 类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：
>
> depth("") = 0
> depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 "(" 或者 ")"
> depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
> depth("(" + A + ")") = 1 + depth(A)，其中 A 是一个 有效括号字符串
> 例如：""、"()()"、"()(()())" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 ")(" 、"(()" 都不是 有效括号字符串 。
>
> 给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。
>
>  
>
> 示例 1：
>
> 输入：s = "(1+(2*3)+((8)/4))+1"
> 输出：3
> 解释：数字 8 在嵌套的 3 层括号中。
> 示例 2：
>
> 输入：s = "(1)+((2))+(((3)))"
> 输出：3
>
>
> 提示：
>
> 1 <= s.length <= 100
> s 由数字 0-9 和字符 '+'、'-'、'*'、'/'、'('、')' 组成
> 题目数据保证括号表达式 s 是 有效的括号表达式
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maxDepth(String s) {
        int ans=0,ans_temp=0;
        for(char i:s.toCharArray()){
            if(i=='('){
                ans_temp++;
                ans=Math.max(ans_temp,ans);
            }else if(i==')'){
                ans_temp--;
            }
        }

        return ans;
    }
}
```

### [1615. 最大网络秩](https://leetcode.cn/problems/maximal-network-rank/)

> n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。
>
> 两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。
>
> 整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。
>
> 给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex1.png)
>
> 输入：n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]
> 输出：4
> 解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。
> 示例 2：
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex2.png)
>
> 输入：n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]
> 输出：5
> 解释：共有 5 条道路与城市 1 或 2 相连。
> 示例 3：
>
> 输入：n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]
> 输出：5
> 解释：2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。
>
>
> 提示：
>
> 2 <= n <= 100
> 0 <= roads.length <= n * (n - 1) / 2
> roads[i].length == 2
> 0 <= ai, bi <= n-1
> ai != bi
> 每对城市之间 最多只有一条 道路相连
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximal-network-rank
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maximalNetworkRank(int n, int[][] roads) {
        HashMap<Integer, Integer> graph = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int size = 0;
            for (int[] j : roads) {
                if (j[0] == i || j[1] == i) size++;
            }
            graph.put(i, size);
        }

        List<int[]> num=new ArrayList<>();
        int max = 0, pre_max = 0,ans=0;
        for (int i = 0; i < n; i++) {
            num.add(new int[]{i,graph.get(i)});
        }
        Collections.sort(num,(o1,o2)->o2[1]-o1[1]);

        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                int[] pre_num=num.get(i);
                int[] cur_num=num.get(j);
                if(pd(pre_num[0],cur_num[0],roads)){
                    ans=Math.max(ans,pre_num[1]+cur_num[1]-1);
                }else{
                    ans=Math.max(ans,pre_num[1]+cur_num[1]);
                }   
            }
        }

        return ans;
    }
    public boolean pd(int pre_max,int max,int[][] roads){
        for (int[] i : roads) {
            if ((i[0] == pre_max && i[1] == max) || (i[0] == max && i[1] == pre_max)) {
                return true;
            }
        }
        return false;
    }
}
```

### \1616. 分割两个字符串得到回文串

> 给你两个字符串 `a` 和 `b` ，它们长度相同。请你选择一个下标，将两个字符串都在 **相同的下标** 分割开。由 `a` 可以得到两个字符串： `aprefix` 和 `asuffix` ，满足 `a = aprefix + asuffix` ，同理，由 `b` 可以得到两个字符串 `bprefix` 和 `bsuffix` ，满足 `b = bprefix + bsuffix` 。请你判断 `aprefix + bsuffix` 或者 `bprefix + asuffix` 能否构成回文串。
>
> 当你将一个字符串 `s` 分割成 `sprefix` 和 `ssuffix` 时， `ssuffix` 或者 `sprefix` 可以为空。比方说， `s = "abc"` 那么 `"" + "abc"` ， `"a" + "bc" `， `"ab" + "c"` 和 `"abc" + ""` 都是合法分割。
>
> 如果 **能构成回文字符串** ，那么请返回 `true`，否则返回 `false` 。
>
> **注意**， `x + y` 表示连接字符串 `x` 和 `y` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：a = "x", b = "y"
> 输出：true
> 解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：
> aprefix = "", asuffix = "x"
> bprefix = "", bsuffix = "y"
> 那么 aprefix + bsuffix = "" + "y" = "y" 是回文串。
> ```
>
> **示例 2：**
>
> ```
> 输入：a = "abdef", b = "fecab"
> 输出：true
> ```
>
> **示例 3：**
>
> ```
> 输入：a = "ulacfd", b = "jizalu"
> 输出：true
> 解释：在下标为 3 处分割：
> aprefix = "ula", asuffix = "cfd"
> bprefix = "jiz", bsuffix = "alu"
> 那么 aprefix + bsuffix = "ula" + "alu" = "ulaalu" 是回文串。
> ```
>
>  
>
> **提示：**
>
> - `1 <= a.length, b.length <= 10^5`
> - `a.length == b.length`
> - `a` 和 `b` 都只包含小写英文字母

```java
class Solution {
    public boolean checkPalindromeFormation(String a, String b) {
        return check(a,b)||check(b,a);
    }
    
    private boolean check(String a,String b){
        char[] stra = a.toCharArray();
        char[] strb = b.toCharArray();
        int left = 0;
        int length = stra.length;
        while (left<=length/2){
            if (stra[left]==strb[length-1-left])
                left++;
            else
                break;
        }
        //如果超过一半都是相等的，直接返回true
        if (left>=length/2)
            return true;
        //否则判断中间未遍历的部分是否是回文
        if (isPa(a.substring(left,length-left)) || isPa(b.substring(left,length-left)))
            return true;
        return false;
    }
    
    //判断是否回文
    private boolean isPa(String string){
        char[] str  =string.toCharArray();
        for (int i=0;i<str.length/2;i++){
            if (str[i]!=str[str.length-1-i])
                return false;
        }
        return true;
    }
}
```

## 第 304 场周赛

### [2357. 使数组中所有元素都等于零](https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/)

> 给你一个非负整数数组 nums 。在一步操作中，你必须：
>
> 选出一个正整数 x ，x 需要小于或等于 nums 中 最小 的 非零 元素。
> nums 中的每个正整数都减去 x。
> 返回使 nums 中所有元素都等于 0 需要的 最少 操作数。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,5,0,3,5]
> 输出：3
> 解释：
> 第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。
> 第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。
> 第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。
> 示例 2：
>
> 输入：nums = [0]
> 输出：0
> 解释：nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。
>
>
> 提示：
>
> 1 <= nums.length <= 100
> 0 <= nums[i] <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int minimumOperations(int[] nums) {
        int ans=0;
        outer:for(int i=0;i<nums.length;i++){
            int min=Integer.MAX_VALUE;
            for(int j=0;j<nums.length;j++){
                if(nums[j]>0) min=Math.min(min,nums[j]);
            }
            if(min==Integer.MAX_VALUE||min==0) break outer;
            ans++;
            for(int j=0;j<nums.length;j++){
                if(nums[j]!=0) nums[j]-=min;
            }
            for(int j=0;j<nums.length;j++){
                if(nums[j]!=0) break;
                if(j==nums.length-1) break outer; 
            }
        }
        return ans;
    }
}
```

### [2358. 分组的最大数量](https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/)

> 给你一个正整数数组 grades ，表示大学中一些学生的成绩。你打算将 所有 学生分为一些 有序 的非空分组，其中分组间的顺序满足以下全部条件：
>
> 第 i 个分组中的学生总成绩 小于 第 (i + 1) 个分组中的学生总成绩，对所有组均成立（除了最后一组）。
> 第 i 个分组中的学生总数 小于 第 (i + 1) 个分组中的学生总数，对所有组均成立（除了最后一组）。
> 返回可以形成的 最大 组数。
>
>  
>
> 示例 1：
>
> 输入：grades = [10,6,12,7,3,5]
> 输出：3
> 解释：下面是形成 3 个分组的一种可行方法：
> - 第 1 个分组的学生成绩为 grades = [12] ，总成绩：12 ，学生数：1
> - 第 2 个分组的学生成绩为 grades = [6,7] ，总成绩：6 + 7 = 13 ，学生数：2
> - 第 3 个分组的学生成绩为 grades = [10,3,5] ，总成绩：10 + 3 + 5 = 18 ，学生数：3 
> 可以证明无法形成超过 3 个分组。
> 示例 2：
>
> 输入：grades = [8,8]
> 输出：1
> 解释：只能形成 1 个分组，因为如果要形成 2 个分组的话，会导致每个分组中的学生数目相等。
>
>
> 提示：
>
> 1 <= grades.length <= 105
> 1 <= grades[i] <= 105
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maximumGroups(int[] grades) {
        int n=grades.length;
        int ans=1;
        for(int i=1;i<n;i++){
            if(i*(i+1)<=2*n) ans=i;
            else break;
        }
        return ans;
    }
}
```

### [2359. 找到离给定两个节点最近的节点](https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/)

> 给你一个 n 个节点的 有向图 ，节点编号为 0 到 n - 1 ，每个节点 至多 有一条出边。
>
> 有向图用大小为 n 下标从 0 开始的数组 edges 表示，表示节点 i 有一条有向边指向 edges[i] 。如果节点 i 没有出边，那么 edges[i] == -1 。
>
> 同时给你两个节点 node1 和 node2 。
>
> 请你返回一个从 node1 和 node2 都能到达节点的编号，使节点 node1 和节点 node2 到这个节点的距离 较大值最小化。如果有多个答案，请返回 最小 的节点编号。如果答案不存在，返回 -1 。
>
> 注意 edges 可能包含环。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png)
>
> 输入：edges = [2,2,3,-1], node1 = 0, node2 = 1
> 输出：2
> 解释：从节点 0 到节点 2 的距离为 1 ，从节点 1 到节点 2 的距离为 1 。
> 两个距离的较大值为 1 。我们无法得到一个比 1 更小的较大值，所以我们返回节点 2 。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png)
>
> 输入：edges = [1,2,-1], node1 = 0, node2 = 2
> 输出：2
> 解释：节点 0 到节点 2 的距离为 2 ，节点 2 到它自己的距离为 0 。
> 两个距离的较大值为 2 。我们无法得到一个比 2 更小的较大值，所以我们返回节点 2 。
>
>
> 提示：
>
> n == edges.length
> 2 <= n <= 105
> -1 <= edges[i] < n
> edges[i] != i
> 0 <= node1, node2 < n
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/find-closest-node-to-given-two-nodes
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int closestMeetingNode(int[] edges, int node1, int node2) {
        int[] d1=xz(edges,node1),d2=xz(edges,node2);
        int ans=-1,n=edges.length;
        for(int i=0,minDis=n;i<n;i++){
            int temp_max=Math.max(d1[i],d2[i]);
            if(temp_max<minDis){
                minDis=temp_max;
                ans=i;
            }
        }
        return ans;
    }
    int[] xz(int[] edgs,int x){
        int n=edgs.length;
        int[] ans=new int[n];
        Arrays.fill(ans,n);
        for(int i=0;x>=0&&ans[x]==n;x=edgs[x]){
            ans[x]=i++;
        }
        return ans;
    }
}
```

### [2360. 图中的最长环](https://leetcode.cn/problems/longest-cycle-in-a-graph/)

> 给你一个 n 个节点的 有向图 ，节点编号为 0 到 n - 1 ，其中每个节点 至多 有一条出边。
>
> 图用一个大小为 n 下标从 0 开始的数组 edges 表示，节点 i 到节点 edges[i] 之间有一条有向边。如果节点 i 没有出边，那么 edges[i] == -1 。
>
> 请你返回图中的 最长 环，如果没有任何环，请返回 -1 。
>
> 一个环指的是起点和终点是 同一个 节点的路径。
>
>  
>
> 示例 1：
>
> ![img](https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png)
>
> 输入：edges = [3,3,4,2,3]
> 输出去：3
> 解释：图中的最长环是：2 -> 4 -> 3 -> 2 。
> 这个环的长度为 3 ，所以返回 3 。
> 示例 2：
>
> ![img](https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png)
>
> 输入：edges = [2,-1,3,1]
> 输出：-1
> 解释：图中没有任何环。
>
>
> 提示：
>
> n == edges.length
> 2 <= n <= 105
> -1 <= edges[i] < n
> edges[i] != i
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/longest-cycle-in-a-graph
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int longestCycle(int[] edges) {
        HashMap<Integer, List<Integer>> graph = new HashMap<>();
        int[] in_degree = new int[edges.length];
        boolean[] visit=new boolean[edges.length];
        for (int i = 0; i < edges.length; i++) {
            int start = i, end = edges[i];
            if (start == end||end==-1) continue;
            graph.computeIfAbsent(start, key -> new ArrayList<>()).add(end);
            in_degree[end]++;
        }
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < edges.length; i++)
            if (in_degree[i] == 0) q.offer(i);
        int count=0;
        while (!q.isEmpty()) {
            int cur = q.poll();
            count++;
            visit[cur]=true;
            for (int nei : graph.getOrDefault(cur, new ArrayList<>())) {
                if (--in_degree[nei] == 0) q.offer(nei);
            }
        }
        if(count==edges.length) return -1;
        int ans=0;
        for(int i=0;i<edges.length;i++){
            if(visit[i]) continue;
            in_degree[i]=0;
            q.offer(i);
            count=0;
            while (!q.isEmpty()){
                int cur=q.poll();
                count++;
                for(int nei:graph.getOrDefault(cur,new ArrayList<>())){
                    if(--in_degree[nei]==0) q.offer(nei);
                }
            }

            ans=Math.max(ans,count);
        }

        return ans;
    }
}
```

## 第 192 场周赛 

### \1470. 重新排列数组

> 给你一个数组 `nums` ，数组中有 `2n` 个元素，按 `[x1,x2,...,xn,y1,y2,...,yn]` 的格式排列。
>
> 请你将数组按 `[x1,y1,x2,y2,...,xn,yn]` 格式重新排列，返回重排后的数组。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,5,1,3,4,7], n = 3
> 输出：[2,3,5,4,1,7] 
> 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,3,4,4,3,2,1], n = 4
> 输出：[1,4,2,3,3,2,4,1]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1,1,2,2], n = 2
> 输出：[1,2,1,2]
> ```
>
>  
>
> **提示：**
>
> - `1 <= n <= 500`
> - `nums.length == 2n`
> - `1 <= nums[i] <= 10^3`

```java
class Solution {
    public int[] shuffle(int[] nums, int n) {
        int[] ans=new int[2*n];
        int temp=-1;
        for(int i=0;i<n;i++){
            ans[++temp]=nums[i];
            ans[++temp]=nums[n+i];
        }
        
        return ans;
    }
}
```

### \1471. 数组中的 k 个最强值

> 给你一个整数数组 `arr` 和一个整数 `k` 。
>
> 设 `m` 为数组的中位数，只要满足下述两个前提之一，就可以判定 `arr[i]` 的值比 `arr[j]` 的值更强：
>
> -  `|arr[i] - m| > |arr[j] - m|`
> -  `|arr[i] - m| == |arr[j] - m|`，且 `arr[i] > arr[j]`
>
> 请返回由数组中最强的 `k` 个值组成的列表。答案可以以 **任意顺序** 返回。
>
> **中位数** 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 `n` ，那么中位数就是该有序列表（下标从 0 开始）中位于 `((n - 1) / 2)` 的元素。
>
> - 例如 `arr = [6, -3, 7, 2, 11]`，`n = 5`：数组排序后得到 `arr = [-3, 2, 6, 7, 11]` ，数组的中间位置为 `m = ((5 - 1) / 2) = 2` ，中位数 `arr[m]` 的值为 `6` 。
> - 例如 `arr = [-7, 22, 17, 3]`，`n = 4`：数组排序后得到 `arr = [-7, 3, 17, 22]` ，数组的中间位置为 `m = ((4 - 1) / 2) = 1` ，中位数 `arr[m]` 的值为 `3` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：arr = [1,2,3,4,5], k = 2
> 输出：[5,1]
> 解释：中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。
> 注意，尽管 |5 - 3| == |1 - 3| ，但是 5 比 1 更强，因为 5 > 1 。
> ```
>
> **示例 2：**
>
> ```
> 输入：arr = [1,1,3,5,5], k = 2
> 输出：[5,5]
> 解释：中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。
> ```
>
> **示例 3：**
>
> ```
> 输入：arr = [6,7,11,7,6,8], k = 5
> 输出：[11,8,6,6,7]
> 解释：中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。
> [11,8,6,6,7] 的任何排列都是正确答案。
> ```
>
> **示例 4：**
>
> ```
> 输入：arr = [6,-3,7,2,11], k = 3
> 输出：[-3,11,2]
> ```
>
> **示例 5：**
>
> ```
> 输入：arr = [-7,22,17,3], k = 2
> 输出：[22,17]
> ```
>
>  
>
> **提示：**
>
> - `1 <= arr.length <= 10^5`
> - `-10^5 <= arr[i] <= 10^5`
> - `1 <= k <= arr.length`

```java

class Solution {
    public int[] getStrongest(int[] arr, int k) {
        int n=arr.length;
        Arrays.sort(arr);
        int num=arr[(n-1)/2];
        
        List<int[]> list=new ArrayList<>();
        for(int i:arr){
            int a=Math.abs(i-num),b=i;
            list.add(new int[]{a,b});
        }
        Collections.sort(list, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0]==o2[0]) return o2[1]-o1[1];
                else return o2[0]-o1[0];
            }
        });
        
        int[] ans=new int[k];
        int temp=-1;
        for(int[] i:list){
            ans[++temp]=i[1];

            if(temp==k-1) break;
        }

        return ans;
    }
}
```

### \1472. 设计浏览器历史记录

> 你有一个只支持单个标签页的 **浏览器** ，最开始你浏览的网页是 `homepage` ，你可以访问其他的网站 `url` ，也可以在浏览历史中后退 `steps` 步或前进 `steps` 步。
>
> 请你实现 `BrowserHistory` 类：
>
> - `BrowserHistory(string homepage)` ，用 `homepage` 初始化浏览器类。
> - `void visit(string url)` 从当前页跳转访问 `url` 对应的页面 。执行此操作会把浏览历史前进的记录全部删除。
> - `string back(int steps)` 在浏览历史中后退 `steps` 步。如果你只能在浏览历史中后退至多 `x` 步且 `steps > x` ，那么你只后退 `x` 步。请返回后退 **至多** `steps` 步以后的 `url` 。
> - `string forward(int steps)` 在浏览历史中前进 `steps` 步。如果你只能在浏览历史中前进至多 `x` 步且 `steps > x` ，那么你只前进 `x` 步。请返回前进 **至多** `steps`步以后的 `url` 。
>
>  
>
> **示例：**
>
> ```
> 输入：
> ["BrowserHistory","visit","visit","visit","back","back","forward","visit","forward","back","back"]
> [["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]
> 输出：
> [null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"]
> 
> 解释：
> BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
> browserHistory.visit("google.com");       // 你原本在浏览 "leetcode.com" 。访问 "google.com"
> browserHistory.visit("facebook.com");     // 你原本在浏览 "google.com" 。访问 "facebook.com"
> browserHistory.visit("youtube.com");      // 你原本在浏览 "facebook.com" 。访问 "youtube.com"
> browserHistory.back(1);                   // 你原本在浏览 "youtube.com" ，后退到 "facebook.com" 并返回 "facebook.com"
> browserHistory.back(1);                   // 你原本在浏览 "facebook.com" ，后退到 "google.com" 并返回 "google.com"
> browserHistory.forward(1);                // 你原本在浏览 "google.com" ，前进到 "facebook.com" 并返回 "facebook.com"
> browserHistory.visit("linkedin.com");     // 你原本在浏览 "facebook.com" 。 访问 "linkedin.com"
> browserHistory.forward(2);                // 你原本在浏览 "linkedin.com" ，你无法前进任何步数。
> browserHistory.back(2);                   // 你原本在浏览 "linkedin.com" ，后退两步依次先到 "facebook.com" ，然后到 "google.com" ，并返回 "google.com"
> browserHistory.back(7);                   // 你原本在浏览 "google.com"， 你只能后退一步到 "leetcode.com" ，并返回 "leetcode.com"
> ```
>
>  
>
> **提示：**
>
> - `1 <= homepage.length <= 20`
> - `1 <= url.length <= 20`
> - `1 <= steps <= 100`
> - `homepage` 和 `url` 都只包含 '.' 或者小写英文字母。
> - 最多调用 `5000` 次 `visit`， `back` 和 `forward` 函数。

```java
class BrowserHistory {

    Deque<String> deque1=new ArrayDeque<>();
    Deque<String> deque2=new ArrayDeque<>();

    public BrowserHistory(String homepage) {
        deque1.push(homepage);
    }

    public void visit(String url) {
        deque1.push(url);
        deque2.clear();
    }

    public String back(int steps) {
        for(int i=0;i<steps&&deque1.size()>1;i++){
            deque2.push(deque1.poll());
        }
        return deque1.peek();
    }

    public String forward(int steps) {
        for(int i=0;i<steps&&!deque2.isEmpty();i++){
            deque1.push(deque2.poll());
        }
        return deque1.peek();
    }
}
```

1. ![捕获.PNG](https://cdn.jsdelivr.net/gh/yzk656/image/202212241928443.png)

## 第 236 场周赛

### \1822. 数组元素积的符号

> 已知函数 `signFunc(x)` 将会根据 `x` 的正负返回特定值：
>
> - 如果 `x` 是正数，返回 `1` 。
> - 如果 `x` 是负数，返回 `-1` 。
> - 如果 `x` 是等于 `0` ，返回 `0` 。
>
> 给你一个整数数组 `nums` 。令 `product` 为数组 `nums` 中所有元素值的乘积。
>
> 返回 `signFunc(product)` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [-1,-2,-3,-4,3,2,1]
> 输出：1
> 解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,5,0,2,-3]
> 输出：0
> 解释：数组中所有值的乘积是 0 ，且 signFunc(0) = 0
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [-1,1,-1,1,-1]
> 输出：-1
> 解释：数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 1000`
> - `-100 <= nums[i] <= 100`

```java
class Solution {
    public int arraySign(int[] nums) {
        long ans=1;
        for(int i:nums) {
            ans=(ans*i)%Integer.MAX_VALUE;
        }
        if(ans>0) return 1;
        else if(ans==0) return 0;
        else return -1;
    }
}
```

### \1823. 找出游戏的获胜者

> 共有 `n` 名小伙伴一起做游戏。小伙伴们围成一圈，按 **顺时针顺序** 从 `1` 到 `n` 编号。确切地说，从第 `i` 名小伙伴顺时针移动一位会到达第 `(i+1)` 名小伙伴的位置，其中 `1 <= i < n` ，从第 `n` 名小伙伴顺时针移动一位会回到第 `1` 名小伙伴的位置。
>
> 游戏遵循如下规则：
>
> 1. 从第 `1` 名小伙伴所在位置 **开始** 。
> 2. 沿着顺时针方向数 `k` 名小伙伴，计数时需要 **包含** 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
> 3. 你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
> 4. 如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 **顺时针下一位** 小伙伴 **开始**，回到步骤 `2` 继续执行。
> 5. 否则，圈子中最后一名小伙伴赢得游戏。
>
> 给你参与游戏的小伙伴总数 `n` ，和一个整数 `k` ，返回游戏的获胜者。
>
>  
>
> **示例 1：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241928502.png)
>
> ```
> 输入：n = 5, k = 2
> 输出：3
> 解释：游戏运行步骤如下：
> 1) 从小伙伴 1 开始。
> 2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。
> 3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。
> 4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。
> 5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。
> 6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。
> 7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。
> 8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。
> 9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 6, k = 5
> 输出：1
> 解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。
> ```
>
>  
>
> **提示：**
>
> - `1 <= k <= n <= 500`
>
>  
>
> **进阶：**你能否使用线性时间复杂度和常数空间复杂度解决此问题？

```java
class Solution {
    public int findTheWinner(int n, int k) {
        List<Integer> list=new ArrayList<>();
        for(int i=1;i<=n;i++){
            list.add(i);
        }

        int start=0,end=0;
        while (list.size()>1){
            end=(start+k-1)%list.size();
            start=(start+k-1)%list.size();
            list.remove(end);
        }
        
        return list.get(0);
    }
}
```

### \1824. 最少侧跳次数

> 给你一个长度为 `n` 的 **3 跑道道路** ，它总共包含 `n + 1` 个 **点** ，编号为 `0` 到 `n` 。一只青蛙从 `0` 号点第二条跑道 **出发** ，它想要跳到点 `n` 处。然而道路上可能有一些障碍。
>
> 给你一个长度为 `n + 1` 的数组 `obstacles` ，其中 `obstacles[i]` （**取值范围从 0 到 3**）表示在点 `i` 处的 `obstacles[i]` 跑道上有一个障碍。如果 `obstacles[i] == 0` ，那么点 `i` 处没有障碍。任何一个点的三条跑道中 **最多有一个** 障碍。
>
> - 比方说，如果 `obstacles[2] == 1` ，那么说明在点 2 处跑道 1 有障碍。
>
> 这只青蛙从点 `i` 跳到点 `i + 1` 且跑道不变的前提是点 `i + 1` 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 **同一个** 点处 **侧跳** 到 **另外一条** 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。
>
> - 比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。
>
> 这只青蛙从点 0 处跑道 `2` 出发，并想到达点 `n` 处的 **任一跑道** ，请你返回 **最少侧跳次数** 。
>
> **注意**：点 `0` 处和点 `n` 处的任一跑道都不会有障碍。
>
>  
>
> **示例 1：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241925807.png)
>
> ```
> 输入：obstacles = [0,1,2,3,0]
> 输出：2 
> 解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。
> 注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。
> ```
>
> **示例 2：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241925397.png)
>
> ```
> 输入：obstacles = [0,1,1,3,3,0]
> 输出：0
> 解释：跑道 2 没有任何障碍，所以不需要任何侧跳。
> ```
>
> **示例 3：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241925305.png)
>
> ```
> 输入：obstacles = [0,2,1,0,3,0]
> 输出：2
> 解释：最优方案如上图所示。总共有 2 次侧跳。
> ```
>
>  
>
> **提示：**
>
> - `obstacles.length == n + 1`
> - `1 <= n <= 5 * 105`
> - `0 <= obstacles[i] <= 3`
> - `obstacles[0] == obstacles[n] == 0`

```java
class Solution {
    int[] dx = new int[]{1, -1, 2, -2};

    public int minSideJumps(int[] obstacles) {
        int m = obstacles.length;
        boolean[][] visit = new boolean[3][m];
        PriorityQueue<int[]> queue = new PriorityQueue<>((o1, o2) -> o1[2] - o2[2]);
        queue.offer(new int[]{1, 0, 0});
        visit[1][0] = true;
        int ans = 0;
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int cur_x = cur[0], cur_y = cur[1], cur_value = cur[2];
            if (cur_y == m - 1) {
                ans = cur_value;
                break;
            }
            if (cur_y + 1 < m && obstacles[cur_y + 1]-1 != cur_x) {
                queue.add(new int[]{cur_x, cur_y + 1, cur_value});
                visit[cur_x][cur_y + 1] = true;
            } else {
                for (int i = 0; i < 4; i++) {
                    int x = dx[i] + cur_x;
                    if (x < 0 || x > 2 || obstacles[cur_y]-1 == x || visit[x][cur_y]) continue;
                    queue.offer(new int[]{x,cur_y,cur_value+1});
                    visit[x][cur_y]=true;
                }
            }
        }

        return ans;
    }
}
```

1. BFS

## 第 209 场周赛

### \1608. 特殊数组的特征值

> 给你一个非负整数数组 `nums` 。如果存在一个数 `x` ，使得 `nums` 中恰好有 `x` 个元素 **大于或者等于** `x` ，那么就称 `nums` 是一个 **特殊数组** ，而 `x` 是该数组的 **特征值** 。
>
> 注意： `x` **不必** 是 `nums` 的中的元素。
>
> 如果数组 `nums` 是一个 **特殊数组** ，请返回它的特征值 `x` 。否则，返回 `-1` 。可以证明的是，如果 `nums` 是特殊数组，那么其特征值 `x` 是 **唯一的** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [3,5]
> 输出：2
> 解释：有 2 个元素（3 和 5）大于或等于 2 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,0]
> 输出：-1
> 解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。
> 如果 x = 0，应该有 0 个元素 >= x，但实际有 2 个。
> 如果 x = 1，应该有 1 个元素 >= x，但实际有 0 个。
> 如果 x = 2，应该有 2 个元素 >= x，但实际有 0 个。
> x 不能取更大的值，因为 nums 中只有两个元素。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [0,4,3,0,4]
> 输出：3
> 解释：有 3 个元素大于或等于 3 。
> ```
>
> **示例 4：**
>
> ```
> 输入：nums = [3,6,7,7,0]
> 输出：-1
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 100`
> - `0 <= nums[i] <= 1000`

```java
class Solution {
    public int specialArray(int[] nums) {
        int max=Arrays.stream(nums).max().getAsInt();
        for(int i=0;i<=max;i++){
            int sum=0;
            for(int j:nums){
                if(j>=i) sum++;
            }
        
            if(sum==i){
                return i;
            }
        }
        return -1;
    }
}
```

### \1609. 奇偶树

> 如果一棵二叉树满足下述几个条件，则可以称为 **奇偶树** ：
>
> - 二叉树根节点所在层下标为 `0` ，根的子节点所在层下标为 `1` ，根的孙节点所在层下标为 `2` ，依此类推。
> - **偶数下标** 层上的所有节点的值都是 **奇** 整数，从左到右按顺序 **严格递增**
> - **奇数下标** 层上的所有节点的值都是 **偶** 整数，从左到右按顺序 **严格递减**
>
> 给你二叉树的根节点，如果二叉树为 **奇偶树** ，则返回 `true` ，否则返回 `false` 。
>
>  
>
> **示例 1：**
>
> **![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241925662.png)**
>
> ```
> 输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
> 输出：true
> 解释：每一层的节点值分别是：
> 0 层：[1]
> 1 层：[10,4]
> 2 层：[3,7,9]
> 3 层：[12,8,6,2]
> 由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。
> ```
>
> **示例 2：**
>
> **![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241925177.png)**
>
> ```
> 输入：root = [5,4,2,3,3,7]
> 输出：false
> 解释：每一层的节点值分别是：
> 0 层：[5]
> 1 层：[4,2]
> 2 层：[3,3,7]
> 2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。
> ```
>
> **示例 3：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241925815.png)
>
> ```
> 输入：root = [5,9,1,3,5,7]
> 输出：false
> 解释：1 层上的节点值应为偶数。
> ```
>
> **示例 4：**
>
> ```
> 输入：root = [1]
> 输出：true
> ```
>
> **示例 5：**
>
> ```
> 输入：root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]
> 输出：true
> ```
>
>  
>
> **提示：**
>
> - 树中节点数在范围 `[1, 105]` 内
> - `1 <= Node.val <= 106`

```java
class Solution {
    public boolean isEvenOddTree(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; ++i) {
                TreeNode cur = queue.poll();
                if (depth % 2 == 0) {
                    if (cur.val % 2 == 0) return false;
                    list.add(cur.val);
                    if (cur.left != null) queue.offer(cur.left);
                    if (cur.right != null) queue.offer(cur.right);
                } else if (depth % 2 == 1) {
                    if (cur.val % 2 == 1) return false;
                    list.add(cur.val);
                    if (cur.left != null) queue.offer(cur.left);
                    if (cur.right != null) queue.offer(cur.right);
                }
            }
            if (!pd(depth, list)) return false;
            depth++;
        }

        return true;
    }

    public boolean pd(int depth, List<Integer> list) {
        //偶数层 递增
        if (depth % 2 == 0) {
            for (int i = 1; i < list.size(); i++) {
                if (list.get(i - 1) >= list.get(i)) return false;
            }
        } else if (depth % 2 == 1) {//奇数层 递减
            for (int i = 1; i < list.size(); i++) {
                if (list.get(i - 1) <= list.get(i)) return false;
            }
        }

        return true;
    }
}
```

## 第 84 场双周赛

### [6141. 合并相似的物品](https://leetcode.cn/problems/merge-similar-items/)

> 给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质：
>
> items[i] = [valuei, weighti] 其中 valuei 表示第 i 件物品的 价值 ，weighti 表示第 i 件物品的 重量 。
> items 中每件物品的价值都是 唯一的 。
> 请你返回一个二维数组 ret，其中 ret[i] = [valuei, weighti]， weighti 是所有价值为 valuei 物品的 重量之和 。
>
> 注意：ret 应该按价值 升序 排序后返回。
>
>  
>
> 示例 1：
>
> 输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]
> 输出：[[1,6],[3,9],[4,5]]
> 解释：
> value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。
> value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。
> value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。
> 所以，我们返回 [[1,6],[3,9],[4,5]] 。
> 示例 2：
>
> 输入：items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]
> 输出：[[1,4],[2,4],[3,4]]
> 解释：
> value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。
> value = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。
> value = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。
> 所以，我们返回 [[1,4],[2,4],[3,4]] 。
> 示例 3：
>
> 输入：items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]
> 输出：[[1,7],[2,4],[7,1]]
> 解释：
> value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。
> value = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。
> value = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。
> 所以，我们返回 [[1,7],[2,4],[7,1]] 。
>
>
> 提示：
>
> 1 <= items1.length, items2.length <= 1000
> items1[i].length == items2[i].length == 2
> 1 <= valuei, weighti <= 1000
> items1 中每个 valuei 都是 唯一的 。
> items2 中每个 valuei 都是 唯一的 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/merge-similar-items
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {
        TreeMap<Integer,Integer> treeMap=new TreeMap<>();
        for(int[] i:items1){
            treeMap.put(i[0],treeMap.getOrDefault(i[0],0)+i[1]);
        }
        for(int[] i:items2){
            treeMap.put(i[0],treeMap.getOrDefault(i[0],0)+i[1]);
        }
        List<List<Integer>> ans=new ArrayList<>();
        for(int i:treeMap.keySet()){
            List<Integer> temp=new ArrayList<>();
            temp.add(i);
            temp.add(treeMap.get(i));
            ans.add(temp);
        }

        return ans;
    }
}
```

### [6142. 统计坏数对的数目](https://leetcode.cn/problems/count-number-of-bad-pairs/)

> 给你一个下标从 0 开始的整数数组 nums 。如果 i < j 且 j - i != nums[j] - nums[i] ，那么我们称 (i, j) 是一个 坏数对 。
>
> 请你返回 nums 中 坏数对 的总数目。
>
>  
>
> 示例 1：
>
> 输入：nums = [4,1,3,3]
> 输出：5
> 解释：数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。
> 数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。
> 数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。
> 数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。
> 数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。
> 总共有 5 个坏数对，所以我们返回 5 。
> 示例 2：
>
> 输入：nums = [1,2,3,4,5]
> 输出：0
> 解释：没有坏数对。
>
>
> 提示：
>
> 1 <= nums.length <= 105
> 1 <= nums[i] <= 109
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/count-number-of-bad-pairs
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public long countBadPairs(int[] nums) {
        long ans=nums.length*1l*(nums.length-1)/2;
        HashMap<Integer,Integer> hashMap=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            hashMap.put(nums[i]-i,hashMap.getOrDefault(nums[i]-i,0)+1);
        }
        for(int i:hashMap.values()){
            ans-=i*1l*(i-1)/2;
        }
        return ans;
    }
}
```

### [6174. 任务调度器 II](https://leetcode.cn/problems/task-scheduler-ii/)

> 给你一个下标从 0 开始的正整数数组 tasks ，表示需要 按顺序 完成的任务，其中 tasks[i] 表示第 i 件任务的 类型 。
>
> 同时给你一个正整数 space ，表示一个任务完成 后 ，另一个 相同 类型任务完成前需要间隔的 最少 天数。
>
> 在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：
>
> 完成 tasks 中的下一个任务
> 休息一天
> 请你返回完成所有任务所需的 最少 天数。
>
>  
>
> 示例 1：
>
> 输入：tasks = [1,2,1,2,3,1], space = 3
> 输出：9
> 解释：
> 9 天完成所有任务的一种方法是：
> 第 1 天：完成任务 0 。
> 第 2 天：完成任务 1 。
> 第 3 天：休息。
> 第 4 天：休息。
> 第 5 天：完成任务 2 。
> 第 6 天：完成任务 3 。
> 第 7 天：休息。
> 第 8 天：完成任务 4 。
> 第 9 天：完成任务 5 。
> 可以证明无法少于 9 天完成所有任务。
> 示例 2：
>
> 输入：tasks = [5,8,8,5], space = 2
> 输出：6
> 解释：
> 6 天完成所有任务的一种方法是：
> 第 1 天：完成任务 0 。
> 第 2 天：完成任务 1 。
> 第 3 天：休息。
> 第 4 天：休息。
> 第 5 天：完成任务 2 。
> 第 6 天：完成任务 3 。
> 可以证明无法少于 6 天完成所有任务。
>
>
> 提示：
>
> 1 <= tasks.length <= 105
> 1 <= tasks[i] <= 109
> 1 <= space <= tasks.length
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/task-scheduler-ii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public long taskSchedulerII(int[] tasks, int space) {
        long ans=0;
        HashMap<Integer,Long> hashMap=new HashMap<>();
        for(int i:tasks){
            ans++;
            if(hashMap.containsKey(i)){
                long pre=hashMap.get(i);
                if(pre+space>=ans){
                    ans=pre+space+1;
                }
            }
            hashMap.put(i,ans);
        }

        return ans;
    }
}
```

## 第 305 场周赛

### [6136. 算术三元组的数目](https://leetcode.cn/problems/number-of-arithmetic-triplets/)

> 给你一个下标从 0 开始、严格递增 的整数数组 nums 和一个正整数 diff 。如果满足下述全部条件，则三元组 (i, j, k) 就是一个 算术三元组 ：
>
> i < j < k ，
> nums[j] - nums[i] == diff 且
> nums[k] - nums[j] == diff
> 返回不同 算术三元组 的数目。
>
>  
>
> 示例 1：
>
> 输入：nums = [0,1,4,6,7,10], diff = 3
> 输出：2
> 解释：
> (1, 2, 4) 是算术三元组：7 - 4 == 3 且 4 - 1 == 3 。
> (2, 4, 5) 是算术三元组：10 - 7 == 3 且 7 - 4 == 3 。
> 示例 2：
>
> 输入：nums = [4,5,6,7,8,9], diff = 2
> 输出：2
> 解释：
> (0, 2, 4) 是算术三元组：8 - 6 == 2 且 6 - 4 == 2 。
> (1, 3, 5) 是算术三元组：9 - 7 == 2 且 7 - 5 == 2 。
>
>
> 提示：
>
> 3 <= nums.length <= 200
> 0 <= nums[i] <= 200
> 1 <= diff <= 50
> nums 严格 递增
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/number-of-arithmetic-triplets
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans=0;
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                for(int k=j+1;k<nums.length;k++){
                    if(nums[k]-nums[j]==diff&&nums[j]-nums[i]==diff){
                        ans++;
                    }
                }
            }
        }

        return ans;
    }
}
```

### [6139. 受限条件下可到达节点的数目](https://leetcode.cn/problems/reachable-nodes-with-restrictions/)

> 现有一棵由 n 个节点组成的无向树，节点编号从 0 到 n - 1 ，共有 n - 1 条边。
>
> 给你一个二维整数数组 edges ，长度为 n - 1 ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条边。另给你一个整数数组 restricted 表示 受限 节点。
>
> 在不访问受限节点的前提下，返回你可以从节点 0 到达的 最多 节点数目。
>
> 注意，节点 0 不 会标记为受限节点。
>
>  
>
> 示例 1：
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241925565.png)
>
> 输入：n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
> 输出：4
> 解释：上图所示正是这棵树。
> 在不访问受限节点的前提下，只有节点 [0,1,2,3] 可以从节点 0 到达。
> 示例 2：
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241925685.png)
>
>
> 输入：n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
> 输出：3
> 解释：上图所示正是这棵树。
> 在不访问受限节点的前提下，只有节点 [0,5,6] 可以从节点 0 到达。
>
>
> 提示：
>
> 2 <= n <= 105
> edges.length == n - 1
> edges[i].length == 2
> 0 <= ai, bi < n
> ai != bi
> edges 表示一棵有效的树
> 1 <= restricted.length < n
> 1 <= restricted[i] < n
> restricted 中的所有值 互不相同
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/reachable-nodes-with-restrictions
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int reachableNodes(int n, int[][] edges, int[] restricted) {
        HashMap<Integer,List<Integer>> graph=new HashMap<>();
        for(int[] i:edges){
            graph.computeIfAbsent(i[0],key->new ArrayList<>()).add(i[1]);
            graph.computeIfAbsent(i[1],key->new ArrayList<>()).add(i[0]);
        }
        Set<Integer> set=new HashSet<>();
        for(int i:restricted) set.add(i);
        boolean[] visit=new boolean[n];
        Queue<Integer> queue=new LinkedList<>();
        queue.offer(0);
        visit[0]=true;
        int ans=1;
        while (!queue.isEmpty()){
            int cur=queue.poll();
            for(int i:graph.getOrDefault(cur,new ArrayList<>())){
                if(visit[i]||set.contains(i)) continue;
                else {
                    queue.offer(i);
                    visit[i]=true;
                    ans++;
                }
            }
        }

        return ans;
    }
}
```

### [6137. 检查数组是否存在有效划分](https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/)

> 给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。
>
> 如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分：
>
> 子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。
> 子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。
> 子数组 恰 由 3 个连续递增元素组成，并且相邻元素之间的差值为 1 。例如，子数组 [3,4,5] ，但是子数组 [1,3,5] 不符合要求。
> 如果数组 至少 存在一种有效划分，返回 true ，否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：nums = [4,4,4,5,6]
> 输出：true
> 解释：数组可以划分成子数组 [4,4] 和 [4,5,6] 。
> 这是一种有效划分，所以返回 true 。
> 示例 2：
>
> 输入：nums = [1,1,1,2]
> 输出：false
> 解释：该数组不存在有效划分。
>
>
> 提示：
>
> 2 <= nums.length <= 105
> 1 <= nums[i] <= 106
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean validPartition(int[] nums) {
        int n=nums.length;
        boolean[] f=new boolean[n+1];
        f[0]=true;
        for (int i=1;i<n;i++){
            int x=nums[i];
            if(f[i-1]&&x==nums[i-1])
                f[i+1]=true;
            if(i>1){
                if(f[i-2]&&nums[i-1]==nums[i-2]&&x==nums[i-1])
                    f[i+1]=true;
                if(f[i-2]&&x-nums[i-1]==1&&nums[i-1]-nums[i-2]==1)
                    f[i+1]=true;
            }
        }

        return f[n];
    }
}
```

## 第 157 场周赛

### \1217. 玩筹码

> 有 `n` 个筹码。第 `i` 个筹码的位置是 `position[i]` 。
>
> 我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 `i` 个筹码的位置从 `position[i]` 改变为:
>
> 
>
> - `position[i] + 2` 或 `position[i] - 2` ，此时 `cost = 0`
> - `position[i] + 1` 或 `position[i] - 1` ，此时 `cost = 1`
>
> 返回将所有筹码移动到同一位置上所需要的 *最小代价* 。
>
>  
>
> **示例 1：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241925518.jpeg)
>
> ```
> 输入：position = [1,2,3]
> 输出：1
> 解释：第一步:将位置3的筹码移动到位置1，成本为0。
> 第二步:将位置2的筹码移动到位置1，成本= 1。
> 总成本是1。
> ```
>
> **示例 2：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241924346.jpeg)
>
> ```
> 输入：position = [2,2,2,3,3]
> 输出：2
> 解释：我们可以把位置3的两个筹码移到位置2。每一步的成本为1。总成本= 2。
> ```
>
> **示例 3:**
>
> ```
> 输入：position = [1,1000000000]
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - `1 <= chips.length <= 100`
> - `1 <= chips[i] <= 10^9`

```java
class Solution {
    public int minCostToMoveChips(int[] position) {
        int ans=Integer.MAX_VALUE;
        for(int i=0;i<position.length;i++){
            int temp_ans=0;
            for(int j=0;j<position.length;j++){
                int num=(position[j]-position[i])%2==0?0:1;
                temp_ans+=num;
            }
            ans=Math.min(temp_ans,ans);
        }
        
        return ans;
    }
}
```

### \1218. 最长定差子序列

> 给你一个整数数组 `arr` 和一个整数 `difference`，请你找出并返回 `arr` 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 `difference` 。
>
> **子序列** 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 `arr` 派生出来的序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：arr = [1,2,3,4], difference = 1
> 输出：4
> 解释：最长的等差子序列是 [1,2,3,4]。
> ```
>
> **示例 2：**
>
> ```
> 输入：arr = [1,3,5,7], difference = 1
> 输出：1
> 解释：最长的等差子序列是任意单个元素。
> ```
>
> **示例 3：**
>
> ```
> 输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2
> 输出：4
> 解释：最长的等差子序列是 [7,5,3,1]。
> ```
>
>  
>
> **提示：**
>
> - `1 <= arr.length <= 105`
> - `-104 <= arr[i], difference <= 104`

```java
class Solution {
    public int longestSubsequence(int[] arr, int difference) {
        HashMap<Integer,Integer> hashMap=new HashMap<>();
        int max=0;
        for(int num:arr){
            int key=num-difference;
            int length= hashMap.getOrDefault(key,0)+1;
            hashMap.put(num,length);
            max=Math.max(max,length);
        }

        return max;
    }
}
```

### \1219. 黄金矿工

> 你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 `m * n` 的网格 `grid` 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 `0`。
>
> 为了使收益最大化，矿工需要按以下规则来开采黄金：
>
> - 每当矿工进入一个单元，就会收集该单元格中的所有黄金。
> - 矿工每次可以从当前位置向上下左右四个方向走。
> - 每个单元格只能被开采（进入）一次。
> - **不得开采**（进入）黄金数目为 `0` 的单元格。
> - 矿工可以从网格中 **任意一个** 有黄金的单元格出发或者是停止。
>
>  
>
> **示例 1：**
>
> ```
> 输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
> 输出：24
> 解释：
> [[0,6,0],
>  [5,8,7],
>  [0,9,0]]
> 一种收集最多黄金的路线是：9 -> 8 -> 7。
> ```
>
> **示例 2：**
>
> ```
> 输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
> 输出：28
> 解释：
> [[1,0,7],
>  [2,0,6],
>  [3,4,5],
>  [0,3,0],
>  [9,0,20]]
> 一种收集最多黄金的路线是：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7。
> ```
>
>  
>
> **提示：**
>
> - `1 <= grid.length, grid[i].length <= 15`
> - `0 <= grid[i][j] <= 100`
> - 最多 **25** 个单元格中有黄金。

```java
class Solution {
    int[] dx = new int[]{0, 1, 0, -1};
    int[] dy = new int[]{1, 0, -1, 0};
    boolean[][] visit;

    public int getMaximumGold(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        List<int[]> list = new ArrayList<>();
        visit = new boolean[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] > 0) list.add(new int[]{i, j});
            }
        }

        int ans = 0;
        for (int[] i : list) {
            int x = i[0], y = i[1];
            visit[x][y] = true;
            int num = dfs(grid, x, y);
            visit[x][y] = false;
            ans = Math.max(ans, num);
        }

        return ans;
    }

    public int dfs(int[][] grid, int x, int y) {
        int ans = grid[x][y];
        int m = grid.length, n = grid[0].length;
        for (int i = 0; i < 4; i++) {
            int cur_x = x + dx[i], cur_y = y + dy[i];
            if (cur_x >= 0 && cur_x < m && cur_y >= 0 && cur_y < n && !visit[cur_x][cur_y] && grid[cur_x][cur_y] > 0) {
                visit[cur_x][cur_y] = true;
                ans = Math.max(ans, grid[x][y] + dfs(grid, cur_x, cur_y));
                visit[cur_x][cur_y] = false;
            }
        }

        return ans;
    }
}
```

1. 不要求路径最短时，需要用回溯
2. <img src="https://cdn.jsdelivr.net/gh/yzk656/image/202212241924244.png" alt="image-20220808230804993" style="zoom:25%;" />

## 第 138 场周赛

### \1051. 高度检查器

> 学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 **非递减** 的高度顺序排成一行。
>
> 排序后的高度情况用整数数组 `expected` 表示，其中 `expected[i]` 是预计排在这一行中第 `i` 位的学生的高度（**下标从 0 开始**）。
>
> 给你一个整数数组 `heights` ，表示 **当前学生站位** 的高度情况。`heights[i]` 是这一行中第 `i` 位学生的高度（**下标从 0 开始**）。
>
> 返回满足 `heights[i] != expected[i]` 的 **下标数量** 。
>
>  
>
> **示例：**
>
> ```
> 输入：heights = [1,1,4,2,1,3]
> 输出：3 
> 解释：
> 高度：[1,1,4,2,1,3]
> 预期：[1,1,1,2,3,4]
> 下标 2 、4 、5 处的学生高度不匹配。
> ```
>
> **示例 2：**
>
> ```
> 输入：heights = [5,1,2,3,4]
> 输出：5
> 解释：
> 高度：[5,1,2,3,4]
> 预期：[1,2,3,4,5]
> 所有下标的对应学生高度都不匹配。
> ```
>
> **示例 3：**
>
> ```
> 输入：heights = [1,2,3,4,5]
> 输出：0
> 解释：
> 高度：[1,2,3,4,5]
> 预期：[1,2,3,4,5]
> 所有下标的对应学生高度都匹配。
> ```
>
>  
>
> **提示：**
>
> - `1 <= heights.length <= 100`
> - `1 <= heights[i] <= 100`

```java
class Solution {
    public int heightChecker(int[] heights) {
        int[] a=heights.clone();
        Arrays.sort(a);
        int ans=0;
        for(int i=0;i<a.length;i++)
            if(heights[i]!=a[i]) ans++;
        return ans;
    }
}
```

### \1052. 爱生气的书店老板

> 有一个书店老板，他的书店开了 `n` 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 `n` 的整数数组 `customers` ，其中 `customers[i]` 是在第 `i` 分钟开始时进入商店的顾客数量，所有这些顾客在第 `i` 分钟结束后离开。
>
> 在某些时候，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。
>
> 当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。
>
> 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 `minutes` 分钟不生气，但却只能使用一次。
>
> 请你返回 *这一天营业下来，最多有多少客户能够感到满意* 。
>  
>
> **示例 1：**
>
> ```
> 输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
> 输出：16
> 解释：书店老板在最后 3 分钟保持冷静。
> 感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
> ```
>
> **示例 2：**
>
> ```
> 输入：customers = [1], grumpy = [0], minutes = 1
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - `n == customers.length == grumpy.length`
> - `1 <= minutes <= n <= 2 * 104`
> - `0 <= customers[i] <= 1000`
> - `grumpy[i] == 0 or 1`

```java
class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int n=customers.length;
        int pre_sum=0;
        for(int i=0;i<n;i++)
            if(grumpy[i]==0) pre_sum+=customers[i];
        int left=0,right=0;
        int temp_sum=0,temp_max=0;
        //System.out.println(pre_sum);
        while (right<n){
            if(grumpy[right]==1){
                temp_sum+=customers[right];
                //System.out.println(temp_sum);
                temp_max=Math.max(temp_max,temp_sum);
            }
            if(right-left==minutes-1){
                temp_sum-=grumpy[left]==1?customers[left]:0;
                left++;
            }
            right++;
        }

        return pre_sum+temp_max;
    }
}
```

### \1054. 距离相等的条形码

> 在一个仓库里，有一排条形码，其中第 `i` 个条形码为 `barcodes[i]`。
>
> 请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：barcodes = [1,1,1,2,2,2]
> 输出：[2,1,2,1,2,1]
> ```
>
> **示例 2：**
>
> ```
> 输入：barcodes = [1,1,1,1,2,2,3,3]
> 输出：[1,3,1,3,2,1,2,1]
> ```
>
>  
>
> **提示：**
>
> - `1 <= barcodes.length <= 10000`
> - `1 <= barcodes[i] <= 10000`

```java
class Solution {
    public int[] rearrangeBarcodes(int[] barcodes) {
        int max=Arrays.stream(barcodes).max().getAsInt();
        int[] counts=new int[max+1],ans=new int[barcodes.length];
        for(int i:barcodes) counts[i]++;
        PriorityQueue<Integer> priorityQueue=new PriorityQueue<>((o1,o2)->counts[o2]-counts[o1]);
        for(int i=0;i<counts.length;i++) {
            if(counts[i]!=0)
            priorityQueue.offer(i);
        }

        int index=0;
        while (priorityQueue.size()>1){
            int a=priorityQueue.poll();
            int b=priorityQueue.poll();
            ans[index++]=a;
            ans[index++]=b;
            if(counts[a]>=2){
                counts[a]--;
                priorityQueue.offer(a);
            }
            if(counts[b]>=2){
                counts[b]--;
                priorityQueue.offer(b);
            }
        }
        if(!priorityQueue.isEmpty()) ans[index]=priorityQueue.poll();

        return ans;
    }
}
```

1. 优先队列，先把目前数目多的进行排队去除
2. 同时优先队列也保证先进先出的做法
   1. 对于`1 1 1 2 2 3 4`最终1会排在末尾，从而避免出现` 2 1 2 1 1 3 4`的情况

## 第 200 场周赛

### \1534. 统计好三元组

> 给你一个整数数组 `arr` ，以及 `a`、`b` 、`c` 三个整数。请你统计其中好三元组的数量。
>
> 如果三元组 `(arr[i], arr[j], arr[k])` 满足下列全部条件，则认为它是一个 **好三元组** 。
>
> - `0 <= i < j < k < arr.length`
> - `|arr[i] - arr[j]| <= a`
> - `|arr[j] - arr[k]| <= b`
> - `|arr[i] - arr[k]| <= c`
>
> 其中 `|x|` 表示 `x` 的绝对值。
>
> 返回 **好三元组的数量** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
> 输出：4
> 解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1
> 输出：0
> 解释：不存在满足所有条件的三元组。
> ```
>
>  
>
> **提示：**
>
> - `3 <= arr.length <= 100`
> - `0 <= arr[i] <= 1000`
> - `0 <= a, b, c <= 1000`

```java
class Solution {
    public int countGoodTriplets(int[] arr, int a, int b, int c) {
        int ans=0;
        for(int i=0;i< arr.length;i++){
            for(int j=i+1;j<arr.length;j++){
                for(int k=j+1;k<arr.length;k++){
                    int num1=Math.abs(arr[i]-arr[j]);
                    int num2=Math.abs(arr[j]-arr[k]);
                    int num3=Math.abs(arr[i]-arr[k]);
                    if(num1<=a&&num2<=b&&num3<=c) ans++;
                }
            }
        }

        return ans;
    }
}
```

### \1535. 找出数组游戏的赢家

> 给你一个由 **不同** 整数组成的整数数组 `arr` 和一个整数 `k` 。
>
> 每回合游戏都在数组的前两个元素（即 `arr[0]` 和 `arr[1]` ）之间进行。比较 `arr[0]` 与 `arr[1]` 的大小，较大的整数将会取得这一回合的胜利并保留在位置 `0` ，较小的整数移至数组的末尾。当一个整数赢得 `k` 个连续回合时，游戏结束，该整数就是比赛的 **赢家** 。
>
> 返回赢得比赛的整数。
>
> 题目数据 **保证** 游戏存在赢家。
>
>  ![image-20220811001600465](https://cdn.jsdelivr.net/gh/yzk656/image/202212241924047.png)
>
> **示例 1：**
>
> ```
> 输入：arr = [2,1,3,5,4,6,7], k = 2
> 输出：5
> 解释：一起看一下本场游戏每回合的情况：
> 因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。
> ```
>
> **示例 2：**
>
> ```
> 输入：arr = [3,2,1], k = 10
> 输出：3
> 解释：3 将会在前 10 个回合中连续获胜。
> ```
>
> **示例 3：**
>
> ```
> 输入：arr = [1,9,8,2,3,7,6,4,5], k = 7
> 输出：9
> ```
>
> **示例 4：**
>
> ```
> 输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000
> 输出：99
> ```
>
>  
>
> **提示：**
>
> - `2 <= arr.length <= 10^5`
> - `1 <= arr[i] <= 10^6`
> - `arr` 所含的整数 **各不相同** 。
> - `1 <= k <= 10^9`

```java
class Solution {
    public int getWinner(int[] arr, int k) {
        List<Integer> list= new ArrayList<>(arr.length);
        for(int i:arr) list.add(i);
        int max=Arrays.stream(arr).max().getAsInt();

        while (true){
            int temp=0;
            while (list.get(0)<list.get(1)){
                temp=1;
                list.add(list.get(0));
                list.remove(0);
                if(temp==k||list.get(0)==max) return list.get(0);
            }
            while (list.get(0)>list.get(1)){
                temp++;
                if(temp==k||list.get(0)==max) return list.get(0);
                list.add(list.get(1));
                list.remove(1);
            }
        }

    }
}
```

### \1536. 排布二进制网格的最少交换次数

> 给你一个 `n x n` 的二进制网格 `grid`，每一次操作中，你可以选择网格的 **相邻两行** 进行交换。
>
> 一个符合要求的网格需要满足主对角线以上的格子全部都是 **0** 。
>
> 请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 **-1** 。
>
> 主对角线指的是从 `(1, 1)` 到 `(n, n)` 的这些格子。
>
>  
>
> **示例 1：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241924487.jpeg)
>
> ```
> 输入：grid = [[0,0,1],[1,1,0],[1,0,0]]
> 输出：3
> ```
>
> **示例 2：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241924900.jpeg)
>
> ```
> 输入：grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]
> 输出：-1
> 解释：所有行都是一样的，交换相邻行无法使网格符合要求。
> ```
>
> **示例 3：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241924340.jpeg)
>
> ```
> 输入：grid = [[1,0,0],[1,1,0],[1,1,1]]
> 输出：0
> ```
>
>  
>
> **提示：**
>
> - `n == grid.length`
> - `n == grid[i].length`
> - `1 <= n <= 200`
> - `grid[i][j]` 要么是 `0` 要么是 `1` 。

```java
class Solution {
    //满足f[i]<=i
    public int minSwaps(int[][] grid) {
        int m=grid.length,n=grid[0].length;
        int[] f=new int[m];
        for(int i=0;i<m;i++){
            for(int j=n-1;j>=0;j--){
                if(grid[i][j]==1) {
                    f[i]=j;
                    break;
                }
            }
        }
        int ans=0;
        for(int i=0;i<m;i++){
            if(f[i]<=i) continue;
            int temp_index=m;
            for(int j=i+1;j<m;j++){
                if(f[j]<=i){
                    temp_index=j;
                    break;
                }
            }
            if(temp_index==m) return -1;
            for(int j=temp_index;j>i;j--){
                int temp_f=f[j];
                f[j]=f[j-1];
                f[j-1]=temp_f;
                ans++;
            }
        }

        return ans;
    }
}
```

## 第 240 场周赛

### [1854. 人口最多的年份](https://leetcode.cn/problems/maximum-population-year/)

> 给你一个二维整数数组 logs ，其中每个 logs[i] = [birthi, deathi] 表示第 i 个人的出生和死亡年份。
>
> 年份 x 的 人口 定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：x 在闭区间 [birthi, deathi - 1] 内。注意，人不应当计入他们死亡当年的人口中。
>
> 返回 人口最多 且 最早 的年份。
>
>  
>
> 示例 1：
>
> 输入：logs = [[1993,1999],[2000,2010]]
> 输出：1993
> 解释：人口最多为 1 ，而 1993 是人口为 1 的最早年份。
> 示例 2：
>
> 输入：logs = [[1950,1961],[1960,1971],[1970,1981]]
> 输出：1960
> 解释： 
> 人口最多为 2 ，分别出现在 1960 和 1970 。
> 其中最早年份是 1960 。
>
>
> 提示：
>
> 1 <= logs.length <= 100
> 1950 <= birthi < deathi <= 2050
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-population-year
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maximumPopulation(int[][] logs) {
        Arrays.sort(logs, ((o1, o2) -> o1[0] - o2[0]));
        
        List<Integer> list = new ArrayList<>();
        for (int[] i : logs) list.add(i[0]);

        int ans = 0, ans_index = 0;
        for (int i : list) {
            int temp_ans = 0;
            for (int[] j : logs) {
                int a = j[0], b = j[1];
                if (i >= a && i < b) temp_ans++;
            }
            if (temp_ans > ans) {
                
                ans_index = i;
                ans = temp_ans;
            }
        }

        return ans_index;
    }
}
```

### [1855. 下标对中的最大距离](https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values/)

> 给你两个 非递增 的整数数组 nums1 和 nums2 ，数组下标均 从 0 开始 计数。
>
> 下标对 (i, j) 中 0 <= i < nums1.length 且 0 <= j < nums2.length 。如果该下标对同时满足 i <= j 且 nums1[i] <= nums2[j] ，则称之为 有效 下标对，该下标对的 距离 为 j - i 。
>
> 返回所有 有效 下标对 (i, j) 中的 最大距离 。如果不存在有效下标对，返回 0 。
>
> 一个数组 arr ，如果每个 1 <= i < arr.length 均有 arr[i-1] >= arr[i] 成立，那么该数组是一个 非递增 数组。
>
>  
>
> 示例 1：
>
> 输入：nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
> 输出：2
> 解释：有效下标对是 (0,0), (2,2), (2,3), (2,4), (3,3), (3,4) 和 (4,4) 。
> 最大距离是 2 ，对应下标对 (2,4) 。
> 示例 2：
>
> 输入：nums1 = [2,2,2], nums2 = [10,10,1]
> 输出：1
> 解释：有效下标对是 (0,0), (0,1) 和 (1,1) 。
> 最大距离是 1 ，对应下标对 (0,1) 。
> 示例 3：
>
> 输入：nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
> 输出：2
> 解释：有效下标对是 (2,2), (2,3), (2,4), (3,3) 和 (3,4) 。
> 最大距离是 2 ，对应下标对 (2,4) 。
>
>
> 提示：
>
> 1 <= nums1.length <= 105
> 1 <= nums2.length <= 105
> 1 <= nums1[i], nums2[j] <= 105
> nums1 和 nums2 都是 非递增 数组
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maxDistance(int[] nums1, int[] nums2) {
        int ans=0;
        int m=nums1.length,n=nums2.length;
        for(int i=0;i<m;i++){
            int num=nums1[i];
            int l=i,r=n-1;
            while (l<r){
                int mid=(l+r+1)>>1;
                if(nums2[mid]>=num){
                    l=mid;
                }else{
                    r=mid-1;
                }
            }
            ans=Math.max(l-i,ans);
        }

        return ans;
    }
}
```

### \1856. 子数组最小乘积的最大值

> 一个数组的 **最小乘积** 定义为这个数组中 **最小值** **乘以** 数组的 **和** 。
>
> - 比方说，数组 `[3,2,5]` （最小值是 `2`）的最小乘积为 `2 * (3+2+5) = 2 * 10 = 20` 。
>
> 给你一个正整数数组 `nums` ，请你返回 `nums` 任意 **非空子数组** 的**最小乘积** 的 **最大值** 。由于答案可能很大，请你返回答案对 `109 + 7` **取余** 的结果。
>
> 请注意，最小乘积的最大值考虑的是取余操作 **之前** 的结果。题目保证最小乘积的最大值在 **不取余** 的情况下可以用 **64 位有符号整数** 保存。
>
> **子数组** 定义为一个数组的 **连续** 部分。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,3,2]
> 输出：14
> 解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。
> 2 * (2+3+2) = 2 * 7 = 14 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,3,3,1,2]
> 输出：18
> 解释：最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。
> 3 * (3+3) = 3 * 6 = 18 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [3,1,5,6,4,2]
> 输出：60
> 解释：最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。
> 4 * (5+6+4) = 4 * 15 = 60 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `1 <= nums[i] <= 107`

```java
class Solution {
    public int maxSumMinProduct(int[] nums) {
        int n=nums.length;
        Deque<Integer> deque=new ArrayDeque<>();
        int[] left=new int[n];
        int[] right=new int[n];
        Arrays.fill(left,-1);
        Arrays.fill(right,n);
        long mod=(long) 1e9+7;

        for(int i=0;i<n;i++){
            while (!deque.isEmpty()&&nums[deque.peek()]>nums[i]){//如果前面的值比当前值大
                Integer pop=deque.pop();
                right[pop]=i;//修改前面的元素的值，改为遇到的小值下标最大子序列不包括该下标的值
            }
            deque.push(i);
        }
        deque.clear();

        for(int i=n-1;i>=0;i--){
            while (!deque.isEmpty()&&nums[deque.peek()]>nums[i]){
                Integer pop=deque.pop();
                left[pop]=i;
            }
            deque.push(i);
        }
        deque.clear();

        long[] pre_sum=new long[n+1];//nums[0]=pre_sum[1]
        for(int i=1;i<=n;i++) pre_sum[i]=pre_sum[i-1]+nums[i-1];

        long ans=0;
        for(int i=0;i<n;i++){
            int l=left[i]+1;
            int r=right[i]-1;
            ans=Math.max(ans,(pre_sum[r+1]-pre_sum[l])*nums[i]);
        }

        return (int) (ans%mod);
    }
}
```

1. 地址:https://www.bilibili.com/video/BV1rK4y1A7GE?spm_id_from=333.337.search-card.all.click&vd_source=2b44df7de02d967d7dc69478401443b4
2. 因为是把每个元素值作为最小值去查找空间的，因此，遇到相等的不用等于

## 第 83 场周赛

### \830. 较大分组的位置

> 在一个由小写字母构成的字符串 `s` 中，包含由一些连续的相同字符所构成的分组。
>
> 例如，在字符串 `s = "abbxxxxzyy"` 中，就含有 `"a"`, `"bb"`, `"xxxx"`, `"z"` 和 `"yy"` 这样的一些分组。
>
> 分组可以用区间 `[start, end]` 表示，其中 `start` 和 `end` 分别表示该分组的起始和终止位置的下标。上例中的 `"xxxx"` 分组用区间表示为 `[3,6]` 。
>
> 我们称所有包含大于或等于三个连续字符的分组为 **较大分组** 。
>
> 找到每一个 **较大分组** 的区间，**按起始位置下标递增顺序排序后**，返回结果。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "abbxxxxzzy"
> 输出：[[3,6]]
> 解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "abc"
> 输出：[]
> 解释："a","b" 和 "c" 均不是符合要求的较大分组。
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "abcdddeeeeaabbbcd"
> 输出：[[3,5],[6,9],[12,14]]
> 解释：较大分组为 "ddd", "eeee" 和 "bbb"
> ```
>
> **示例 4：**
>
> ```
> 输入：s = "aba"
> 输出：[]
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s` 仅含小写英文字母

```java
class Solution {
    public List<List<Integer>> largeGroupPositions(String s) {
        List<List<Integer>> ans=new ArrayList<>();

        int left=0,right=1,n=s.length();
        while (right<n){
            while (right<n&&s.charAt(right)==s.charAt(left)){
                right++;
            }
            right--;
            if(right-left>=2){
                List<Integer> list=new ArrayList<>();
                list.add(left);
                list.add(right);
                ans.add(list);
            }
            right+=2;
            left=right-1;
        }

        return ans;
    }
}
```

### \831. 隐藏个人信息

> 给你一条个人信息字符串 `s` ，可能表示一个 **邮箱地址** ，也可能表示一串 **电话号码** 。返回按如下规则 **隐藏** 个人信息后的结果：
>
> ***电子邮件地址：***
>
> 一个电子邮件地址由以下部分组成：
>
> - 一个 **名字** ，由大小写英文字母组成，后面跟着
> - 一个 `'@'` 字符，后面跟着
> - 一个 **域名** ，由大小写英文字母和一个位于中间的 `'.'` 字符组成。`'.'` 不会是域名的第一个或者最后一个字符。
>
> 要想隐藏电子邮件地址中的个人信息：
>
> - **名字** 和 **域名** 部分的大写英文字母应当转换成小写英文字母。
> - **名字** 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 `"*****"` 替换。
>
> ***电话号码：***
>
> 一个电话号码应当按下述格式组成：
>
> - 电话号码可以由 10-13 位数字组成
> - 后 10 位构成 **本地号码**
> - 前面剩下的 0-3 位，构成 **国家代码**
> - 利用 `{'+', '-', '(', ')', ' '}` 这些 **分隔字符** 按某种形式对上述数字进行分隔
>
> 要想隐藏电话号码中的个人信息：
>
> - 移除所有 **分隔字符**
> - 隐藏个人信息后的电话号码应该遵从这种格式：
>   - `"***-***-XXXX"` 如果国家代码为 0 位数字
>   - `"+*-***-***-XXXX"` 如果国家代码为 1 位数字
>   - `"+**-***-***-XXXX"` 如果国家代码为 2 位数字
>   - `"+***-***-***-XXXX"` 如果国家代码为 3 位数字
> - `"XXXX"` 是最后 4 位 **本地号码**
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "LeetCode@LeetCode.com"
> 输出："l*****e@leetcode.com"
> 解释：s 是一个电子邮件地址。
> 名字和域名都转换为小写，名字的中间用 5 个 * 替换。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "AB@qq.com"
> 输出："a*****b@qq.com"
> 解释：s 是一个电子邮件地址。
> 名字和域名都转换为小写，名字的中间用 5 个 * 替换。
> 注意，尽管 "ab" 只有两个字符，但中间仍然必须有 5 个 * 。
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "1(234)567-890"
> 输出："***-***-7890"
> 解释：s 是一个电话号码。
> 共计 10 位数字，所以本地号码为 10 位数字，国家代码为 0 位数字。
> 因此，隐藏后的电话号码应该是 "***-***-7890" 。
> ```
>
> **示例 4：**
>
> ```
> 输入：s = "86-(10)12345678"
> 输出："+**-***-***-5678"
> 解释：s 是一个电话号码。
> 共计 12 位数字，所以本地号码为 10 位数字，国家代码为 2 位数字。
> 因此，隐藏后的电话号码应该是 "+**-***-***-7890" 。
> ```
>
>  
>
> **提示：**
>
> - `s` 是一个 **有效** 的电子邮件或者电话号码
>
> - 如果
>
>    
>
>   ```
>   s
>   ```
>
>    
>
>   是一个电子邮件：
>
>   - `8 <= s.length <= 40`
>   - `s` 是由大小写英文字母，恰好一个 `'@'` 字符，以及 `'.'` 字符组成
>
> - 如果
>
>    
>
>   ```
>   s
>   ```
>
>    
>
>   是一个电话号码：
>
>   - `10 <= s.length <= 20`
>   - `s` 是由数字、空格、字符 `'('`、`')'`、`'-'` 和 `'+'` 组成

```java
class Solution {
    public String maskPII(String s) {
        int n = s.length();
        List<Character> list = new ArrayList<>();
        for (int i = 0; i < n; i++) list.add(s.charAt(i));

        String ans = "";
        if (list.contains('@')) {
            ans = email(s);
        } else {
            ans = phone(s);
        }

        return ans;
    }

    public String email(String s) {
        String[] temp = s.split("@");
        StringBuilder ans = new StringBuilder();

        String temp1=temp[0].toLowerCase();
        ans.append(temp1.charAt(0)).append("*****").append(temp1.charAt(temp1.length()-1));

        ans.append("@");

        temp1=temp[1].toLowerCase();
        ans.append(temp1);

        return ans.toString();
    }

    public String phone(String s) {
        int num=0;
        for(int i=0;i<s.length();i++)
            if(Character.isDigit(s.charAt(i)))
                num++;
        int[] s1=new int[num];
        int temp=-1;
        for(int i=0;i<s.length();i++)
            if(Character.isDigit(s.charAt(i)))
                s1[++temp]=s.charAt(i)-'0';

        StringBuilder ans=new StringBuilder();
        if(num==10){
            ans.append("***-***-").append(s1[num-4]).append(s1[num-3]).append(s1[num-2]).append(s1[num-1]);
        }else if(num==11){
            ans.append("+*-***-***-").append(s1[num-4]).append(s1[num-3]).append(s1[num-2]).append(s1[num-1]);
        } else if (num==12) {
            ans.append("+**-***-***-").append(s1[num-4]).append(s1[num-3]).append(s1[num-2]).append(s1[num-1]);
        }else {
            ans.append("+***-***-***-").append(s1[num-4]).append(s1[num-3]).append(s1[num-2]).append(s1[num-1]);
        }

        return ans.toString();
    }
}
```

### \829. 连续整数求和

> 给定一个正整数 `n`，返回 *连续正整数满足所有数字之和为 `n` 的组数* 。 
>
>  
>
> **示****例 1:**
>
> ```
> 输入: n = 5
> 输出: 2
> 解释: 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。
> ```
>
> **示例 2:**
>
> ```
> 输入: n = 9
> 输出: 3
> 解释: 9 = 4 + 5 = 2 + 3 + 4
> ```
>
> **示例 3:**
>
> ```
> 输入: n = 15
> 输出: 4
> 解释: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5
> ```
>
>  
>
> **提示:**
>
> - `1 <= n <= 109`

```java
class Solution {
    public int consecutiveNumbersSum(int n) {
        int ans=0;n*=2;
        for(int k=1;k*k<n;k++){
            if(n%k!=0) continue;
            if((n/k-(k-1))%2==0) ans++;
        }

        return ans;
    }
}
```

1. ![image-20220813010237799](https://cdn.jsdelivr.net/gh/yzk656/image/202212241923061.png)
2. 

## 第 32 场双周赛

### [1539. 第 k 个缺失的正整数](https://leetcode.cn/problems/kth-missing-positive-number/)

> 给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。
>
> 请你找到这个数组里第 k 个缺失的正整数。
>
>  
>
> 示例 1：
>
> 输入：arr = [2,3,4,7,11], k = 5
> 输出：9
> 解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。
> 示例 2：
>
> 输入：arr = [1,2,3,4], k = 2
> 输出：6
> 解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。
>
>
> 提示：
>
> 1 <= arr.length <= 1000
> 1 <= arr[i] <= 1000
> 1 <= k <= 1000
> 对于所有 1 <= i < j <= arr.length 的 i 和 j 满足 arr[i] < arr[j] 
>
>
> 进阶：
>
> 你可以设计一个时间复杂度小于 O(n) 的算法解决此问题吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/kth-missing-positive-number
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int findKthPositive(int[] arr, int k) {
        int num=k;
        List<Integer> list=new ArrayList<>();
        for(int i:arr) list.add(i);

        int max=Arrays.stream(arr).max().getAsInt();
        int ans=0;
        for(int i=1;i<=max+num;i++){
            if(!list.contains(i)){
                k--;
                if(k==0){
                    ans=i;
                    break;
                }
            }
        }

        return ans;
    }
}
```

### [1540. K 次操作转变字符串](https://leetcode.cn/problems/can-convert-string-in-k-moves/)

> 给你两个字符串 s 和 t ，你的目标是在 k 次操作以内把字符串 s 转变成 t 。
>
> 在第 i 次操作时（1 <= i <= k），你可以选择进行如下操作：
>
> 选择字符串 s 中满足 1 <= j <= s.length 且之前未被选过的任意下标 j （下标从 1 开始），并将此位置的字符切换 i 次。
> 不进行任何操作。
> 切换 1 个字符的意思是用字母表中该字母的下一个字母替换它（字母表环状接起来，所以 'z' 切换后会变成 'a'）。第 i 次操作意味着该字符应切换 i 次
>
> 请记住任意一个下标 j 最多只能被操作 1 次。
>
> 如果在不超过 k 次操作内可以把字符串 s 转变成 t ，那么请你返回 true ，否则请你返回 false 。
>
>  
>
> 示例 1：
>
> 输入：s = "input", t = "ouput", k = 9
> 输出：true
> 解释：第 6 次操作时，我们将 'i' 切换 6 次得到 'o' 。第 7 次操作时，我们将 'n' 切换 7 次得到 'u' 。
> 示例 2：
>
> 输入：s = "abc", t = "bcd", k = 10
> 输出：false
> 解释：我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 'a' 切换成 'b' ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母。
> 示例 3：
>
> 输入：s = "aab", t = "bbb", k = 27
> 输出：true
> 解释：第 1 次操作时，我们将第一个 'a' 切换 1 次得到 'b' 。在第 27 次操作时，我们将第二个字母 'a' 切换 27 次得到 'b' 。
>
>
> 提示：
>
> 1 <= s.length, t.length <= 10^5
> 0 <= k <= 10^9
> s 和 t 只包含小写英文字母。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/can-convert-string-in-k-moves
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean canConvertString(String s, String t, int k) {
        if(s.length()!=t.length()) return false;
        int[] counts=new int[26];
        int n=s.length();
        for(int i=0;i<n;i++){
            int diff=t.charAt(i)-s.charAt(i);
            if(diff<0) diff+=26;
            counts[diff]++;
        }
        for(int i=1;i<26;i++){
            int max_cover=i+26*(counts[i]-1);
            if(max_cover>k) return false;
        }
        
        return true;
    }
}
```

### [1541. 平衡括号字符串的最少插入次数](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/)

> 给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足：
>
> 任何左括号 '(' 必须对应两个连续的右括号 '))' 。
> 左括号 '(' 必须在对应的连续两个右括号 '))' 之前。
> 比方说 "())"， "())(())))" 和 "(())())))" 都是平衡的， ")()"， "()))" 和 "(()))" 都是不平衡的。
>
> 你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。
>
> 请你返回让 s 平衡的最少插入次数。
>
>  
>
> 示例 1：
>
> 输入：s = "(()))"
> 输出：1
> 解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 "(())))" 。
> 示例 2：
>
> 输入：s = "())"
> 输出：0
> 解释：字符串已经平衡了。
> 示例 3：
>
> 输入：s = "))())("
> 输出：3
> 解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。
> 示例 4：
>
> 输入：s = "(((((("
> 输出：12
> 解释：添加 12 个 ')' 得到平衡字符串。
> 示例 5：
>
> 输入：s = ")))))))"
> 输出：5
> 解释：在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 "(((())))))))" 。
>
>
> 提示：
>
> 1 <= s.length <= 10^5
> s 只包含 '(' 和 ')' 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int minInsertions(String s) {
        int ans=0,need=0,n=s.length();
        for(int i=0;i<n;i++){
            char c=s.charAt(i);
            if(c=='('){
                need+=2;
                if(need%2==1){
                    ans++;
                    need--;
                }
            }else {
                need--;
                if(need==-1){
                    ans++;
                    need=1;
                }
            }
        }

        return ans+need;
    }
}
```

1. 基本思路

   遍历字符串，通过一个 `need` 变量记录对右括号的需求数，根据 `need` 的变化来判断是否需要插入。

   类似 [921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid)，当 `need == -1` 时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号。

   另外，当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号，因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数，这一点也是本题的难点。

   **详细题解：[如何解决括号相关的问题](https://labuladong.github.io/article/fname.html?fname=括号插入)**

### [921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)

> 只有满足下面几点之一，括号字符串才是有效的：
>
> 它是一个空字符串，或者
> 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
> 它可以被写作 (A)，其中 A 是有效字符串。
> 给定一个括号字符串 s ，移动N次，你就可以在字符串的任何位置插入一个括号。
>
> 例如，如果 s = "()))" ，你可以插入一个开始括号为 "(()))" 或结束括号为 "())))" 。
> 返回 为使结果字符串 s 有效而必须添加的最少括号数。
>
>  
>
> 示例 1：
>
> 输入：s = "())"
> 输出：1
> 示例 2：
>
> 输入：s = "((("
> 输出：3
>
>
> 提示：
>
> 1 <= s.length <= 1000
> s 只包含 '(' 和 ')' 字符。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int minAddToMakeValid(String s) {
        int ans=0,need=0,n=s.length();
        for(int i=0;i<n;i++){
            char c=s.charAt(i);
            if(c=='('){
                need++;
            }else {
                need--;
                if(need==-1){
                    ans++;
                    need=0;
                }
            }
        }
        
        return ans+need;
    }
}
```

## 第 306 场周赛

### [6148. 矩阵中的局部最大值](https://leetcode.cn/problems/largest-local-values-in-a-matrix/)

> 给你一个大小为 n x n 的整数矩阵 grid 。
>
> 生成一个大小为 (n - 2) x (n - 2) 的整数矩阵  maxLocal ，并满足：
>
> maxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。
> 换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。
>
> 返回生成的矩阵。
>
>  
>
> 示例 1：
>
> <img src="https://cdn.jsdelivr.net/gh/yzk656/image/202212241923775.png" alt="img" style="zoom:33%;" />
>
> 输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
> 输出：[[9,9],[8,6]]
> 解释：原矩阵和生成的矩阵如上图所示。
> 注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。
> 示例 2：
>
> <img src="https://cdn.jsdelivr.net/gh/yzk656/image/202212241923074.png" alt="img" style="zoom:33%;" />
>
> 输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]
> 输出：[[2,2,2],[2,2,2],[2,2,2]]
> 解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。
>
>
> 提示：
>
> n == grid.length == grid[i].length
> 3 <= n <= 100
> 1 <= grid[i][j] <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/largest-local-values-in-a-matrix
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int[][] largestLocal(int[][] grid) {
        int m=grid.length,n=grid[0].length;
        int[][] ans=new int[m-2][n-2];
        for(int i=0;i<m-2;i++){
            for(int j=0;j<n-2;j++){
                int x=i+1,y=j+1;
                int max=0;
                for(int p=x-1;p<=x+1;p++){
                    for(int q=y-1;q<=y+1;q++){
                        max=Math.max(max,grid[p][q]);
                    }
                }

                ans[i][j]=max;
            }
        }

        return ans;
    }
}
```

### [6149. 边积分最高的节点](https://leetcode.cn/problems/node-with-highest-edge-score/)

> 给你一个有向图，图中有 n 个节点，节点编号从 0 到 n - 1 ，其中每个节点都 恰有一条 出边。
>
> 图由一个下标从 0 开始、长度为 n 的整数数组 edges 表示，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的 有向 边。
>
> 节点 i 的 边积分 定义为：所有存在一条指向节点 i 的边的节点的 编号 总和。
>
> 返回 边积分 最高的节点。如果多个节点的 边积分 相同，返回编号 最小 的那个。
>
>  
>
> 示例 1：
>
> <img src="https://cdn.jsdelivr.net/gh/yzk656/image/202212241923228.png" alt="img" style="zoom:33%;" />
>
>
> 输入：edges = [1,0,0,0,0,7,7,5]
> 输出：7
> 解释：
> - 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。
> - 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。
> - 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。
> - 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。
> 节点 7 的边积分最高，所以返回 7 。
> 示例 2：
> - <img src="https://cdn.jsdelivr.net/gh/yzk656/image/202212241923598.png" alt="img" style="zoom:33%;" />
>
>
> 输入：edges = [2,0,0,2]
> 输出：0
> 解释：
> - 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。
> - 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。
> 节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。
>
>
> 提示：
>
> n == edges.length
> 2 <= n <= 105
> 0 <= edges[i] < n
> edges[i] != i
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/node-with-highest-edge-score
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int edgeScore(int[] edges) {
        HashMap<Integer, List<Integer>> hashMap = new HashMap<>();
        int max = Arrays.stream(edges).max().getAsInt(), n = edges.length;
        for (int i = 0; i < n; i++) {
            int start = i, end = edges[i];
            hashMap.computeIfAbsent(end, key -> new ArrayList<>()).add(start);
        }

        int ans=0;
        TreeSet<long[]> treeSet = new TreeSet<>((o1, o2) -> (int) (o2[1]%Integer.MAX_VALUE == o1[1]%Integer.MAX_VALUE ? o1[0] - o2[0] : o2[1]%Integer.MAX_VALUE - o1[1]%Integer.MAX_VALUE));
        for(int i=0;i<=max;i++){
            long ans_temp=0;
            for(int j:hashMap.getOrDefault(i,new ArrayList<>())){
                ans_temp+=j;
            }
            treeSet.add(new long[]{i,ans_temp});
        }

        return (int) treeSet.first()[0];
    }
}
```

## 第 31 场双周赛

### [1523. 在区间范围内统计奇数数目](https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/)

> 给你两个非负整数 low 和 high 。请你返回 low 和 high 之间（包括二者）奇数的数目。
>
>  
>
> 示例 1：
>
> 输入：low = 3, high = 7
> 输出：3
> 解释：3 到 7 之间奇数数字为 [3,5,7] 。
> 示例 2：
>
> 输入：low = 8, high = 10
> 输出：1
> 解释：8 到 10 之间奇数数字为 [9] 。
>
>
> 提示：
>
> 0 <= low <= high <= 10^9
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int countOdds(int low, int high) {
        int ans = 0;
        int num = high - low + 1;
        if (num % 2 == 0) return num / 2;
        else {
            ans+=num/2;
            ans+=low%2==0?0:1;
            return ans;
        }
    }
}
```

### [1524. 和为奇数的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/)

> 给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。
>
> 由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。
>
>  
>
> 示例 1：
>
> 输入：arr = [1,3,5]
> 输出：4
> 解释：所有的子数组为 [[1],[1,3],[1,3,5],[3],[3,5],[5]] 。
> 所有子数组的和为 [1,4,9,3,8,5].
> 奇数和包括 [1,9,3,5] ，所以答案为 4 。
> 示例 2 ：
>
> 输入：arr = [2,4,6]
> 输出：0
> 解释：所有子数组为 [[2],[2,4],[2,4,6],[4],[4,6],[6]] 。
> 所有子数组和为 [2,6,12,4,10,6] 。
> 所有子数组和都是偶数，所以答案为 0 。
> 示例 3：
>
> 输入：arr = [1,2,3,4,5,6,7]
> 输出：16
> 示例 4：
>
> 输入：arr = [100,100,99,99]
> 输出：4
> 示例 5：
>
> 输入：arr = [7]
> 输出：1
>
>
> 提示：
>
> 1 <= arr.length <= 10^5
> 1 <= arr[i] <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int numOfSubarrays(int[] arr) {
        int n=arr.length;
        int[][] dp=new int[n][2];
        long ans=0l;
        if(arr[0]%2!=0) {
            dp[0][0]=1;
            ans++;
        }
        else dp[0][1]=1;

        for(int i=1;i<n;i++){
            if(arr[i]%2==0){
                dp[i][0]=dp[i-1][0];
                dp[i][1]=dp[i-1][1]+1;
            }else {
                dp[i][0]=dp[i-1][1]+1;
                dp[i][1]=dp[i-1][0];
            }
            ans+=dp[i][0];
            ans%=(int)1e9+7;
        }

        return (int) ans;
    }
}
```

### [1525. 字符串的好分割数目](https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/)

> 给你一个字符串 s ，一个分割被称为 「好分割」 当它满足：将 s 分割成 2 个字符串 p 和 q ，它们连接起来等于 s 且 p 和 q 中不同字符的数目相同。
>
> 请你返回 s 中好分割的数目。
>
>  
>
> 示例 1：
>
> 输入：s = "aacaba"
> 输出：2
> 解释：总共有 5 种分割字符串 "aacaba" 的方法，其中 2 种是好分割。
> ("a", "acaba") 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。
> ("aa", "caba") 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。
> ("aac", "aba") 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。
> ("aaca", "ba") 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。
> ("aacab", "a") 左边字符串和右边字符串分别包含 3 个和 1 个不同的字符。
> 示例 2：
>
> 输入：s = "abcd"
> 输出：1
> 解释：好分割为将字符串分割成 ("ab", "cd") 。
> 示例 3：
>
> 输入：s = "aaaaa"
> 输出：4
> 解释：所有分割都是好分割。
> 示例 4：
>
> 输入：s = "acbadbaada"
> 输出：2
>
>
> 提示：
>
> s 只包含小写英文字母。
> 1 <= s.length <= 10^5
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/number-of-good-ways-to-split-a-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int numSplits(String s) {
        int n = s.length();
        int[] l = new int[n], r = new int[n];
        HashSet<Character> hashSet = new HashSet<>();
        for (int i = 0; i < n; i++) {
            hashSet.add(s.charAt(i));
            l[i] = hashSet.size();
        }
        hashSet = new HashSet<>();
        for (int i = n-1; i >= 0; i--) {
            hashSet.add(s.charAt(i));
            r[i] = hashSet.size();
        }
        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            if (l[i] == r[i + 1]) ans++;
        }

        return ans;
    }
}
```

## 第 241 场周赛

### \1863. 找出所有子集的异或总和再求和

> 一个数组的 **异或总和** 定义为数组中所有元素按位 `XOR` 的结果；如果数组为 **空** ，则异或总和为 `0` 。
>
> - 例如，数组 `[2,5,6]` 的 **异或总和** 为 `2 XOR 5 XOR 6 = 1` 。
>
> 给你一个数组 `nums` ，请你求出 `nums` 中每个 **子集** 的 **异或总和** ，计算并返回这些值相加之 **和** 。
>
> **注意：**在本题中，元素 **相同** 的不同子集应 **多次** 计数。
>
> 数组 `a` 是数组 `b` 的一个 **子集** 的前提条件是：从 `b` 删除几个（也可能不删除）元素能够得到 `a` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,3]
> 输出：6
> 解释：[1,3] 共有 4 个子集：
> - 空子集的异或总和是 0 。
> - [1] 的异或总和为 1 。
> - [3] 的异或总和为 3 。
> - [1,3] 的异或总和为 1 XOR 3 = 2 。
> 0 + 1 + 3 + 2 = 6
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [5,1,6]
> 输出：28
> 解释：[5,1,6] 共有 8 个子集：
> - 空子集的异或总和是 0 。
> - [5] 的异或总和为 5 。
> - [1] 的异或总和为 1 。
> - [6] 的异或总和为 6 。
> - [5,1] 的异或总和为 5 XOR 1 = 4 。
> - [5,6] 的异或总和为 5 XOR 6 = 3 。
> - [1,6] 的异或总和为 1 XOR 6 = 7 。
> - [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。
> 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [3,4,5,6,7,8]
> 输出：480
> 解释：每个子集的全部异或总和值之和为 480 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 12`
> - ```1 <= nums[i] <= 20`

```java
class Solution {
    int ans=0;
    public int subsetXORSum(int[] nums) {
        if(nums.length==1) return nums[0];
        dfs(nums,0,0);
        return ans;
    }

    public void dfs(int[] nums,int i,int xor_sum){
        if(i==nums.length){
            ans+=xor_sum;
            return;
        }
        dfs(nums,i+1,xor_sum^nums[i]);
        dfs(nums,i+1,xor_sum);
    }
}
```

### \1864. 构成交替字符串需要的最小交换次数

> 给你一个二进制字符串 `s` ，现需要将其转化为一个 **交替字符串** 。请你计算并返回转化所需的 **最小** 字符交换次数，如果无法完成转化，返回 `-1` 。
>
> **交替字符串** 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 `"010"` 和 `"1010"` 属于交替字符串，但 `"0100"` 不是。
>
> 任意两个字符都可以进行交换，**不必相邻** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "111000"
> 输出：1
> 解释：交换位置 1 和 4："111000" -> "101010" ，字符串变为交替字符串。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "010"
> 输出：0
> 解释：字符串已经是交替字符串了，不需要交换。
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "1110"
> 输出：-1
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s[i]` 的值为 `'0'` 或 `'1'`

```java
class Solution {
    public int minSwaps(String s) {
        int count = 0;
        for (char c : s.toCharArray()) {
            if (c == '1') count++;
            else count--;
        }
        if (Math.abs(count) > 1) return -1;
        if (count == 0) {
            int count1 = 0;
            int count2 = 0;
            for (int i = 0; i < s.length(); i++) {
                if (i % 2 == 0 && s.charAt(i) == '0') {
                    count1++;
                }
            }
            for (int i = 0; i < s.length(); i++) {
                if (i % 2 == 1 && s.charAt(i) == '0') {
                    count2++;
                }
            }

            return Math.min(count1, count2);
        }
        if (count == 1){
            int count1=0;
            for(int i=0;i<s.length();i++){
                if(i%2==0&&s.charAt(i)=='0'){
                    count1++;
                }
            }

            return count1;
        }

        int count1=0;
        for(int i=0;i<s.length();i++){
            if(i%2==0&&s.charAt(i)=='1'){
                count1++;
            }
        }
        
        return count1;

    }
}
```

### \1865. 找出和为指定值的下标对

> 给你两个整数数组 `nums1` 和 `nums2` ，请你实现一个支持下述两类查询的数据结构：
>
> 1. **累加** ，将一个正整数加到 `nums2` 中指定下标对应元素上。
> 2. **计数** ，统计满足 `nums1[i] + nums2[j]` 等于指定值的下标对 `(i, j)` 数目（`0 <= i < nums1.length` 且 `0 <= j < nums2.length`）。
>
> 实现 `FindSumPairs` 类：
>
> - `FindSumPairs(int[] nums1, int[] nums2)` 使用整数数组 `nums1` 和 `nums2` 初始化 `FindSumPairs` 对象。
> - `void add(int index, int val)` 将 `val` 加到 `nums2[index]` 上，即，执行 `nums2[index] += val` 。
> - `int count(int tot)` 返回满足 `nums1[i] + nums2[j] == tot` 的下标对 `(i, j)` 数目。
>
>  
>
> **示例：**
>
> ```
> 输入：
> ["FindSumPairs", "count", "add", "count", "count", "add", "add", "count"]
> [[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]
> 输出：
> [null, 8, null, 2, 1, null, null, 11]
> 
> 解释：
> FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);
> findSumPairs.count(7);  // 返回 8 ; 下标对 (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) 满足 2 + 5 = 7 ，下标对 (5,1), (5,5) 满足 3 + 4 = 7
> findSumPairs.add(3, 2); // 此时 nums2 = [1,4,5,4,5,4]
> findSumPairs.count(8);  // 返回 2 ；下标对 (5,2), (5,4) 满足 3 + 5 = 8
> findSumPairs.count(4);  // 返回 1 ；下标对 (5,0) 满足 3 + 1 = 4
> findSumPairs.add(0, 1); // 此时 nums2 = [2,4,5,4,5,4]
> findSumPairs.add(1, 1); // 此时 nums2 = [2,5,5,4,5,4]
> findSumPairs.count(7);  // 返回 11 ；下标对 (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) 满足 2 + 5 = 7 ，下标对 (5,3), (5,5) 满足 3 + 4 = 7
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums1.length <= 1000`
> - `1 <= nums2.length <= 105`
> - `1 <= nums1[i] <= 109`
> - `1 <= nums2[i] <= 105`
> - `0 <= index < nums2.length`
> - `1 <= val <= 105`
> - `1 <= tot <= 109`
> - 最多调用 `add` 和 `count` 函数各 `1000` 次

```java
class FindSumPairs {
    int[] nums1, nums2;
    HashMap<Integer,Integer> hashMap;

    public FindSumPairs(int[] nums1, int[] nums2) {
        this.nums1 = nums1;
        this.nums2 = nums2;
        hashMap=new HashMap<>();
        for(int i=0;i<nums2.length;i++)
            hashMap.put(nums2[i],hashMap.getOrDefault(nums2[i],0)+1);
    }

    public void add(int index, int val) {
        hashMap.put(nums2[index],hashMap.get(nums2[index])-1);
        nums2[index] += val;
        hashMap.put(nums2[index],hashMap.getOrDefault(nums2[index],0)+1);
    }

    public int count(int tot) {
        int n = nums1.length, m = nums2.length;
        int ans = 0;
        for(int i:nums1){
            int num=tot-i;
            ans+=hashMap.getOrDefault(num,0);
        }

        return ans;
    }
}
```

## 第 85 场双周赛

### \6156. 得到 K 个黑块的最少涂色次数

> 给你一个长度为 `n` 下标从 **0** 开始的字符串 `blocks` ，`blocks[i]` 要么是 `'W'` 要么是 `'B'` ，表示第 `i` 块的颜色。字符 `'W'` 和 `'B'` 分别表示白色和黑色。
>
> 给你一个整数 `k` ，表示想要 **连续** 黑色块的数目。
>
> 每一次操作中，你可以选择一个白色块将它 **涂成** 黑色块。
>
> 请你返回至少出现 **一次** 连续 `k` 个黑色块的 **最少** 操作次数。
>
>  
>
> **示例 1：**
>
> ```
> 输入：blocks = "WBBWWBBWBW", k = 7
> 输出：3
> 解释：
> 一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。
> 得到 blocks = "BBBBBBBWBW" 。
> 可以证明无法用少于 3 次操作得到 7 个连续的黑块。
> 所以我们返回 3 。
> ```
>
> **示例 2：**
>
> ```
> 输入：blocks = "WBWBBBW", k = 2
> 输出：0
> 解释：
> 不需要任何操作，因为已经有 2 个连续的黑块。
> 所以我们返回 0 。
> ```
>
>  
>
> **提示：**
>
> - `n == blocks.length`
> - `1 <= n <= 100`
> - `blocks[i]` 要么是 `'W'` ，要么是 `'B'` 。
> - `1 <= k <= n`

```java
class Solution {
    public int minimumRecolors(String blocks, int k) {
        int ans = Integer.MAX_VALUE, n = blocks.length();
        for (int i = 0; i < n; i++) {
            int temp = 0;
            if(i+k>n) break;
            for (int j = 0; i+k<=n&&j<k; j++) {
                if (blocks.charAt(i + j) == 'W') temp++;
            }
            //System.out.println(temp);
            ans = Math.min(ans, temp);
        }

        return ans;
    }
}
```

### 6157. 二进制字符串重新安排顺序需要的时间

> 给你一个二进制字符串 `s` 。在一秒之中，**所有** 子字符串 `"01"` **同时** 被替换成 `"10"` 。这个过程持续进行到没有 `"01"` 存在。
>
> 请你返回完成这个过程所需要的秒数。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "0110101"
> 输出：4
> 解释：
> 一秒后，s 变成 "1011010" 。
> 再过 1 秒后，s 变成 "1101100" 。
> 第三秒过后，s 变成 "1110100" 。
> 第四秒后，s 变成 "1111000" 。
> 此时没有 "01" 存在，整个过程花费 4 秒。
> 所以我们返回 4 。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "11100"
> 输出：0
> 解释：
> s 中没有 "01" 存在，整个过程花费 0 秒。
> 所以我们返回 0 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s[i]` 要么是 `'0'` ，要么是 `'1'` 。

```java
class Solution {
    public int secondsToRemoveOccurrences(String s) {
        int ans=0;
        if(s.length()==1) return ans;
        while (s.contains("01")){
            s=s.replace("01","10");
            //System.out.println(s);
            ans++;
        }

        return ans;
    }
}
```

### \6158. 字母移位 II

> ### 6158. 字母移位 II
>
>  显示英文描述
>
>  
>
> [我的提交](https://leetcode.cn/contest/biweekly-contest-85/problems/shifting-letters-ii/submissions/)[返回竞赛](https://leetcode.cn/contest/biweekly-contest-85/)
>
> - **通过的用户数**1586
> - **尝试过的用户数**2576
> - **用户总通过次数**1665
> - **用户总提交次数**6553
> - **题目难度****Medium**
>
> 给你一个小写英文字母组成的字符串 `s` 和一个二维整数数组 `shifts` ，其中 `shifts[i] = [starti, endi, directioni]` 。对于每个 `i` ，将 `s` 中从下标 `starti` 到下标 `endi` （两者都包含）所有字符都进行移位运算，如果 `directioni = 1` 将字符向后移位，如果 `directioni = 0` 将字符向前移位。
>
> 将一个字符 **向后** 移位的意思是将这个字符用字母表中 **下一个** 字母替换（字母表视为环绕的，所以 `'z'` 变成 `'a'`）。类似的，将一个字符 **向前** 移位的意思是将这个字符用字母表中 **前一个** 字母替换（字母表是环绕的，所以 `'a'` 变成 `'z'` ）。
>
> 请你返回对 `s` 进行所有移位操作以后得到的最终字符串。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "abc", shifts = [[0,1,0],[1,2,1],[0,2,1]]
> 输出："ace"
> 解释：首先，将下标从 0 到 1 的字母向前移位，得到 s = "zac" 。
> 然后，将下标从 1 到 2 的字母向后移位，得到 s = "zbd" 。
> 最后，将下标从 0 到 2 的字符向后移位，得到 s = "ace" 。
> ```
>
> **示例 2:**
>
> ```
> 输入：s = "dztz", shifts = [[0,0,0],[1,1,1]]
> 输出："catz"
> 解释：首先，将下标从 0 到 0 的字母向前移位，得到 s = "cztz" 。
> 最后，将下标从 1 到 1 的字符向后移位，得到 s = "catz" 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length, shifts.length <= 5 * 104`
> - `shifts[i].length == 3`
> - `0 <= starti <= endi < s.length`
> - `0 <= directioni <= 1`
> - `s` 只包含小写英文字母。

```java
class Solution {
    int[] sub_arr;

    public String shiftingLetters(String s, int[][] shifts) {
        int n = s.length();
        int[] chang_num=new int[n];
        sub_arr = new int[n+1];

        //求出当前元素的值
        int temp=-1;
        for(char c:s.toCharArray()) chang_num[++temp]=c-'a';

        //计算差分数组
        sub_arr[0]=chang_num[0];
        for(int i=1;i<n;i++){
            sub_arr[i]=chang_num[i]-chang_num[i-1];
        }

        //区间增减
        for (int[] i : shifts) {
            int start = i[0], end = i[1], num = i[2];
            if (num == 0) {
                int val = -1;
                insert(start, end, val);
            } else {
                int val = 1;
                insert(start, end, val);
            }
        }

        //前缀和
        int[] arr = new int[n];
        arr[0]=(sub_arr[0]%26+26)%26;

        for (int i = 1; i < n; i++) {
            arr[i] = ((sub_arr[i] + arr[i-1])%26 + 26) % 26;
        }

        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < n; i++) {
            stringBuilder.append((char) (arr[i] + 'a'));
        }

        return stringBuilder.toString();
    }

    public void insert(int l, int r, int num) {
        sub_arr[l] +=num;
        sub_arr[r + 1] -= num;
    }
}
```

1. 差分
2. 差分数组不需要从1开始，元素长度为n
3. 但是需要`sub_arr[r + 1] -= num;`因此需要数组长度+1
4. 在求前缀和时，由于是从1开始得，因此前缀和首个元素要与差分数组第一个元素值相等

## 第 307 场周赛

### [6152. 赢得比赛需要的最少训练时长](https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/)

> 你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。
>
> 另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。
>
> 你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。
>
> 击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少  energy[i] 。
>
> 在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。
>
> 返回击败全部 n 个对手需要训练的 最少 小时数目。
>
>  
>
> 示例 1：
>
> 输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]
> 输出：8
> 解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。
> 按以下顺序与对手比赛：
> - 你的精力与经验都超过第 0 个对手，所以获胜。
>   精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。
> - 你的精力与经验都超过第 1 个对手，所以获胜。
>   精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。
> - 你的精力与经验都超过第 2 个对手，所以获胜。
>   精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。
> - 你的精力与经验都超过第 3 个对手，所以获胜。
>   精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。
>   在比赛前进行了 8 小时训练，所以返回 8 。
>   可以证明不存在更小的答案。
>   示例 2：
>
> 输入：initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]
> 输出：0
> 解释：你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。
>
>
> 提示：
>
> n == energy.length == experience.length
> 1 <= n <= 100
> 1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {
        int n=energy.length;
        int ans=0;
        int sum=0;
        for(int i:energy) sum+=i;
        if(sum==initialEnergy){
            ans=1;
            initialEnergy++;
        }else if(sum>initialEnergy){
            ans=sum-initialEnergy+1;
            initialEnergy=sum+1;
        } else if(sum<initialEnergy){
            ans=0;
        }
        //System.out.println(initialExperience);
        for(int i=0;i<n;i++){
            if(initialExperience>experience[i]){
                initialExperience+=experience[i];
            }else {
                ans+=experience[i]-initialExperience+1;
                initialExperience=experience[i]+1;
                //System.out.println(initialExperience);
                initialExperience+=experience[i];
            }
        }

        return ans;
    }
}
```

### [6166. 最大回文数字](https://leetcode.cn/problems/largest-palindromic-number/)

> 给你一个仅由数字（0 - 9）组成的字符串 num 。
>
> 请你找出能够使用 num 中数字形成的 最大回文 整数，并以字符串形式返回。该整数不含 前导零 。
>
> 注意：
>
> 你 无需 使用 num 中的所有数字，但你必须使用 至少 一个数字。
> 数字可以重新排序。
>
>
> 示例 1：
>
> 输入：num = "444947137"
> 输出："7449447"
> 解释：
> 从 "444947137" 中选用数字 "4449477"，可以形成回文整数 "7449447" 。
> 可以证明 "7449447" 是能够形成的最大回文整数。
> 示例 2：
>
> 输入：num = "00009"
> 输出："9"
> 解释：
> 可以证明 "9" 能够形成的最大回文整数。
> 注意返回的整数不应含前导零。
>
>
> 提示：
>
> 1 <= num.length <= 105
> num 由数字（0 - 9）组成
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/largest-palindromic-number
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public String largestPalindromic(String num) {
        TreeMap<Integer,Integer> hashMap=new TreeMap<>(((o1, o2) -> o2-o1));
        for(char c:num.toCharArray()){
            int temp=c-'0';
            hashMap.put(temp,hashMap.getOrDefault(temp,0)+1);
        }

        int j_num=-1;
        for(Map.Entry<Integer,Integer> entry:hashMap.entrySet()){
            if(entry.getValue()%2==1) {
                j_num=entry.getKey();
                break;
            }
        }

        if(j_num==-1){
            StringBuilder ans=get_str(hashMap);
            StringBuilder temp=new StringBuilder(ans);
            String temp1=ans.reverse().toString();

            temp.append(temp1);
            int[] index=get(temp);
            if(index[0]>index[1]) return "0";
            return temp.substring(index[0],index[1]).toString();
        }else{
            StringBuilder ans=get_str(hashMap);
            StringBuilder temp=new StringBuilder(ans);
            temp.append(j_num);
            String temp1=ans.reverse().toString();

            temp.append(temp1);
            int[] index=get(temp);
            if(index[0]>index[1]) return "0";
            return temp.substring(index[0],index[1]).toString();
        }
    }

    public int[] get(StringBuilder str){
        int n=str.length();
        int[] ans=new int[]{n,0};
        int l=0,r=n-1;
        while (l<n){
            if(str.charAt(l)!='0') {
                ans[0]=l;
                break;
            }
            l++;
        }
        while (r>=0){
            if(str.charAt(r)!='0'){
                ans[1]=r+1;
                break;
            }
            r--;
        }

        return ans;
    }
    public StringBuilder get_str(TreeMap<Integer,Integer> hashMap){
        StringBuilder ans=new StringBuilder();
        for(Map.Entry<Integer,Integer> entry:hashMap.entrySet()){
            for(int i=0;i<entry.getValue()/2;i++){
                ans.append(entry.getKey());
            }
        }
        
        return ans;
    }
}
```

### [6154. 感染二叉树需要的总时间](https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/)

> 给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。
>
> 每分钟，如果节点满足以下全部条件，就会被感染：
>
> 节点此前还没有感染。
> 节点与一个已感染节点相邻。
> 返回感染整棵树需要的分钟数。
>
>  <img src="https://cdn.jsdelivr.net/gh/yzk656/image/202212241923963.png" alt="img" style="zoom:25%;" />
>
> 示例 1：
>
>
> 输入：root = [1,5,3,null,4,10,6,9,2], start = 3
> 输出：4
> 解释：节点按以下过程被感染：
> - 第 0 分钟：节点 3
> - 第 1 分钟：节点 1、10、6
> - 第 2 分钟：节点5
> - 第 3 分钟：节点 4
> - 第 4 分钟：节点 9 和 2
> 感染整棵树需要 4 分钟，所以返回 4 。
> 示例 2：
>
>
> 输入：root = [1], start = 1
> 输出：0
> 解释：第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。
>
>
> 提示：
>
> 树中节点的数目在范围 [1, 105] 内
> 1 <= Node.val <= 105
> 每个节点的值 互不相同
> 树中必定存在值为 start 的节点
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int amountOfTime(TreeNode root, int start) {
        HashMap<Integer,List<Integer>> graph=new HashMap<>();
        Deque<TreeNode> deque=new LinkedList<>();
        deque.offer(root);

        while (!deque.isEmpty()){
            int size=deque.size();
             for(int i=0;i<size;i++){
                 TreeNode cur=deque.poll();
                 if(cur.left!=null){
                     graph.computeIfAbsent(cur.val,key->new ArrayList<>()).add(cur.left.val);
                     graph.computeIfAbsent(cur.left.val,key->new ArrayList<>()).add(cur.val);
                     deque.offer(cur.left);
                 }
                 if(cur.right!=null){
                     graph.computeIfAbsent(cur.val,key->new ArrayList<>()).add(cur.right.val);
                     graph.computeIfAbsent(cur.right.val,key->new ArrayList<>()).add(cur.val);
                     deque.offer(cur.right);
                 }
             }
        }

        Deque<int[]> deque1=new LinkedList<>();
        Set<Integer> visit=new HashSet<>();
        deque1.offer(new int[]{start,0});
        visit.add(start);
        int depth=0;
        while (!deque1.isEmpty()){
            int[] cur=deque1.poll();
            for(int i:graph.getOrDefault(cur[0],new ArrayList<>())){
                if(!visit.contains(i)){
                    deque1.offer(new int[]{i,cur[1]+1});
                    visit.add(i);
                    depth=Math.max(depth,cur[1]+1);
                }
            }
        }
        
        return depth;
    }
}
```

## 第 18 场双周赛

### [1331. 数组序号转换](https://leetcode.cn/problems/rank-transform-of-an-array/)

> 给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。
>
> 序号代表了一个元素有多大。序号编号的规则如下：
>
> 序号从 1 开始编号。
> 一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。
> 每个数字的序号都应该尽可能地小。
>
>
> 示例 1：
>
> 输入：arr = [40,10,20,30]
> 输出：[4,1,2,3]
> 解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。
> 示例 2：
>
> 输入：arr = [100,100,100]
> 输出：[1,1,1]
> 解释：所有元素有相同的序号。
> 示例 3：
>
> 输入：arr = [37,12,28,9,100,56,80,5,12]
> 输出：[5,3,4,2,8,6,7,1,3]
>
>
> 提示：
>
> 0 <= arr.length <= 105
> -109 <= arr[i] <= 109
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/rank-transform-of-an-array
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int[] arrayRankTransform(int[] arr) {
        int[] a=new int[arr.length];
        System.arraycopy(arr,0,a,0,arr.length);
        Arrays.sort(a);
        HashMap<Integer,Integer> hashMap=new HashMap<>();
        int[] ans=new int[arr.length];
        for(int i:a){
            if(!hashMap.containsKey(i)){
                hashMap.put(i,hashMap.size()+1);
            }
        }
        for(int i=0;i<a.length;i++){
            ans[i]=hashMap.get(arr[i]);
        }
        
        return ans;
    }
}
```

1. 数组拷贝是System.arrayCopy

### [1328. 破坏回文串](https://leetcode.cn/problems/break-a-palindrome/)

> 给你一个由小写英文字母组成的回文字符串 palindrome ，请你将其中 一个 字符用任意小写英文字母替换，使得结果字符串的 字典序最小 ，且 不是 回文串。
>
> 请你返回结果字符串。如果无法做到，则返回一个 空串 。
>
> 如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符严格小于 b 中的对应字符。例如，"abcc” 字典序比 "abcd" 小，因为不同的第一个位置是在第四个字符，显然 'c' 比 'd' 小。
>
>
> 示例 1：
>
> 输入：palindrome = "abccba"
> 输出："aaccba"
> 解释：存在多种方法可以使 "abccba" 不是回文，例如 "zbccba", "aaccba", 和 "abacba" 。
> 在所有方法中，"aaccba" 的字典序最小。
> 示例 2：
>
> 输入：palindrome = "a"
> 输出：""
> 解释：不存在替换一个字符使 "a" 变成非回文的方法，所以返回空字符串。
>
>
> 提示：
>
> 1 <= palindrome.length <= 1000
> palindrome 只包含小写英文字母
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/break-a-palindrome
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public String breakPalindrome(String palindrome) {
        int n=palindrome.length();
        if(n==1) return "";
        
        int half_num=n/2;
        char[] chars=palindrome.toCharArray();
        for(int i=0;i<half_num;i++){
            if(chars[i]!='a'){
                chars[i]='a';
                return new String(chars);
            }
        }
        chars[n-1]='b';
        return new String(chars);
    }
}
```

1. String具有contains函数，可以查找某个子串

### [1329. 将矩阵按对角线排序](https://leetcode.cn/problems/sort-the-matrix-diagonally/)

> 矩阵对角线 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵 mat 有 6 行 3 列，从 mat[2][0] 开始的 矩阵对角线 将会经过 mat[2][0]、mat[3][1] 和 mat[4][2] 。
>
> 给你一个 m * n 的整数矩阵 mat ，请你将同一条 矩阵对角线 上的元素按升序排序后，返回排好序的矩阵。
>
>  
>
> 示例 1：
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241923137.png)
>
> 输入：mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
> 输出：[[1,1,1,1],[1,2,2,2],[1,2,3,3]]
> 示例 2：
>
> 输入：mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
> 输出：[[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]
>
>
> 提示：
>
> m == mat.length
> n == mat[i].length
> 1 <= m, n <= 100
> 1 <= mat[i][j] <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/sort-the-matrix-diagonally
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int[][] diagonalSort(int[][] mat) {
        int n = mat.length, m = mat[0].length;//确定行、列数

        for (int b = -(n - 1); b <= m - 1; b++) {//确定截距
            List<Integer> list = new ArrayList<>();//存储对角线上的元素
            for (int x = 0, y = b; x < n && y < m; x++, y++) {
                if (y >= 0)//x和y的上升频率一样，表明是按照k为1上升的，如果y大于0，表明走到了矩阵内
                    list.add(mat[x][y]);
            }
            Collections.sort(list);//排序
            for (int x = 0, y = b, k = 0; x < n && y < m; x++, y++) {
                if (y >= 0)
                    mat[x][y] = list.get(k++);//填充排序后的数字
            }
        }

        return mat;
    }
}
```

1. ​	![image-20220823100204717](https://cdn.jsdelivr.net/gh/yzk656/image/202212241923138.png)

## 第 278 场周赛

### [2156. 查找给定哈希值的子串](https://leetcode.cn/problems/find-substring-with-given-hash-value/)

> 给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算：
>
> hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.
> 其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val('a') = 1 到 val('z') = 26 。
>
> 给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 k 的 子串 sub ，满足 hash(sub, power, modulo) == hashValue 。
>
> 测试数据保证一定 存在 至少一个这样的子串。
>
> 子串 定义为一个字符串中连续非空字符组成的序列。
>
>  
>
> 示例 1：
>
> 输入：s = "leetcode", power = 7, modulo = 20, k = 2, hashValue = 0
> 输出："ee"
> 解释："ee" 的哈希值为 hash("ee", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。
> "ee" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 "ee" 。
> 示例 2：
>
> 输入：s = "fbxzaad", power = 31, modulo = 100, k = 3, hashValue = 32
> 输出："fbx"
> 解释："fbx" 的哈希值为 hash("fbx", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32 。
> "bxz" 的哈希值为 hash("bxz", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32 。
> "fbx" 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 "fbx" 。
> 注意，"bxz" 的哈希值也为 32 ，但是它在字符串中比 "fbx" 更晚出现。
>
>
> 提示：
>
> 1 <= k <= s.length <= 2 * 104
> 1 <= power, modulo <= 109
> 0 <= hashValue < modulo
> s 只包含小写英文字母。
> 测试数据保证一定 存在 满足条件的子串。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/find-substring-with-given-hash-value
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {
        int n = s.length();
        long[] pow = new long[k];

        pow[0] = 1;
        for (int i = 1; i < k; i++)
            pow[i] = pow[i - 1] * power % modulo;

        for (int i = 0; i <= n - k; i++) {
            long hash_num = 0;
            for (int j = i; j < i + k; j++) {
                int val = s.charAt(j) - 'a' + 1;
                hash_num += val*pow[j-i];
                hash_num %= modulo;
            }
            if ((int) (hash_num % modulo) == hashValue) {
                StringBuilder stringBuilder = new StringBuilder(s);
                return stringBuilder.substring(i, i + k).toString();
            }
        }

        return "";
    }
}
```

## 第 214 场周赛

### \1646. 获取生成数组中的最大值、

> 给你一个整数 `n` 。按下述规则生成一个长度为 `n + 1` 的数组 `nums` ：
>
> - `nums[0] = 0`
> - `nums[1] = 1`
> - 当 `2 <= 2 * i <= n` 时，`nums[2 * i] = nums[i]`
> - 当 `2 <= 2 * i + 1 <= n` 时，`nums[2 * i + 1] = nums[i] + nums[i + 1]`
>
> 返回生成数组 `nums` 中的 **最大** 值。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 7
> 输出：3
> 解释：根据规则：
>   nums[0] = 0
>   nums[1] = 1
>   nums[(1 * 2) = 2] = nums[1] = 1
>   nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
>   nums[(2 * 2) = 4] = nums[2] = 1
>   nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
>   nums[(3 * 2) = 6] = nums[3] = 2
>   nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
> 因此，nums = [0,1,1,2,1,3,2,3]，最大值 3
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 2
> 输出：1
> 解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 3
> 输出：2
> 解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2
> ```
>
>  
>
> **提示：**
>
> - `0 <= n <= 100`

```java
class Solution {
    public int getMaximumGenerated(int n) {
        if(n==0) return 0;
        if(n==2||n==1) return 1;
        int[] ans=new int[n+1];
        ans[0]=0;ans[1]=1;

        int ans_temp=0;
        for(int i=1;;i++){
            if(i*2<=n) {
                ans[i*2]=ans[i];
                ans_temp=Math.max(ans_temp,ans[i]);
            }else break;
            if(i*2+1<=n){
                ans[i*2+1]=ans[i]+ans[i+1];
                ans_temp=Math.max(ans_temp,ans[i*2+1]);
            }else break;
        }

        return ans_temp;
    }
}
```

### \1647. 字符频次唯一的最小删除次数

> 如果字符串 `s` 中 **不存在** 两个不同字符 **频次** 相同的情况，就称 `s` 是 **优质字符串** 。
>
> 给你一个字符串 `s`，返回使 `s` 成为 **优质字符串** 需要删除的 **最小** 字符数。
>
> 字符串中字符的 **频次** 是该字符在字符串中的出现次数。例如，在字符串 `"aab"` 中，`'a'` 的频次是 `2`，而 `'b'` 的频次是 `1` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "aab"
> 输出：0
> 解释：s 已经是优质字符串。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "aaabbbcc"
> 输出：2
> 解释：可以删除两个 'b' , 得到优质字符串 "aaabcc" 。
> 另一种方式是删除一个 'b' 和一个 'c' ，得到优质字符串 "aaabbc" 。
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "ceabaacb"
> 输出：2
> 解释：可以删除两个 'c' 得到优质字符串 "eabaab" 。
> 注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。）
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 105`
> - `s` 仅含小写英文字母

```java
class Solution {
    public int minDeletions(String s) {
        int[] array=new int[26];
        int n=s.length();

        for(int i=0;i<n;i++)
            array[s.charAt(i)-'a']++;

        Set<Integer> set=new HashSet<>();
        int ans=0;
        outer:for(int i:array){
            if(i==0) continue;
            int cur=i;
            while (cur!=0&&!set.add(cur)){
                cur--;
                ans++;
            }
        }

        return ans;
    }
}
```

### \1648. 销售价值减少的颜色球

> 
>  显示英文描述
>
>  
>
> [我的提交](https://leetcode.cn/contest/weekly-contest-214/problems/sell-diminishing-valued-colored-balls/submissions/)[返回竞赛](https://leetcode.cn/contest/weekly-contest-214/)
>
> - **通过的用户数**467
> - **尝试过的用户数**1341
> - **用户总通过次数**485
> - **用户总提交次数**3138
> - **题目难度****Medium**
>
> 你有一些球的库存 `inventory` ，里面包含着不同颜色的球。一个顾客想要 **任意颜色** 总数为 `orders` 的球。
>
> 这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 **同色球** 的数目。比方说还剩下 `6` 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 `6` 。这笔交易以后，只剩下 `5` 个黄球了，所以下一个黄球的价值为 `5` （也就是球的价值随着顾客购买同色球是递减的）
>
> 给你整数数组 `inventory` ，其中 `inventory[i]` 表示第 `i` 种颜色球一开始的数目。同时给你整数 `orders` ，表示顾客总共想买的球数目。你可以按照 **任意顺序** 卖球。
>
> 请你返回卖了 `orders` 个球以后 **最大** 总价值之和。由于答案可能会很大，请你返回答案对 `109 + 7` **取余数** 的结果。
>
>  
>
> **示例 1：**
>
> ![img](https://cdn.jsdelivr.net/gh/yzk656/image/202212241922468.gif)
>
> ```
> 输入：inventory = [2,5], orders = 4
> 输出：14
> 解释：卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。
> 最大总和为 2 + 5 + 4 + 3 = 14 。
> ```
>
> **示例 2：**
>
> ```
> 输入：inventory = [3,5], orders = 6
> 输出：19
> 解释：卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。
> 最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19 。
> ```
>
> **示例 3：**
>
> ```
> 输入：inventory = [2,8,4,10,6], orders = 20
> 输出：110
> ```
>
> **示例 4：**
>
> ```
> 输入：inventory = [1000000000], orders = 1000000000
> 输出：21
> 解释：卖 1000000000 次第一种颜色的球，总价值为 500000000500000000 。 500000000500000000 对 109 + 7 取余为 21 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= inventory.length <= 105`
> - `1 <= inventory[i] <= 109`
> - `1 <= orders <= min(sum(inventory[i]), 109)`

```java
class Solution {
    public int maxProfit(int[] inventory, int orders) {
        int mod = (int) 1e9 + 7;
        int n = inventory.length;


        inventory=Arrays.stream(inventory).boxed().sorted((a,b)->b-a).mapToInt(p->p).toArray();
        System.out.println(inventory[0]);
        long cur = inventory[0];
        long ans = 0;
        int c = 0;
        while (orders != 0) {
            while (c < n && inventory[c] == cur) ++c;
            int next = c == n ? 0 : inventory[c];
            int count = (int) Math.min(orders, c * (cur - next));
            int t = (int) (cur - next);
            int r = 0;
            if (orders < c * (cur - next)) {
                t = orders / c;
                r = orders % c;
            }
            long next_p = cur - t;
            ans = (ans + (cur + next_p + 1) * t / 2 * c + next_p * r) % mod;
            orders -= count;
            cur = next_p;
        }

        return (int) ans;
    }
}
```

1. 数组逆序排序：`a=Arrays.stream(a),boxed().sorted((a,b)->b-a).mapToInt(p->p).toArray()`

## 第 147 场周赛

### [1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)

> 泰波那契序列 Tn 定义如下： 
>
> T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
>
> 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。
>
>  
>
> 示例 1：
>
> 输入：n = 4
> 输出：4
> 解释：
> T_3 = 0 + 1 + 1 = 2
> T_4 = 1 + 1 + 2 = 4
> 示例 2：
>
> 输入：n = 25
> 输出：1389537
>
>
> 提示：
>
> 0 <= n <= 37
> 答案保证是一个 32 位整数，即 answer <= 2^31 - 1
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/n-th-tribonacci-number
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int tribonacci(int n) {
        long t0=0,t1=1,t2=1;
        if(n==0) return 0;
        if(n==1) return 1;
        if(n==2) return 1;
        long ans=0;
        for(int i=3;i<=n;i++){
            ans=t2+t1+t0;
            t0=t1;
            t1=t2;
            t2=ans;
        }
        return (int) ans;
    }
}
```

###  [1138. 字母板上的路径](https://leetcode.cn/problems/alphabet-board-path/)

> 我们从一块字母板上的位置 (0, 0) 出发，该坐标对应的字符为 board[0][0]。
>
> 在本题里，字母板为board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"]，如下所示。
>
> 
>
> 我们可以按下面的指令规则行动：
>
> 如果方格存在，'U' 意味着将我们的位置上移一行；
> 如果方格存在，'D' 意味着将我们的位置下移一行；
> 如果方格存在，'L' 意味着将我们的位置左移一列；
> 如果方格存在，'R' 意味着将我们的位置右移一列；
> '!' 会把在我们当前位置 (r, c) 的字符 board[r][c] 添加到答案中。
> （注意，字母板上只存在有字母的位置。）
>
> 返回指令序列，用最小的行动次数让答案和目标 target 相同。你可以返回任何达成目标的路径。
>
>  
>
> 示例 1：
>
> 输入：target = "leet"
> 输出："DDR!UURRR!!DDD!"
> 示例 2：
>
> 输入：target = "code"
> 输出："RR!DDRR!UUL!R!"
>
>
> 提示：
>
> 1 <= target.length <= 100
> target 仅含有小写英文字母。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/alphabet-board-path
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public String alphabetBoardPath(String target) {
        String ans="";
        int s_x=0,s_y=0;
        for(char c:target.toCharArray()){
            int x=(c-'a')/5;
            int y=(c-'a')%5;
            if(y<s_y){
                for(int i=0;i<s_y-y;i++)
                    ans+='L';
            }
            if(x>s_x){
                for(int i=0;i<x-s_x;i++)
                    ans+='D';
            }
            if(x<s_x){
                for(int i=0;i<s_x-x;i++)
                    ans+='U';
            }
            if(y>s_y){
                for(int i=0;i<y-s_y;i++)
                    ans+='R';
            }
            ans+='!';
            s_x=x;s_y=y;
        }

        return ans;
    }
}
```

1. 如果前往Z，就要先往左，再往下
2. 如果从Z出来，就要先向上再往右

## 第 308 场周赛

### [6161. 从字符串中移除星号](https://leetcode.cn/problems/removing-stars-from-a-string/)

> 给你一个包含若干星号 * 的字符串 s 。
>
> 在一步操作中，你可以：
>
> 选中 s 中的一个星号。
> 移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。
> 返回移除 所有 星号之后的字符串。
>
> 注意：
>
> 生成的输入保证总是可以执行题面中描述的操作。
> 可以证明结果字符串是唯一的。
>
>
> 示例 1：
>
> 输入：s = "leet**cod*e"
> 输出："lecoe"
> 解释：从左到右执行移除操作：
> - 距离第 1 个星号最近的字符是 "leet**cod*e" 中的 't' ，s 变为 "lee*cod*e" 。
> - 距离第 2 个星号最近的字符是 "lee*cod*e" 中的 'e' ，s 变为 "lecod*e" 。
> - 距离第 3 个星号最近的字符是 "lecod*e" 中的 'd' ，s 变为 "lecoe" 。
> 不存在其他星号，返回 "lecoe" 。
> 示例 2：
>
> 输入：s = "erase*****"
> 输出：""
> 解释：整个字符串都会被移除，所以返回空字符串。
>
>
> 提示：
>
> 1 <= s.length <= 105
> s 由小写英文字母和星号 * 组成
> s 可以执行上述操作
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/removing-stars-from-a-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public String removeStars(String s) {
        Deque<Character> deque=new LinkedList<>();
        for(char c:s.toCharArray()){
            if(c!='*'){
                deque.push(c);
            }else{
                deque.pop();
            }
        }
        String ans="";
        while (!deque.isEmpty()){
            ans+=String.valueOf(deque.poll());
        }

        return new StringBuilder(ans).reverse().toString();
    }
}
```

### [6162. 收集垃圾的最少总时间](https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/)

> 给你一个下标从 0 开始的字符串数组 garbage ，其中 garbage[i] 表示第 i 个房子的垃圾集合。garbage[i] 只包含字符 'M' ，'P' 和 'G' ，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 一 单位的任何一种垃圾都需要花费 1 分钟。
>
> 同时给你一个下标从 0 开始的整数数组 travel ，其中 travel[i] 是垃圾车从房子 i 行驶到房子 i + 1 需要的分钟数。
>
> 城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 0 出发，按顺序 到达每一栋房子。但它们 不是必须 到达所有的房子。
>
> 任何时刻只有 一辆 垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 不能 做任何事情。
>
> 请你返回收拾完所有垃圾需要花费的 最少 总分钟数。
>
>  
>
> 示例 1：
>
> 输入：garbage = ["G","P","GP","GG"], travel = [2,4,3]
> 输出：21
> 解释：
> 收拾纸的垃圾车：
> 1. 从房子 0 行驶到房子 1
> 2. 收拾房子 1 的纸垃圾
> 3. 从房子 1 行驶到房子 2
> 4. 收拾房子 2 的纸垃圾
> 收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。
> 收拾玻璃的垃圾车：
> 1. 收拾房子 0 的玻璃垃圾
> 2. 从房子 0 行驶到房子 1
> 3. 从房子 1 行驶到房子 2
> 4. 收拾房子 2 的玻璃垃圾
> 5. 从房子 2 行驶到房子 3
> 6. 收拾房子 3 的玻璃垃圾
> 收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。
> 由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。
> 所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。
> 示例 2：
>
> 输入：garbage = ["MMM","PGM","GP"], travel = [3,10]
> 输出：37
> 解释：
> 收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。
> 收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。
> 收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。
> 总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。
>
>
> 提示：
>
> 2 <= garbage.length <= 105
> garbage[i] 只包含字母 'M' ，'P' 和 'G' 。
> 1 <= garbage[i].length <= 10
> travel.length == garbage.length - 1
> 1 <= travel[i] <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    int ans,m,n;
    HashMap<Character,TreeSet<Integer>> hashMap;
    String[] garbage;
    int[] travel;
    public int garbageCollection(String[] garbage, int[] travel) {
        ans=0;m=garbage.length;n=travel.length;
        hashMap=new HashMap<>();
        this.garbage=garbage;
        this.travel=travel;
        for(int i=0;i<m;i++){
            if(garbage[i].contains("M")){
                hashMap.computeIfAbsent('M',key->new TreeSet<>()).add(i);
            }
            if(garbage[i].contains("P")){
                hashMap.computeIfAbsent('P',key->new TreeSet<>()).add(i);
            }
            if(garbage[i].contains("G")){
                hashMap.computeIfAbsent('G',key->new TreeSet<>()).add(i);
            }
        }
        find('M');find('P');find('G');

        return ans;
    }
    public void find(char temp_char){
        if(!hashMap.containsKey(temp_char)) return ;
        TreeSet<Integer> temp=hashMap.get(temp_char);
        for(int i=0;i<temp.first();i++) ans+=travel[i];
        while (!temp.isEmpty()){
            int start=temp.pollFirst();
            int num=0;
            for(char c:garbage[start].toCharArray()){
                if(c==temp_char) num++;
            }
            ans+=num;
            if(!temp.isEmpty()){
                int next=temp.first();
                while (start<next){
                    ans+=travel[start];
                    start++;
                }
            }else break;
        }
        
    }
}
```

前缀和

```java
class Solution {
    public int garbageCollection(String[] garbage, int[] travel) {
        int m=garbage.length,n=travel.length;
        int[] pre_sum=new int[n+1];
        for(int i=1;i<=n;i++){
            pre_sum[i]=pre_sum[i-1]+travel[i-1];
        }

        int ans=0,M=0,P=0,G=0;
        for(int i=0;i<m;i++){
            for(char c:garbage[i].toCharArray()){
                if(c=='M'){
                    ans+=pre_sum[i]-pre_sum[M]+1;
                    M=i;
                }
                if(c=='P'){
                    ans+=pre_sum[i]-pre_sum[P]+1;
                    P=i;
                }
                if(c=='G'){
                    ans+=pre_sum[i]-pre_sum[G]+1;
                    G=i;
                }
            }
        }

        return ans;
    }
}
```

## 第 104 场周赛

### [914. 卡牌分组](https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards/)

> 给定一副牌，每张牌上都写着一个整数。
>
> 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
>
> 每组都有 X 张牌。
> 组内所有的牌上都写着相同的整数。
> 仅当你可选的 X >= 2 时返回 true。
>
>  
>
> 示例 1：
>
> 输入：deck = [1,2,3,4,4,3,2,1]
> 输出：true
> 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
> 示例 2：
>
> 输入：deck = [1,1,1,2,2,2,3,3]
> 输出：false
> 解释：没有满足要求的分组。
>
> 提示：
>
> 1 <= deck.length <= 104
> 0 <= deck[i] < 104
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean hasGroupsSizeX(int[] deck) {
        HashMap<Integer,Integer> hashMap=new HashMap<>();
        int value=Integer.MAX_VALUE;
        for(int i:deck){
            hashMap.put(i,hashMap.getOrDefault(i,0)+1);
        }
        for(int key:hashMap.keySet()){
            value=Math.min(value,hashMap.get(key));
        }
        if(value<2) return false;
        outer:for(int i=2;i<=value;i++){
            for(int key:hashMap.keySet()){
                int num=hashMap.get(key);
                if(num%i!=0) continue outer;
            }
            return true;
        }
        return false;
    }
}
```

### [915. 分割数组](https://leetcode.cn/problems/partition-array-into-disjoint-intervals/)

> 给定一个数组 nums ，将其划分为两个连续子数组 left 和 right， 使得：
>
> left 中的每个元素都小于或等于 right 中的每个元素。
> left 和 right 都是非空的。
> left 的长度要尽可能小。
> 在完成这样的分组后返回 left 的 长度 。
>
> 用例可以保证存在这样的划分方法。
>
>  
>
> 示例 1：
>
> 输入：nums = [5,0,3,8,6]
> 输出：3
> 解释：left = [5,0,3]，right = [8,6]
> 示例 2：
>
> 输入：nums = [1,1,1,0,6,12]
> 输出：4
> 解释：left = [1,1,1,0]，right = [6,12]
>
>
> 提示：
>
> 2 <= nums.length <= 105
> 0 <= nums[i] <= 106
> 可以保证至少有一种方法能够按题目所描述的那样对 nums 进行划分。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/partition-array-into-disjoint-intervals
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int partitionDisjoint(int[] nums) {
        int n=nums.length;
        int[] left_max=new int[n],right_min=new int[n];
        int max=nums[0];
        left_max[0]=max;
        for(int i=1;i<n;i++){
            if(nums[i]>max){
                max=nums[i];
                left_max[i]=max;
            }else {
                left_max[i]=max;
            }
        }

        int min=nums[n-1];
        right_min[n-1]=min;

        for(int i=n-2;i>=0;i--){
            if(nums[i]<min){
                min=nums[i];
                right_min[i]=min;
            }else {
                right_min[i]=min;
            }
        }

        for(int i=1;i<n;i++){
            if(left_max[i-1]<=right_min[i]){
                return i;
            }
        }

        return -1;
    }
}
```

1. 开一个辅助数组

## 第 310 场周赛

### [6176. 出现最频繁的偶数元素](https://leetcode.cn/problems/most-frequent-even-element/)

> 给你一个整数数组 nums ，返回出现最频繁的偶数元素。
>
> 如果存在多个满足条件的元素，只需要返回 最小 的一个。如果不存在这样的元素，返回 -1 。
>
>  
>
> 示例 1：
>
> 输入：nums = [0,1,2,2,4,4,1]
> 输出：2
> 解释：
> 数组中的偶数元素为 0、2 和 4 ，在这些元素中，2 和 4 出现次数最多。
> 返回最小的那个，即返回 2 。
> 示例 2：
>
> 输入：nums = [4,4,4,9,2,4]
> 输出：4
> 解释：4 是出现最频繁的偶数元素。
> 示例 3：
>
> 输入：nums = [29,47,21,41,13,37,25,7]
> 输出：-1
> 解释：不存在偶数元素。
>
>
> 提示：
>
> 1 <= nums.length <= 2000
> 0 <= nums[i] <= 105
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/most-frequent-even-element
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int mostFrequentEven(int[] nums) {
        TreeMap<Integer,Integer> treeMap=new TreeMap<>();
        int n=nums.length;
        int max=0;
        for(int i:nums){
            if(i%2!=0) continue;
            treeMap.put(i,treeMap.getOrDefault(i,0)+1);
            max=Math.max(max,treeMap.get(i));
        }
        if(treeMap.size()==0) return -1;
        for(int i:treeMap.keySet()){
            if(treeMap.get(i)==max) return i;
        }
        return -1;
    }
}
```

### [6177. 子字符串的最优划分](https://leetcode.cn/problems/optimal-partition-of-string/)

> 给你一个字符串 s ，请你将该字符串划分成一个或多个 子字符串 ，并满足每个子字符串中的字符都是 唯一 的。也就是说，在单个子字符串中，字母的出现次数都不超过 一次 。
>
> 满足题目要求的情况下，返回 最少 需要划分多少个子字符串。
>
> 注意，划分后，原字符串中的每个字符都应该恰好属于一个子字符串。
>
>  
>
> 示例 1：
>
> 输入：s = "abacaba"
> 输出：4
> 解释：
> 两种可行的划分方法分别是 ("a","ba","cab","a") 和 ("ab","a","ca","ba") 。
> 可以证明最少需要划分 4 个子字符串。
> 示例 2：
>
> 输入：s = "ssssss"
> 输出：6
> 解释：
> 只存在一种可行的划分方法 ("s","s","s","s","s","s") 。
>
>
> 提示：
>
> 1 <= s.length <= 105
> s 仅由小写英文字母组成
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/optimal-partition-of-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int partitionString(String s) {
        Set<Character> set;
        int n = s.length();
        int ans = 1;
        for (int i = 0; i < n; ) {
            set = new HashSet<>();
            int j;
            for (j = i; j < n; j++) {
                if (set.contains(s.charAt(j))) {
                    ans++;
                    break;
                } else {
                    set.add(s.charAt(j));
                }
            }
            i = j;
            set.clear();
        }

        return ans;
    }
}
```

### [6178. 将区间分为最少组数](https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/)

> 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示 闭 区间 [lefti, righti] 。
>
> 你需要将 intervals 划分为一个或者多个区间 组 ，每个区间 只 属于一个组，且同一个组中任意两个区间 不相交 。
>
> 请你返回 最少 需要划分成多少个组。
>
> 如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 相交 的。比方说区间 [1, 5] 和 [5, 8] 相交。
>
>  
>
> 示例 1：
>
> 输入：intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]
> 输出：3
> 解释：我们可以将区间划分为如下的区间组：
> - 第 1 组：[1, 5] ，[6, 8] 。
> - 第 2 组：[2, 3] ，[5, 10] 。
> - 第 3 组：[1, 10] 。
> 可以证明无法将区间划分为少于 3 个组。
> 示例 2：
>
> 输入：intervals = [[1,3],[5,6],[8,10],[11,13]]
> 输出：1
> 解释：所有区间互不相交，所以我们可以把它们全部放在一个组内。
>
>
> 提示：
>
> 1 <= intervals.length <= 105
> intervals[i].length == 2
> 1 <= lefti <= righti <= 106
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int minGroups(int[][] intervals) {
        int ans=0;
        PriorityQueue<Integer> pq=new PriorityQueue<>();
        Arrays.sort(intervals,(o1,o2)->o1[0]-o2[0]);

        for(int[] i:intervals){
            int start=i[0],end=i[1];
            if(pq.isEmpty()){
                pq.add(end);
            }else{
                if(pq.peek()<start){
                    pq.poll();
                    pq.offer(end);
                }else{
                    pq.add(end);
                }
            }
        }
        
        return pq.size();
    }
}
```

![image-20220911155943238](https://cdn.jsdelivr.net/gh/yzk656/image/202212241922519.png)

1. 看到与顺序无关就优先想到排序
2. 对end进行排序
3. 不断的进行更新end节点
4. 对于每个不可以连接的，都会放进优先队列中，相当于每个数的一个数组，每次都更新一个数组的end值，每次都把遇到的值交给end最小的值。有点贪心的意味
5. ![image-20220911214644632](https://cdn.jsdelivr.net/gh/yzk656/image/202212241922582.png)

### \6206. 最长递增子序列 II

> 给你一个整数数组 `nums` 和一个整数 `k` 。
>
> 找到 `nums` 中满足以下要求的最长子序列：
>
> - 子序列 **严格递增**
> - 子序列中相邻元素的差值 **不超过** `k` 。
>
> 请你返回满足上述要求的 **最长子序列** 的长度。
>
> **子序列** 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [4,2,1,4,3,4,5,8,15], k = 3
> 输出：5
> 解释：
> 满足要求的最长子序列是 [1,3,4,5,8] 。
> 子序列长度为 5 ，所以我们返回 5 。
> 注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [7,4,5,1,8,12,4,7], k = 5
> 输出：4
> 解释：
> 满足要求的最长子序列是 [4,5,8,12] 。
> 子序列长度为 4 ，所以我们返回 4 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1,5], k = 1
> 输出：1
> 解释：
> 满足要求的最长子序列是 [1] 。
> 子序列长度为 1 ，所以我们返回 1 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `1 <= nums[i], k <= 105`

## 第 86 场双周赛

### [2395. 和相等的子数组](https://leetcode.cn/problems/find-subarrays-with-equal-sum/)

> 给你一个下标从 0 开始的整数数组 nums ，判断是否存在 两个 长度为 2 的子数组且它们的 和 相等。注意，这两个子数组起始位置的下标必须 不相同 。
>
> 如果这样的子数组存在，请返回 true，否则返回 false 。
>
> 子数组 是一个数组中一段连续非空的元素组成的序列。
>
>  
>
> 示例 1：
>
> 输入：nums = [4,2,4]
> 输出：true
> 解释：元素为 [4,2] 和 [2,4] 的子数组有相同的和 6 。
> 示例 2：
>
> 输入：nums = [1,2,3,4,5]
> 输出：false
> 解释：没有长度为 2 的两个子数组和相等。
> 示例 3：
>
> 输入：nums = [0,0,0]
> 输出：true
> 解释：子数组 [nums[0],nums[1]] 和 [nums[1],nums[2]] 的和相等，都为 0 。
> 注意即使子数组的元素相同，这两个子数组也视为不相同的子数组，因为它们在原数组中的起始位置不同。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/find-subarrays-with-equal-sum
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean findSubarrays(int[] nums) {
        int n=nums.length;
        HashMap<Integer,Integer> hashMap=new HashMap<>();
        for(int i=1;i<n;i++){
            int num=nums[i]+nums[i-1];
            hashMap.put(num, hashMap.getOrDefault(num,0)+1);
            if(hashMap.get(num)>=2) return true;
        }
        
        return false;
    }
}
```

### [2396. 严格回文的数字](https://leetcode.cn/problems/strictly-palindromic-number/)

> 如果一个整数 n 在 b 进制下（b 为 2 到 n - 2 之间的所有整数）对应的字符串 全部 都是 回文的 ，那么我们称这个数 n 是 严格回文 的。
>
> 给你一个整数 n ，如果 n 是 严格回文 的，请返回 true ，否则返回 false 。
>
> 如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是 回文的 。
>
>  
>
> 示例 1：
>
> 输入：n = 9
> 输出：false
> 解释：在 2 进制下：9 = 1001 ，是回文的。
> 在 3 进制下：9 = 100 ，不是回文的。
> 所以，9 不是严格回文数字，我们返回 false 。
> 注意在 4, 5, 6 和 7 进制下，n = 9 都不是回文的。
> 示例 2：
>
> 输入：n = 4
> 输出：false
> 解释：我们只考虑 2 进制：4 = 100 ，不是回文的。
> 所以我们返回 false 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/strictly-palindromic-number
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean isStrictlyPalindromic(int n) {
        List<String> list=new ArrayList<>();
        for(int i=2;i<=n-2;i++){
            list.add(Integer.toString(n,i));
        }

        for(String i:list){
            if(!pd(i)) return false;
        }

        return true;
    }

    public boolean pd(String i){
        int n=i.length();
        for(int m=0;m<n/2;m++){
            if(i.charAt(m)!=i.charAt(n-m-1)) return false;
        }
        
        return true;
    }
}
```

### [2397. 被列覆盖的最多行数](https://leetcode.cn/problems/maximum-rows-covered-by-columns/)

> 给你一个下标从 0 开始的 m x n 二进制矩阵 mat 和一个整数 cols ，表示你需要选出的列数。
>
> 如果一行中，所有的 1 都被你选中的列所覆盖，那么我们称这一行 被覆盖 了。
>
> 请你返回在选择 cols 列的情况下，被覆盖 的行数 最大 为多少。
>
>  
>
> 示例 1：
>
> 
>
> 输入：mat = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], cols = 2
> 输出：3
> 解释：
> 如上图所示，覆盖 3 行的一种可行办法是选择第 0 和第 2 列。
> 可以看出，不存在大于 3 行被覆盖的方案，所以我们返回 3 。
> 示例 2：
>
> 
>
> 输入：mat = [[1],[0]], cols = 1
> 输出：2
> 解释：
> 选择唯一的一列，两行都被覆盖了，原因是整个矩阵都被覆盖了。
> 所以我们返回 2 。
>
>
> 提示：
>
> m == mat.length
> n == mat[i].length
> 1 <= m, n <= 12
> mat[i][j] 要么是 0 要么是 1 。
> 1 <= cols <= n
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-rows-covered-by-columns
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
```

## 第 309 场周赛

### [2399. 检查相同字母间的距离](https://leetcode.cn/problems/check-distances-between-same-letters/)

> 给你一个下标从 0 开始的字符串 s ，该字符串仅由小写英文字母组成，s 中的每个字母都 恰好 出现 两次 。另给你一个下标从 0 开始、长度为 26 的的整数数组 distance 。
>
> 字母表中的每个字母按从 0 到 25 依次编号（即，'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25）。
>
> 在一个 匀整 字符串中，第 i 个字母的两次出现之间的字母数量是 distance[i] 。如果第 i 个字母没有在 s 中出现，那么 distance[i] 可以 忽略 。
>
> 如果 s 是一个 匀整 字符串，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：s = "abaccb", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
> 输出：true
> 解释：
> - 'a' 在下标 0 和下标 2 处出现，所以满足 distance[0] = 1 。
> - 'b' 在下标 1 和下标 5 处出现，所以满足 distance[1] = 3 。
> - 'c' 在下标 3 和下标 4 处出现，所以满足 distance[2] = 0 。
> 注意 distance[3] = 5 ，但是由于 'd' 没有在 s 中出现，可以忽略。
> 因为 s 是一个匀整字符串，返回 true 。
> 示例 2：
>
> 输入：s = "aa", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
> 输出：false
> 解释：
> - 'a' 在下标 0 和 1 处出现，所以两次出现之间的字母数量为 0 。
> 但是 distance[0] = 1 ，s 不是一个匀整字符串。
>
>
> 提示：
>
> 2 <= s.length <= 52
> s 仅由小写英文字母组成
> s 中的每个字母恰好出现两次
> distance.length == 26
> 0 <= distance[i] <= 50
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/check-distances-between-same-letters
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean checkDistances(String s, int[] distance) {
        int n=s.length();
        HashMap<Integer,List<Integer>> hashMap=new HashMap<>();
        for(int i=0;i<n;i++){
            hashMap.computeIfAbsent(s.charAt(i)-'a',key->new ArrayList<>()).add(i);
        }

        for(int i=0;i<26;i++){
            int num=distance[i];
            if(!hashMap.containsKey(i)) continue;
            if(hashMap.get(i).get(1)-hashMap.get(i).get(0)-1!=num) return false;
        }

        return true;
    }
}
```

### [2400. 恰好移动 k 步到达某一位置的方法数目](https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/)

> 给你两个 正 整数 startPos 和 endPos 。最初，你站在 无限 数轴上位置 startPos 处。在一步移动中，你可以向左或者向右移动一个位置。
>
> 给你一个正整数 k ，返回从 startPos 出发、恰好 移动 k 步并到达 endPos 的 不同 方法数目。由于答案可能会很大，返回对 109 + 7 取余 的结果。
>
> 如果所执行移动的顺序不完全相同，则认为两种方法不同。
>
> 注意：数轴包含负整数。
>
>  
>
> 示例 1：
>
> 输入：startPos = 1, endPos = 2, k = 3
> 输出：3
> 解释：存在 3 种从 1 到 2 且恰好移动 3 步的方法：
> - 1 -> 2 -> 3 -> 2.
> - 1 -> 2 -> 1 -> 2.
> - 1 -> 0 -> 1 -> 2.
> 可以证明不存在其他方法，所以返回 3 。
> 示例 2：
>
> 输入：startPos = 2, endPos = 5, k = 10
> 输出：0
> 解释：不存在从 2 到 5 且恰好移动 10 步的方法。
>
>
> 提示：
>
> 1 <= startPos, endPos, k <= 1000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int numberOfWays(int startPos, int endPos, int k) {
        int d = Math.abs(endPos - startPos);
        if (d > k || d % 2 != k % 2){
            return 0;
        }

        int mod=(int) 1e9+7;
        int[][] dp=new int[3010][1010];
        startPos+=1000;
        endPos+=1000;

        dp[startPos][0]=1;
        for(int i=1;i<=k;i++){
            for(int j=0;j<=3000;j++){
                dp[j][i]=0;
                if(j!=0) dp[j][i]=(dp[j][i]+dp[j-1][i-1])%mod;
                if(j+1<3000) dp[j][i]=(dp[j][i]+dp[j+1][i-1])%mod;
            }
        }

        return dp[endPos][k];
    }
}
```

## 第 87 场双周赛

### [6184. 统计共同度过的日子数](https://leetcode.cn/problems/count-days-spent-together/)

> Alice 和 Bob 计划分别去罗马开会。
>
> 给你四个字符串 arriveAlice ，leaveAlice ，arriveBob 和 leaveBob 。Alice 会在日期 arriveAlice 到 leaveAlice 之间在城市里（日期为闭区间），而 Bob 在日期 arriveBob 到 leaveBob 之间在城市里（日期为闭区间）。每个字符串都包含 5 个字符，格式为 "MM-DD" ，对应着一个日期的月和日。
>
> 请你返回 Alice和 Bob 同时在罗马的天数。
>
> 你可以假设所有日期都在 同一个 自然年，而且 不是 闰年。每个月份的天数分别为：[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 。
>
>  
>
> 示例 1：
>
> 输入：arriveAlice = "08-15", leaveAlice = "08-18", arriveBob = "08-16", leaveBob = "08-19"
> 输出：3
> 解释：Alice 从 8 月 15 号到 8 月 18 号在罗马。Bob 从 8 月 16 号到 8 月 19 号在罗马，他们同时在罗马的日期为 8 月 16、17 和 18 号。所以答案为 3 。
> 示例 2：
>
> 输入：arriveAlice = "10-01", leaveAlice = "10-31", arriveBob = "11-01", leaveBob = "12-31"
> 输出：0
> 解释：Alice 和 Bob 没有同时在罗马的日子，所以我们返回 0 。
>
>
> 提示：
>
> 所有日期的格式均为 "MM-DD" 。
> Alice 和 Bob 的到达日期都 早于或等于 他们的离开日期。
> 题目测试用例所给出的日期均为 非闰年 的有效日期。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/count-days-spent-together
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```
class Solution {
    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {
        if(leaveAlice.compareTo(arriveBob)<0||leaveBob.compareTo(arriveAlice)<0) return 0;
        HashMap<String,Integer> hashMap=new HashMap<>();
        int[] arr=new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        int a_m=Integer.parseInt(arriveAlice.substring(0,2));
        int a_d=Integer.parseInt(arriveAlice.substring(3));
        int a_e_m=Integer.parseInt(leaveAlice.substring(0,2));
        int a_e_d=Integer.parseInt(leaveAlice.substring(3));

        int b_m=Integer.parseInt(arriveBob.substring(0,2));
        int b_d=Integer.parseInt(arriveBob.substring(3));
        int b_e_m=Integer.parseInt(leaveBob.substring(0,2));
        int b_e_d=Integer.parseInt(leaveBob.substring(3));

        int start=Math.max(a_m,b_m);
        int start_day;
        if(a_m<b_m){
            start_day=b_d;
        }else if(a_m==b_m){
            start_day=Math.max(a_d,b_d);
        }else{
            start_day=a_d;
        }

        int end=Math.min(a_e_m,b_e_m);
        int end_day;
        if(a_e_m<b_e_m){
            end_day=a_e_d;
        }else if(a_e_m==b_e_m){
            end_day=Math.min(a_e_d,b_e_d);
        }else{
            end_day=b_e_d;
        }

        if(start==end)
            return end_day-start_day+1;

        int ans=0;
        ans+=arr[start-1]-start_day+1;
        ans+=end_day;

        for(int i=start+1;i<=end-1;i++){
            int day=arr[i-1];
            ans+=day;
        }

        return ans;
    }
}
```

### [6185. 运动员和训练师的最大匹配数](https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/)

> 给你一个下标从 0 开始的整数数组 players ，其中 players[i] 表示第 i 名运动员的 能力 值，同时给你一个下标从 0 开始的整数数组 trainers ，其中 trainers[j] 表示第 j 名训练师的 训练能力值 。
>
> 如果第 i 名运动员的能力值 小于等于 第 j 名训练师的能力值，那么第 i 名运动员可以 匹配 第 j 名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。
>
> 请你返回满足上述要求 players 和 trainers 的 最大 匹配数。
>
>  
>
> 示例 1：
>
> 输入：players = [4,7,9], trainers = [8,2,5,8]
> 输出：2
> 解释：
> 得到两个匹配的一种方案是：
> - players[0] 与 trainers[0] 匹配，因为 4 <= 8 。
> - players[1] 与 trainers[3] 匹配，因为 7 <= 8 。
> 可以证明 2 是可以形成的最大匹配数。
> 示例 2：
>
> 输入：players = [1,1,1], trainers = [10]
> 输出：1
> 解释：
> 训练师可以匹配所有 3 个运动员
> 每个运动员至多只能匹配一个训练师，所以最大答案是 1 。
>
>
> 提示：
>
> 1 <= players.length, trainers.length <= 105
> 1 <= players[i], trainers[j] <= 109
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-matching-of-players-with-trainers
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int matchPlayersAndTrainers(int[] players, int[] trainers) {
        int n=players.length;
        int m=trainers.length;
        Arrays.sort(players);
        Arrays.sort(trainers);
        int left=0;
        int right=0;

        int ans=0;
        while (left<n&&right<m){
            if(players[left]<=trainers[right]){
                left++;
                right++;
                ans++;
            }else if(players[left]>trainers[right]){
                right++;
            }
        }

        return ans;
    }
}
```

### [2411. 按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/)

[灵茶山艾府的讲解](https://leetcode.cn/problems/find-all-good-indices/solution/d-by-endlesscheng-kya3/)

> 给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。
>
> 换言之，令 Bij 表示子数组 nums[i...j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 max(Bik) ，其中 i <= k <= n - 1 。
> 一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。
>
> 请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。
>
> 子数组 是数组里一段连续非空元素组成的序列。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,0,2,1,3]
> 输出：[3,3,2,2,1]
> 解释：
> 任何位置开始，最大按位或运算的结果都是 3 。
> - 下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。
> - 下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。
> - 下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。
> - 下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。
> - 下标 4 处，能得到结果 3 的最短子数组是 [3] 。
> 所以我们返回 [3,3,2,2,1] 。
> 示例 2：
>
> 输入：nums = [1,2]
> 输出：[2,1]
> 解释：
> 下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。
> 下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。
> 所以我们返回 [2,1] 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int[] smallestSubarrays(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            ans[i] = 1;
            for (int j = i - 1; j >= 0 && (nums[j] | nums[i]) != nums[j]; j--) {
                nums[j]|=nums[i];
                ans[j]=i-j+1;
            }
        }

        return ans;
    }
}
```











## 第 312 场周赛

### [6188. 按身高排序](https://leetcode.cn/problems/sort-the-people/)

> 给你一个字符串数组 names ，和一个由 互不相同 的正整数组成的数组 heights 。两个数组的长度均为 n 。
>
> 对于每个下标 i，names[i] 和 heights[i] 表示第 i 个人的名字和身高。
>
> 请按身高 降序 顺序返回对应的名字数组 names 。
>
>  
>
> 示例 1：
>
> 输入：names = ["Mary","John","Emma"], heights = [180,165,170]
> 输出：["Mary","Emma","John"]
> 解释：Mary 最高，接着是 Emma 和 John 。
> 示例 2：
>
> 输入：names = ["Alice","Bob","Bob"], heights = [155,185,150]
> 输出：["Bob","Alice","Bob"]
> 解释：第一个 Bob 最高，然后是 Alice 和第二个 Bob 。
>
>
> 提示：
>
> n == names.length == heights.length
> 1 <= n <= 103
> 1 <= names[i].length <= 20
> 1 <= heights[i] <= 105
> names[i] 由大小写英文字母组成
> heights 中的所有值互不相同
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/sort-the-people
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public String[] sortPeople(String[] names, int[] heights) {
        TreeMap<Integer,String> treeMap=new TreeMap<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        });
        int n=names.length;
        for(int i=0;i<n;i++){
            treeMap.put(heights[i],names[i]);
        }
        
        String[] ans=new String[n];
        int temp=-1;
        for(int i:treeMap.keySet()){
            ans[++temp]=treeMap.get(i);
        }
        
        return ans;
    }
}
```

### [6189. 按位与最大的最长子数组](https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/)

> 给你一个长度为 n 的整数数组 nums 。
>
> 考虑 nums 中进行 按位与（bitwise AND）运算得到的值 最大 的 非空 子数组。
>
> 换句话说，令 k 是 nums 任意 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 k 的子数组。
> 返回满足要求的 最长 子数组的长度。
>
> 数组的按位与就是对数组中的所有数字进行按位与运算。
>
> 子数组 是数组中的一个连续元素序列。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,2,3,3,2,2]
> 输出：2
> 解释：
> 子数组按位与运算的最大值是 3 。
> 能得到此结果的最长子数组是 [3,3]，所以返回 2 。
> 示例 2：
>
> 输入：nums = [1,2,3,4]
> 输出：1
> 解释：
> 子数组按位与运算的最大值是 4 。 
> 能得到此结果的最长子数组是 [4]，所以返回 1 。
>
>
> 提示：
>
> 1 <= nums.length <= 105
> 1 <= nums[i] <= 106
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int n=nums.length;
        int max=Arrays.stream(nums).max().getAsInt();
        int ans=0;
        int temp_ans=0;
        for(int i:nums){
            if(i==max){
                temp_ans++;
                ans=Math.max(ans,temp_ans);
            }else 
                temp_ans=0;
        }
        
        return ans;
    }
}
```

1. &运算只会使结果更小，不会使结果更大，因此最大值只会是数组中的某一个元素

### [6190. 找到所有好下标](https://leetcode.cn/problems/find-all-good-indices/)

> 给你一个大小为 n 下标从 0 开始的整数数组 nums 和一个正整数 k 。
>
> 对于 k <= i < n - k 之间的一个下标 i ，如果它满足以下条件，我们就称它为一个 好 下标：
>
> 下标 i 之前 的 k 个元素是 非递增的 。
> 下标 i 之后 的 k 个元素是 非递减的 。
> 按 升序 返回所有好下标。
>
>  
>
> 示例 1：
>
> 输入：nums = [2,1,1,1,3,4,1], k = 2
> 输出：[2,3]
> 解释：数组中有两个好下标：
> - 下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。
> - 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。
> 注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。
> 示例 2：
>
> 输入：nums = [2,1,1,2], k = 2
> 输出：[]
> 解释：数组中没有好下标。
>
>
> 提示：
>
> n == nums.length
> 3 <= n <= 105
> 1 <= nums[i] <= 106
> 1 <= k <= n / 2
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/find-all-good-indices
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public List<Integer> goodIndices(int[] nums, int k) {
        List<Integer> ans=new ArrayList<>();
        int n=nums.length;

        int[] right=new int[n];
        Arrays.fill(right,1);
        int[] left=new int[n];
        Arrays.fill(left,1);
        for(int i=n-1;i>=1;i--){
            if(nums[i-1]<=nums[i]){
                right[i-1]=right[i]+1;
            }else {
                right[i-1]=1;
            }
        }
        for(int i=0;i<n-1;i++){
            if(nums[i]>=nums[i+1]){
                left[i+1]=left[i]+1;
            }else{
                left[i+1]=1;
            }
        }

        for(int i=k;i<n-k;i++){
            if(left[i-1]>=k&&right[i+1]>=k)
                ans.add(i);
        }

        return ans;
    }
}
```



## 第 88 场双周赛

### [6212. 删除字符使频率相同](https://leetcode.cn/problems/remove-letter-to-equalize-frequency/)

> 给你一个下标从 0 开始的字符串 word ，字符串只包含小写英文字母。你需要选择 一个 下标并 删除 下标处的字符，使得 word 中剩余每个字母出现 频率 相同。
>
> 如果删除一个字母后，word 中剩余所有字母的出现频率都相同，那么返回 true ，否则返回 false 。
>
> 注意：
>
> 字母 x 的 频率 是这个字母在字符串中出现的次数。
> 你 必须 恰好删除一个字母，不能一个字母都不删除。
>
>
> 示例 1：
>
> 输入：word = "abcc"
> 输出：true
> 解释：选择下标 3 并删除该字母，word 变成 "abc" 且每个字母出现频率都为 1 。
> 示例 2：
>
> 输入：word = "aazz"
> 输出：false
> 解释：我们必须删除一个字母，所以要么 "a" 的频率变为 1 且 "z" 的频率为 2 ，要么两个字母频率反过来。所以不可能让剩余所有字母出现频率相同。
>
>
> 提示：
>
> 2 <= word.length <= 100
> word 只包含小写英文字母。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/remove-letter-to-equalize-frequency
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public boolean equalFrequency(String word) {
        int[] a=new int[26];
        for(int i=0;i<word.length();i++){
            a[word.charAt(i)-'a']++;
        }

        outer:for(int i=0;i<26;i++){
            if(a[i]==0) continue;
            a[i]--;
            int temp=0;
            for(int j=0;j<26;j++){
                if(a[j]==0) continue;
                temp=a[j];
                break;
            }
            for(int j=0;j<26;j++) {
                if (a[j] == 0) continue;
                if (a[j] != temp) {
                    a[i]++;
                    continue outer;
                }
            }
            return true;
        }

        return false;
    }
}
```

### [6197. 最长上传前缀](https://leetcode.cn/problems/longest-uploaded-prefix/)

> 给你一个 n 个视频的上传序列，每个视频编号为 1 到 n 之间的 不同 数字，你需要依次将这些视频上传到服务器。请你实现一个数据结构，在上传的过程中计算 最长上传前缀 。
>
> 如果 闭区间 1 到 i 之间的视频全部都已经被上传到服务器，那么我们称 i 是上传前缀。最长上传前缀指的是符合定义的 i 中的 最大值 。
>
> 请你实现 LUPrefix 类：
>
> LUPrefix(int n) 初始化一个 n 个视频的流对象。
> void upload(int video) 上传 video 到服务器。
> int longest() 返回上述定义的 最长上传前缀 的长度。
>
>
> 示例 1：
>
> 输入：
> ["LUPrefix", "upload", "longest", "upload", "longest", "upload", "longest"]
> [[4], [3], [], [1], [], [2], []]
> 输出：
> [null, null, 0, null, 1, null, 3]
>
> 解释：
> LUPrefix server = new LUPrefix(4);   // 初始化 4个视频的上传流
> server.upload(3);                    // 上传视频 3 。
> server.longest();                    // 由于视频 1 还没有被上传，最长上传前缀是 0 。
> server.upload(1);                    // 上传视频 1 。
> server.longest();                    // 前缀 [1] 是最长上传前缀，所以我们返回 1 。
> server.upload(2);                    // 上传视频 2 。
> server.longest();                    // 前缀 [1,2,3] 是最长上传前缀，所以我们返回 3 。
>
>
> 提示：
>
> 1 <= n <= 105
> 1 <= video <= 105
> video 中所有值 互不相同 。
> upload 和 longest 总调用 次数至多不超过 2 * 105 次。
> 至少会调用 longest 一次。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/longest-uploaded-prefix
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class LUPrefix {
    int[] a;
    int max=0;
    public LUPrefix(int n) {
        a=new int[n];
    }

    public void upload(int video) {
        a[video-1]++;
    }

    public int longest() {
        int i;
        for(i=max;i<a.length;i++){
            if(a[i]==0) {
                max=i-1==-1?0:i;
                return max;
            }
        }
        if(i==a.length){
            max=a.length;
        }
        return max;
    }
}
```

### [6213. 所有数对的异或和](https://leetcode.cn/problems/bitwise-xor-of-all-pairings/)

> 给你两个下标从 0 开始的数组 nums1 和 nums2 ，两个数组都只包含非负整数。请你求出另外一个数组 nums3 ，包含 nums1 和 nums2 中 所有数对 的异或和（nums1 中每个整数都跟 nums2 中每个整数 恰好 匹配一次）。
>
> 请你返回 nums3 中所有整数的 异或和 。
>
>  
>
> 示例 1：
>
> 输入：nums1 = [2,1,3], nums2 = [10,2,5,0]
> 输出：13
> 解释：
> 一个可能的 nums3 数组是 [8,0,7,2,11,3,4,1,9,1,6,3] 。
> 所有这些数字的异或和是 13 ，所以我们返回 13 。
> 示例 2：
>
> 输入：nums1 = [1,2], nums2 = [3,4]
> 输出：0
> 解释：
> 所有数对异或和的结果分别为 nums1[0] ^ nums2[0] ，nums1[0] ^ nums2[1] ，nums1[1] ^ nums2[0] 和 nums1[1] ^ nums2[1] 。
> 所以，一个可能的 nums3 数组是 [2,5,1,6] 。
> 2 ^ 5 ^ 1 ^ 6 = 0 ，所以我们返回 0 。
>
>
> 提示：
>
> 1 <= nums1.length, nums2.length <= 105
> 0 <= nums1[i], nums2[j] <= 109
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/bitwise-xor-of-all-pairings
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
/*
	nums1[a,b]  nums2[c,d,e]
	ans=(a^c)^(a^d)^(a^e)^(b^c)^(b^d)^(b^e)
       =(a^a^a)^(b^b^b)^(c^c)^(d^d)^(e^e)
       
    因此，如果nums2.length%2==1 左侧：a^b
    		nums1.length%2==1 右侧：c^d^
*/



class Solution {
    public int xorAllNums(int[] nums1, int[] nums2) {
        int n1=nums1.length,n2=nums2.length;
        int a=0,b=0;
        for(int i:nums1) a^=i;
        for(int i:nums2) b^=i;

        if(n1%2==0) b=0;
        if(n2%2==0) a=0;

        return a^b;
    }
}
```

## 第 62 场双周赛

### [2022. 将一维数组转变成二维数组](https://leetcode.cn/problems/convert-1d-array-into-2d-array/)

> 给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。
>
> original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。
>
> 请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。
>
>  
>
> 示例 1：
>
>
> 输入：original = [1,2,3,4], m = 2, n = 2
> 输出：[[1,2],[3,4]]
> 解释：
> 构造出的二维数组应该包含 2 行 2 列。
> original 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。
> original 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。
> 示例 2：
>
> 输入：original = [1,2,3], m = 1, n = 3
> 输出：[[1,2,3]]
> 解释：
> 构造出的二维数组应该包含 1 行 3 列。
> 将 original 中所有三个元素放入第一行中，构成要求的二维数组。
> 示例 3：
>
> 输入：original = [1,2], m = 1, n = 1
> 输出：[]
> 解释：
> original 中有 2 个元素。
> 无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。
> 示例 4：
>
> 输入：original = [3], m = 1, n = 2
> 输出：[]
> 解释：
> original 中只有 1 个元素。
> 无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。
>
>
> 提示：
>
> 1 <= original.length <= 5 * 104
> 1 <= original[i] <= 105
> 1 <= m, n <= 4 * 104
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/convert-1d-array-into-2d-array
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        int len=original.length;
        if(len!=m*n) return new int[][]{};
        int[][] ans=new int[m][n];

        int index=-1;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                ans[i][j]=original[++index];
            }
        }

        return ans;
    }
}
```

### [2024. 考试的最大困扰度](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/)

> 一位老师正在出一场由 n 道判断题构成的考试，每道题的答案为 true （用 'T' 表示）或者 false （用 'F' 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 true 或者连续出现 false）。
>
> 给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：
>
> 每次操作中，将问题的正确答案改为 'T' 或者 'F' （也就是将 answerKey[i] 改为 'T' 或者 'F' ）。
> 请你返回在不超过 k 次操作的情况下，最大 连续 'T' 或者 'F' 的数目。
>
>  
>
> 示例 1：
>
> 输入：answerKey = "TTFF", k = 2
> 输出：4
> 解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = "TTTT" 。
> 总共有四个连续的 'T' 。
> 示例 2：
>
> 输入：answerKey = "TFFT", k = 1
> 输出：3
> 解释：我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = "FFFT" 。
> 或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = "TFFF" 。
> 两种情况下，都有三个连续的 'F' 。
> 示例 3：
>
> 输入：answerKey = "TTFTTFTT", k = 1
> 输出：5
> 解释：我们可以将第一个 'F' 换成 'T' ，得到 answerKey = "TTTTTFTT" 。
> 或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = "TTFTTTTT" 。
> 两种情况下，都有五个连续的 'T' 。
>
>
> 提示：
>
> n == answerKey.length
> 1 <= n <= 5 * 104
> answerKey[i] 要么是 'T' ，要么是 'F'
> 1 <= k <= n
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximize-the-confusion-of-an-exam
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maxConsecutiveAnswers(String answerKey, int k) {
        return Math.max(find(answerKey, k, 'T'), find(answerKey, k, 'F'));
    }

    public int find(String answerKey, int k, char c) {
        int n = answerKey.length();
        int ans = 0;
        int left = 0, right = 0;
        while (right < n) {
            if (answerKey.charAt(right) != (c == 'T' ? 'T' : 'F'))
                k--;
            while (k < 0) {
                if (left <= right && answerKey.charAt(left) == (c == 'T' ? 'F' : 'T'))
                    k++;
                left++;
            }
            ans = Math.max(ans, right - left + 1);
            right++;
        }

        return ans;
    }
}
```

## 第 316 场周赛

### [6214. 判断两个事件是否存在冲突](https://leetcode.cn/problems/determine-if-two-events-have-conflict/)

> 给你两个字符串数组 event1 和 event2 ，表示发生在同一天的两个闭区间时间段事件，其中：
>
> event1 = [startTime1, endTime1] 且
> event2 = [startTime2, endTime2]
> 事件的时间为有效的 24 小时制且按 HH:MM 格式给出。
>
> 当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 冲突 。
>
> 如果两个事件之间存在冲突，返回 true ；否则，返回 false 。
>
>  
>
> 示例 1：
>
> 输入：event1 = ["01:15","02:00"], event2 = ["02:00","03:00"]
> 输出：true
> 解释：两个事件在 2:00 出现交集。
> 示例 2：
>
> 输入：event1 = ["01:00","02:00"], event2 = ["01:20","03:00"]
> 输出：true
> 解释：两个事件的交集从 01:20 开始，到 02:00 结束。
> 示例 3：
>
> 输入：event1 = ["10:00","11:00"], event2 = ["14:00","15:00"]
> 输出：false
> 解释：两个事件不存在交集。
>
>
> 提示：
>
> evnet1.length == event2.length == 2.
> event1[i].length == event2[i].length == 5
> startTime1 <= endTime1
> startTime2 <= endTime2
> 所有事件的时间都按照 HH:MM 格式给出
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/determine-if-two-events-have-conflict
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

![image-20221023173216689](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221023173216689.png)

```java
class Solution {
    public boolean haveConflict(String[] event1, String[] event2) {
        if(event1[1].compareTo(event2[0])<0||event2[1].compareTo(event1[0])<0)
            return false;
        return true;
    }
}
```

### [6224. 最大公因数等于 K 的子数组数目](https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/)

> 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的子数组中元素的最大公因数等于 k 的子数组数目。
>
> 子数组 是数组中一个连续的非空序列。
>
> 数组的最大公因数 是能整除数组中所有元素的最大整数。
>
>  
>
> 示例 1：
>
> 输入：nums = [9,3,1,2,6,3], k = 3
> 输出：4
> 解释：nums 的子数组中，以 3 作为最大公因数的子数组如下：
> - [9,3,1,2,6,3]
> - [9,3,1,2,6,3]
> - [9,3,1,2,6,3]
> - [9,3,1,2,6,3]
> 示例 2：
>
> 输入：nums = [4], k = 7
> 输出：0
> 解释：不存在以 7 作为最大公因数的子数组。
>
>
> 提示：
>
> 1 <= nums.length <= 1000
> 1 <= nums[i], k <= 109
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
import java.math.BigInteger;
class Solution {
    public int subarrayGCD(int[] nums, int k) {
        int n=nums.length;
        int ans=0;
        for(int i=0;i<n;i++){
            BigInteger gcd1=BigInteger.ZERO;
            for(int j=i;j<n;j++){
                gcd1=gcd1.gcd(BigInteger.valueOf(nums[j]));
                if(gcd1.intValue()==k)
                    ans++;
                else if(gcd1.intValue()<k)
                    break;
            }
        }
        
        return ans;
    }
}
```

### [6216. 使数组相等的最小开销](https://leetcode.cn/problems/minimum-cost-to-make-array-equal/)

> 给你两个下标从 0 开始的数组 nums 和 cost ，分别包含 n 个 正 整数。
>
> 你可以执行下面操作 任意 次：
>
> 将 nums 中 任意 元素增加或者减小 1 。
> 对第 i 个元素执行一次操作的开销是 cost[i] 。
>
> 请你返回使 nums 中所有元素 相等 的 最少 总开销。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,3,5,2], cost = [2,3,1,14]
> 输出：8
> 解释：我们可以执行以下操作使所有元素变为 2 ：
> - 增加第 0 个元素 1 次，开销为 2 。
> - 减小第 1 个元素 1 次，开销为 3 。
> - 减小第 2 个元素 3 次，开销为 1 + 1 + 1 = 3 。
> 总开销为 2 + 3 + 3 = 8 。
> 这是最小开销。
> 示例 2：
>
> 输入：nums = [2,2,2,2,2], cost = [4,2,8,1,3]
> 输出：0
> 解释：数组中所有元素已经全部相等，不需要执行额外的操作。
>
>
> 提示：
>
> n == nums.length == cost.length
> 1 <= n <= 105
> 1 <= nums[i], cost[i] <= 106
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimum-cost-to-make-array-equal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public long minCost(int[] nums, int[] cost) {
        int  l=0,r=(int) 1e6+10;
        while (l<r){
            int mid=l+(r-l)/2;
            long cost1=get_cost(nums,cost,mid);
            long cost2=get_cost(nums,cost,mid+1);
            if(cost1<cost2){
                r=mid;
            }else
                l=mid+1;
        }

        return get_cost(nums,cost,l);
    }
    private long get_cost(int[] nums,int[] cost,int t){
        long ans=0;
        for(int i=0;i<nums.length;i++){
            ans+=1l*Math.abs(nums[i]-t)*cost[i];
        }

        return ans;
    }
}
```

对于二分查找：

求第一个返回r，求最后一个返回l

![image-20221023235159397](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221023235159397.png)

对于第一个求找到第一个>=5的元素时，如果if的判断条件时>=5，r=mid

第一个

![image-20221024000003644](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221024000003644.png)

![image-20221024002111397](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221024002111397.png)

第二个

![image-20221024001023127](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221024001023127.png)

![image-20221024002148114](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221024002148114.png)

第三个

![image-20221024001144164](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221024001144164.png)

![image-20221024002223834](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221024002223834.png)

第四个

![image-20221024001852832](https://cdn.jsdelivr.net/gh/yzk656/image/image-20221024001852832.png)

==注意==如果要返回的是l，就不要让r等于l可能的值

总结后的代码

```
class Solution {
    public long minCost(int[] nums, int[] cost) {
        int  l=-1,r=(int) 1e6+10;
        while (l+1!=r){
            int mid=l+(r-l+1)/2;
            long cost1=get_cost(nums,cost,mid);
            long cost2=get_cost(nums,cost,mid+1);
            if(cost1<cost2){
                r=mid;
            }else
                l=mid;
        }

        return get_cost(nums,cost,r);
    }
    private long get_cost(int[] nums,int[] cost,int t){
        long ans=0;
        for(int i=0;i<nums.length;i++){
            ans+=1l*Math.abs(nums[i]-t)*cost[i];
        }

        return ans;
    }
}
```

## 第 334 场周赛

### [6369. 左右元素和的差值](https://leetcode.cn/problems/left-and-right-sum-differences/)

> 给你一个下标从 0 开始的整数数组 nums ，请你找出一个下标从 0 开始的整数数组 answer ，其中：
>
> answer.length == nums.length
> answer[i] = |leftSum[i] - rightSum[i]|
> 其中：
>
> leftSum[i] 是数组 nums 中下标 i 左侧元素之和。如果不存在对应的元素，leftSum[i] = 0 。
> rightSum[i] 是数组 nums 中下标 i 右侧元素之和。如果不存在对应的元素，rightSum[i] = 0 。
> 返回数组 answer 。
>
>  
>
> 示例 1：
>
> 输入：nums = [10,4,8,3]
> 输出：[15,1,11,22]
> 解释：数组 leftSum 为 [0,10,14,22] 且数组 rightSum 为 [15,11,3,0] 。
> 数组 answer 为 [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22] 。
> 示例 2：
>
> 输入：nums = [1]
> 输出：[0]
> 解释：数组 leftSum 为 [0] 且数组 rightSum 为 [0] 。
> 数组 answer 为 [|0 - 0|] = [0] 。
>
>
> 提示：
>
> 1 <= nums.length <= 1000
> 1 <= nums[i] <= 105
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/left-and-right-sum-differences
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int[] leftRigthDifference(int[] nums) {
        int n=nums.length;
        int sum=Arrays.stream(nums).sum();
        int[] ans=new int[n];

        int temp1=0,temp2=0;
        for(int i=0;i<n;i++){
            temp1+=i==0?0:nums[i-1];
            temp2=sum-temp1-nums[i];
            ans[i]=Math.abs(temp1-temp2);
        }

        return ans;
    }
}
```

### [6368. 找出字符串的可整除数组](https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/)

> 给你一个下标从 0 开始的字符串 word ，长度为 n ，由从 0 到 9 的数字组成。另给你一个正整数 m 。
>
> word 的 可整除数组 div  是一个长度为 n 的整数数组，并满足：
>
> 如果 word[0,...,i] 所表示的 数值 能被 m 整除，div[i] = 1
> 否则，div[i] = 0
> 返回 word 的可整除数组。
>
>  
>
> 示例 1：
>
> 输入：word = "998244353", m = 3
> 输出：[1,1,0,0,0,1,1,0,0]
> 解释：仅有 4 个前缀可以被 3 整除："9"、"99"、"998244" 和 "9982443" 。
> 示例 2：
>
> 输入：word = "1010", m = 10
> 输出：[0,1,0,1]
> 解释：仅有 2 个前缀可以被 10 整除："10" 和 "1010" 。
>
>
> 提示：
>
> 1 <= n <= 105
> word.length == n
> word 由数字 0 到 9 组成
> 1 <= m <= 109
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/find-the-divisibility-array-of-a-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    // 一个数取余后得到的数再加上其他数值，并不会影响他的余数
    public int[] divisibilityArray(String word, int m) {
        int n=word.length();
        int[] ans=new int[n];

        long temp=0;
        for(int i=0;i<n;i++){
            // 因为要将前面的数转换成只与前一个数的关系，因此要乘上 10 
            temp=(temp*10+word.charAt(i)-'0')%m;
            ans[i]=temp==0?1:0;
        }

        return ans;
    }
}
```


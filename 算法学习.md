# 算法学习

## 2月份

### 前缀和

#### \3956. 截断数组

> 给定一个长度为 n� 的数组 a1,a2,…,an�1,�2,…,��。
>
> 现在，要将该数组从中间截断，得到三个**非空**子数组。
>
> 要求，三个子数组内各元素之和都相等。
>
> 请问，共有多少种不同的截断方法？
>
> #### 输入格式
>
> 第一行包含整数 n�。
>
> 第二行包含 n� 个整数 a1,a2,…,an�1,�2,…,��。
>
> #### 输出格式
>
> 输出一个整数，表示截断方法数量。
>
> #### 数据范围
>
> 前六个测试点满足 1≤n≤101≤�≤10。
> 所有测试点满足 1≤n≤1051≤�≤105，−10000≤ai≤10000−10000≤��≤10000。
>
> #### 输入样例1：
>
> ```
> 4
> 1 2 3 3
> ```
>
> #### 输出样例1：
>
> ```
> 1
> ```
>
> #### 输入样例2：
>
> ```
> 5
> 1 2 3 4 5
> ```
>
> #### 输出样例2：
>
> ```
> 0
> ```
>
> #### 输入样例3：
>
> ```
> 2
> 0 0
> ```
>
> #### 输出样例3：
>
> ```
> 0
> ```

```java
import java.io.*;
import java.util.Scanner;

/**
 * @ClassName: Main
 * @Description: TODO
 * @Author: 杨振坤
 * @date: 2023/2/14 0:11
 */
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = 100010;
        int n = sc.nextInt();
        int[] s = new int[N];
        /*计算前缀和并赋值*/
        for (int i = 1; i <= n; i++) {
            s[i] = s[i - 1] + sc.nextInt();
        }

        /*判断总和是否能被3整除*/
        if (s[n] % 3 != 0) {
            System.out.println(0);
            return;
        } else {
            long sum = 0, cnt = 0;
            /**
             * 遍历第二个点，如果前面总和为S/3,则情况数+1（代表着对于第一个2S/3的所有满足情况）
             * 如果遍历的第二个点为2S/3,则把这种情况的所有满足的cnt加进总和
             * */
            for (int j = 2; j < n; j++) {
                if (s[j - 1] == s[n] / 3)
                    cnt++;
                if (s[j] == s[n] / 3 * 2) {
                    sum += cnt;
                }
            }
            System.out.println(sum);
            return;
        }
    }
}
```

#### \795. 前缀和

> 输入一个长度为 n� 的整数序列。
>
> 接下来再输入 m� 个询问，每个询问输入一对 l,r�,�。
>
> 对于每个询问，输出原序列中从第 l� 个数到第 r� 个数的和。
>
> #### 输入格式
>
> 第一行包含两个整数 n� 和 m�。
>
> 第二行包含 n� 个整数，表示整数数列。
>
> 接下来 m� 行，每行包含两个整数 l� 和 r�，表示一个询问的区间范围。
>
> #### 输出格式
>
> 共 m� 行，每行输出一个询问的结果。
>
> #### 数据范围
>
> 1≤l≤r≤n1≤�≤�≤�,
> 1≤n,m≤1000001≤�,�≤100000,
> −1000≤数列中元素的值≤1000−1000≤数列中元素的值≤1000
>
> #### 输入样例：
>
> ```
> 5 3
> 2 1 3 6 4
> 1 2
> 1 3
> 2 4
> ```
>
> #### 输出样例：
>
> ```
> 3
> 6
> 10
> ```

```java
import java.io.*;
import java.util.Scanner;

/**
 * @ClassName: Main
 * @Description: TODO
 * @Author: 杨振坤
 * @date: 2023/2/14 0:11
 */
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N=100010;
        int n=sc.nextInt();
        int m=sc.nextInt();
        int[] a=new int[N];
        for(int i=1;i<=n;i++){
            a[i]=a[i-1]+sc.nextInt();
        }

        for(int i=0;i<m;i++){
            int l=sc.nextInt();
            int r=sc.nextInt();
            System.out.println(a[r]-a[l-1]);
        }
    }
}
```

#### \796. 子矩阵的和

> 输入一个 n� 行 m� 列的整数矩阵，再输入 q� 个询问，每个询问包含四个整数 x1,y1,x2,y2�1,�1,�2,�2，表示一个子矩阵的左上角坐标和右下角坐标。
>
> 对于每个询问输出子矩阵中所有数的和。
>
> #### 输入格式
>
> 第一行包含三个整数 n，m，q�，�，�。
>
> 接下来 n� 行，每行包含 m� 个整数，表示整数矩阵。
>
> 接下来 q� 行，每行包含四个整数 x1,y1,x2,y2�1,�1,�2,�2，表示一组询问。
>
> #### 输出格式
>
> 共 q� 行，每行输出一个询问的结果。
>
> #### 数据范围
>
> 1≤n,m≤10001≤�,�≤1000,
> 1≤q≤2000001≤�≤200000,
> 1≤x1≤x2≤n1≤�1≤�2≤�,
> 1≤y1≤y2≤m1≤�1≤�2≤�,
> −1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000
>
> #### 输入样例：
>
> ```
> 3 4 3
> 1 7 2 4
> 3 6 2 8
> 2 1 2 3
> 1 1 2 2
> 2 1 3 4
> 1 3 3 4
> ```
>
> #### 输出样例：
>
> ```
> 17
> 27
> 21
> ```

```java
import java.io.*;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = 1010;
        int[][] a = new int[N][N];

        int n = sc.nextInt(), m = sc.nextInt(), q = sc.nextInt();
        /*求前缀和*/
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                a[i][j] = sc.nextInt() + a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
            }
        }

        /*计算访问*/
        for (int i = 0; i < q; i++) {
            int x1 = sc.nextInt(), y1 = sc.nextInt();
            int x2 = sc.nextInt(), y2 = sc.nextInt();
            int num = a[x2][y2] - a[x2][y1 - 1] - a[x1 - 1][y2] + a[x1 - 1][y1 - 1];
            System.out.println(num);
        }
    }
}
```

#### \3729. 改变数组元素

> 给定一个空数组 V� 和一个整数数组 a1,a2,…,an�1,�2,…,��。
>
> 现在要对数组 V� 进行 n� 次操作。
>
> 第 i� 次操作的具体流程如下：
>
> 1. 从数组 V� 尾部插入整数 00。
> 2. 将位于数组 V� 末尾的 ai�� 个元素都变为 11（已经是 11 的不予理会）。
>
> 注意：
>
> - ai�� 可能为 00，即不做任何改变。
> - ai�� 可能大于目前数组 V� 所包含的元素个数，此时视为将数组内所有元素变为 11。
>
> 请你输出所有操作完成后的数组 V�。
>
> #### 输入格式
>
> 第一行包含整数 T�，表示共有 T� 组测试数据。
>
> 每组数据第一行包含整数 n�。
>
> 第二行包含 n� 个整数 a1,a2,…,an�1,�2,…,��。
>
> #### 输出格式
>
> 每组数据输出一行结果，表示所有操作完成后的数组 V�，数组内元素之间用空格隔开。
>
> #### 数据范围
>
> 1≤T≤200001≤�≤20000,
> 1≤n≤2×1051≤�≤2×105,
> 0≤ai≤n0≤��≤�,
> 保证一个测试点内所有 n� 的和不超过 2×1052×105。
>
> #### 输入样例：
>
> ```
> 3
> 6
> 0 3 0 0 1 3
> 10
> 0 0 0 1 0 5 0 0 0 2
> 3
> 0 0 0
> ```
>
> #### 输出样例：
>
> ```
> 1 1 0 1 1 1
> 0 1 1 1 1 1 0 0 1 1
> 0 0 0
> ```

```java
import java.io.*;
import java.util.Scanner;

/**
 * @ClassName: Main
 * @Description: TODO
 * @Author: 杨振坤
 * @date: 2023/2/14 0:11
 */
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T=sc.nextInt();
        while (T--!=0){
            int n=sc.nextInt();
            /*定义差分数组*/
            int[] a=new int[n+2];
            for(int i=1;i<=n;i++){
                int x=sc.nextInt();
                /*i是当前数组长度，x是当前想改变数字的长度大小*/
                x=Math.min(x,i);
                /*加数时的左区间*/
                int l=i-x+1;
                /*加数时的右区间*/
                int r=i;
                a[l]++;
                a[r+1]--;
            }
            /*求前缀和，恢复正常数值*/
            for(int i=1;i<=n;i++){
                a[i]+=a[i-1];
            }
            /*进行更改，因为答案》=1的数为1*/
            for(int i=1;i<=n;i++){
                if(a[i]!=0)
                    a[i]=1;
                System.out.print(a[i]+" ");
            }
            System.out.println();
        }
    }
}
```

#### \99. 激光炸弹

> 地图上有 N� 个目标，用整数 Xi,Yi��,�� 表示目标在地图上的位置，每个目标都有一个价值 Wi��。
>
> **注意**：不同目标可能在同一位置。
>
> 现在有一种新型的激光炸弹，可以摧毁一个包含 R×R�×� 个位置的正方形内的所有目标。
>
> 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y�，� 轴平行。
>
> 求一颗炸弹最多能炸掉地图上总价值为多少的目标。
>
> #### 输入格式
>
> 第一行输入正整数 N� 和 R�，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。
>
> 接下来 N� 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi��,��,��，分别代表目标的 x� 坐标，y� 坐标和价值，数据用空格隔开。
>
> #### 输出格式
>
> 输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。
>
> #### 数据范围
>
> 0≤R≤1090≤�≤109
> 0<N≤100000<�≤10000,
> 0≤Xi,Yi≤50000≤��,��≤5000
> 0≤Wi≤10000≤��≤1000
>
> #### 输入样例：
>
> ```
> 2 1
> 0 0 1
> 1 1 1
> ```
>
> #### 输出样例：
>
> ```
> 1
> ```

```java
import java.io.*;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[][] pre_sum = new int[5010][5010];
        int[][] mat = new int[5010][5010];
        int N = sc.nextInt();
        int R = sc.nextInt();
        /*因为矩形边长最大就是5000，因此R超过5000也没意义了*/
        R = Math.min(R, 5001);


        /*赋值*/
        int Row=R;
        int Col=R;
        for (int i = 0; i < N; i++) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            int w = sc.nextInt();
            /*进行数组赋值*/
            mat[x][y] += w;
            /*求长和宽的最大值*/
            Row=Math.max(Row,x+1);
            Col=Math.max(Col,y+1);
        }

        /*求前缀和*/
        for (int i = 1; i <= Row; i++) {
            for (int j = 1; j <= Col; j++) {
                /*计算二维数组的前缀和*/
                pre_sum[i][j] = pre_sum[i - 1][j] + pre_sum[i][j - 1] - pre_sum[i - 1][j - 1] + mat[i - 1][j - 1];
            }
        }

        /*求解*/
        int ans = 0;
        for (int i = R; i <= Row; i++) {
            for (int j = R; j <= Col; j++) {
                /*计算每个点的最大值，由于边缘不算，因此-R就相当于除去边缘这个点了*/
                ans = Math.max(ans, pre_sum[i][j] - pre_sum[i - R][j] - pre_sum[i][j - R] + pre_sum[i - R][j - R]);
            }
        }
        System.out.println(ans);
    }
}
```

### 差分

#### \797. 差分

> 输入一个长度为 n� 的整数序列。
>
> 接下来输入 m� 个操作，每个操作包含三个整数 l,r,c�,�,�，表示将序列中 [l,r][�,�] 之间的每个数加上 c�。
>
> 请你输出进行完所有操作后的序列。
>
> #### 输入格式
>
> 第一行包含两个整数 n� 和 m�。
>
> 第二行包含 n� 个整数，表示整数序列。
>
> 接下来 m� 行，每行包含三个整数 l，r，c�，�，�，表示一个操作。
>
> #### 输出格式
>
> 共一行，包含 n� 个整数，表示最终序列。
>
> #### 数据范围
>
> 1≤n,m≤1000001≤�,�≤100000,
> 1≤l≤r≤n1≤�≤�≤�,
> −1000≤c≤1000−1000≤�≤1000,
> −1000≤整数序列中元素的值≤1000−1000≤整数序列中元素的值≤1000
>
> #### 输入样例：
>
> ```
> 6 3
> 1 2 2 1 2 1
> 1 3 1
> 3 5 1
> 1 6 1
> ```
>
> #### 输出样例：
>
> ```
> 3 4 5 3 4 2
> ```

```java
import java.io.*;
import java.util.Scanner;

public class Main {
    static int[] a = new int[100010];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();

        /*使用差分进行赋值*/
        for (int i = 1; i <= n; i++) {
            insert(i, i, sc.nextInt());
        }

        /*进行插入操作*/
        for (int i = 0; i < m; i++) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            int c = sc.nextInt();
            insert(l, r, c);
        }

        /*进行归位*/
        for (int i = 1; i <= n; i++) {
            a[i] += a[i - 1];
            System.out.print(a[i] + " ");
        }

    }

    //方法
    public static void insert(int l, int r, int c) {
        a[l] += c;
        a[r + 1] -= c;
    }
}
```

#### \798. 差分矩阵

> 输入一个 n� 行 m� 列的整数矩阵，再输入 q� 个操作，每个操作包含五个整数 x1,y1,x2,y2,c�1,�1,�2,�2,�，其中 (x1,y1)(�1,�1) 和 (x2,y2)(�2,�2) 表示一个子矩阵的左上角坐标和右下角坐标。
>
> 每个操作都要将选中的子矩阵中的每个元素的值加上 c�。
>
> 请你将进行完所有操作后的矩阵输出。
>
> #### 输入格式
>
> 第一行包含整数 n,m,q�,�,�。
>
> 接下来 n� 行，每行包含 m� 个整数，表示整数矩阵。
>
> 接下来 q� 行，每行包含 55 个整数 x1,y1,x2,y2,c�1,�1,�2,�2,�，表示一个操作。
>
> #### 输出格式
>
> 共 n� 行，每行 m� 个整数，表示所有操作进行完毕后的最终矩阵。
>
> #### 数据范围
>
> 1≤n,m≤10001≤�,�≤1000,
> 1≤q≤1000001≤�≤100000,
> 1≤x1≤x2≤n1≤�1≤�2≤�,
> 1≤y1≤y2≤m1≤�1≤�2≤�,
> −1000≤c≤1000−1000≤�≤1000,
> −1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000
>
> #### 输入样例：
>
> ```
> 3 4 3
> 1 2 2 1
> 3 2 2 1
> 1 1 1 1
> 1 1 2 2 1
> 1 3 2 3 2
> 3 1 3 4 1
> ```
>
> #### 输出样例：
>
> ```
> 2 3 4 1
> 4 3 4 1
> 2 2 2 2
> ```

```java
import java.io.*;
import java.util.Scanner;

public class Main {
    /*差分：原数组a，差分数组b
        原数组是差分数组的前缀和
    * */
    static int[][] a = new int[1010][1010];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int q = sc.nextInt();

        /*赋值*/
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                int num = sc.nextInt();
                insert(i, j, i, j, num);
            }
        }

        /*进行操作*/
        for (int i = 0; i < q; i++) {
            int x1 = sc.nextInt(), y1 = sc.nextInt();
            int x2 = sc.nextInt(), y2 = sc.nextInt();
            int num = sc.nextInt();
            insert(x1, y1, x2, y2, num);
        }

        /*恢复原数组*/
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
                System.out.print(a[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void insert(int x1, int y1, int x2, int y2, int c) {
        a[x1][y1] += c;
        a[x1][y2 + 1] -= c;
        a[x2+1][y1] -= c;
        a[x2+1][y2+1] += c;
    }
}
```

#### \100. 增减序列

> 给定一个长度为 n� 的数列 a1,a2,…,an�1,�2,…,��，每次可以选择一个区间 [l,r][�,�]，使下标在这个区间内的数都加一或者都减一。
>
> 求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。
>
> #### 输入格式
>
> 第一行输入正整数 n�。
>
> 接下来 n� 行，每行输入一个整数，第 i+1�+1 行的整数代表 ai��。
>
> #### 输出格式
>
> 第一行输出最少操作次数。
>
> 第二行输出最终能得到多少种结果。
>
> #### 数据范围
>
> 0<n≤1050<�≤105,
> 0≤ai<21474836480≤��<2147483648
>
> #### 输入样例：
>
> ```
> 4
> 1
> 1
> 2
> 2
> ```
>
> #### 输出样例：
>
> ```
> 1
> 2
> ```

![image-20230217130020895](C:\Users\27939\AppData\Roaming\Typora\typora-user-images\image-20230217130020895.png)

```java
import java.io.*;
import java.util.Scanner;

public class Main {
    static int N = 100010;
    static int[] a = new int[N];
    static int[] b = new int[N];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for (int i = 1; i <= n; i++)
            a[i] = sc.nextInt();

        for (int i = 1; i <= n; i++)
            b[i] = a[i] - a[i - 1];

        long p = 0, q = 0;
        for (int i = 2; i <= n; i++) {
            if (b[i] > 0)
                p += b[i];
            else
                q -= b[i];
        }

        System.out.println(Math.max(p, q));
        System.out.println(Math.abs(p - q) + 1);
    }
}
```

### 二分

#### \1460. 我在哪？

> 农夫约翰出门沿着马路散步，但是他现在发现自己可能迷路了！
>
> 沿路有一排共 N� 个农场。
>
> 不幸的是农场并没有编号，这使得约翰难以分辨他在这条路上所处的位置。
>
> 然而，每个农场都沿路设有一个彩色的邮箱，所以约翰希望能够通过查看最近的几个邮箱的颜色来唯一确定他所在的位置。
>
> 每个邮箱的颜色用 A..Z�..� 之间的一个字母来指定，所以沿着道路的 N� 个邮箱的序列可以用一个长为 N� 的由字母 A..Z�..� 组成的字符串来表示。
>
> 某些邮箱可能会有相同的颜色。
>
> 约翰想要知道最小的 K� 的值，使得他查看任意连续 K� 个邮箱序列，他都可以唯一确定这一序列在道路上的位置。
>
> 例如，假设沿路的邮箱序列为 `ABCDABC` 。
>
> 约翰不能令 K=3�=3，因为如果他看到了 `ABC`，则沿路有两个这一连续颜色序列可能所在的位置。
>
> 最小可行的 K� 的值为 K=4�=4，因为如果他查看任意连续 44 个邮箱，那么可得到的连续颜色序列可以唯一确定他在道路上的位置。
>
> #### 输入格式
>
> 输入的第一行包含 N�，第二行包含一个由 N� 个字符组成的字符串，每个字符均在 A..Z�..� 之内。
>
> #### 输出格式
>
> 输出一行，包含一个整数，为可以解决农夫约翰的问题的最小 K� 值。
>
> #### 数据范围
>
> 1≤N≤1001≤�≤100
>
> #### 输入样例：
>
> ```
> 7
> ABCDABC
> ```
>
> #### 输出样例：
>
> ```
> 4
> ```

```java
import java.io.*;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        char[] str = sc.next().toCharArray();

        for (int k = 1; k <= N; k++) {
            boolean flag = false;
            for (int i = 0; i + k - 1 < N; i++) {
                for (int j = i + 1; j + k - 1 < N; j++) {
                    boolean same = true;
                    for (int u = 0; u < k; u++) {
                        if (str[i + u] != str[j + u]) {
                            same = false;
                            break;
                        }
                    }
                    if (same) {
                        flag = true;
                        break;
                    }
                }
                if (flag)
                    break;
            }
            if (!flag) {
                System.out.println(k);
                break;
            }
        }
    }
}
```

#### \1460. 我在哪？

> 农夫约翰出门沿着马路散步，但是他现在发现自己可能迷路了！
>
> 沿路有一排共 N� 个农场。
>
> 不幸的是农场并没有编号，这使得约翰难以分辨他在这条路上所处的位置。
>
> 然而，每个农场都沿路设有一个彩色的邮箱，所以约翰希望能够通过查看最近的几个邮箱的颜色来唯一确定他所在的位置。
>
> 每个邮箱的颜色用 A..Z�..� 之间的一个字母来指定，所以沿着道路的 N� 个邮箱的序列可以用一个长为 N� 的由字母 A..Z�..� 组成的字符串来表示。
>
> 某些邮箱可能会有相同的颜色。
>
> 约翰想要知道最小的 K� 的值，使得他查看任意连续 K� 个邮箱序列，他都可以唯一确定这一序列在道路上的位置。
>
> 例如，假设沿路的邮箱序列为 `ABCDABC` 。
>
> 约翰不能令 K=3�=3，因为如果他看到了 `ABC`，则沿路有两个这一连续颜色序列可能所在的位置。
>
> 最小可行的 K� 的值为 K=4�=4，因为如果他查看任意连续 44 个邮箱，那么可得到的连续颜色序列可以唯一确定他在道路上的位置。
>
> #### 输入格式
>
> 输入的第一行包含 N�，第二行包含一个由 N� 个字符组成的字符串，每个字符均在 A..Z�..� 之内。
>
> #### 输出格式
>
> 输出一行，包含一个整数，为可以解决农夫约翰的问题的最小 K� 值。
>
> #### 数据范围
>
> 1≤N≤1001≤�≤100
>
> #### 输入样例：
>
> ```
> 7
> ABCDABC
> ```
>
> #### 输出样例：
>
> ```
> 4
> ```

```java
import java.io.*;
import java.util.HashSet;
import java.util.Scanner;

public class Main {
    static int N;
    static String str;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        str = sc.next();

        int l = 1, r = N;
        while (l < r) {
            int mid = l + r >> 1;
            if (check(mid))
                r = mid;
            else
                l = mid + 1;
        }

        System.out.println(r);
    }

    public static boolean check(int mid) {
        HashSet<String> hashSet = new HashSet<>();

        for (int i = 0; i + mid - 1 < N; i++) {
            String s = str.substring(i, i + mid);
            if (hashSet.contains(s)) {
                return false;
            }
            hashSet.add(s);
        }


        return true;
    }
}
```

#### \789. 数的范围

> 
> 给定一个按照升序排列的长度为 n� 的整数数组，以及 q� 个查询。
>
> 对于每个查询，返回一个元素 k� 的起始位置和终止位置（位置从 00 开始计数）。
>
> 如果数组中不存在该元素，则返回 `-1 -1`。
>
> #### 输入格式
>
> 第一行包含整数 n� 和 q�，表示数组长度和询问个数。
>
> 第二行包含 n� 个整数（均在 1∼100001∼10000 范围内），表示完整数组。
>
> 接下来 q� 行，每行包含一个整数 k�，表示一个询问元素。
>
> #### 输出格式
>
> 共 q� 行，每行包含两个整数，表示所求元素的起始位置和终止位置。
>
> 如果数组中不存在该元素，则返回 `-1 -1`。
>
> #### 数据范围
>
> 1≤n≤1000001≤�≤100000
> 1≤q≤100001≤�≤10000
> 1≤k≤100001≤�≤10000
>
> #### 输入样例：
>
> ```
> 6 3
> 1 2 2 3 3 4
> 3
> 4
> 5
> ```
>
> #### 输出样例：
>
> ```
> 3 4
> 5 5
> -1 -1
> ```

```java
import java.io.*;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = 100010;
        int n = sc.nextInt();
        int q = sc.nextInt();

        int[] a = new int[N];
        for (int i = 0; i < n; i++)
            a[i] = sc.nextInt();


        for (int i = 0; i < q; i++) {

            int l = 0, r = n - 1;
            int num = sc.nextInt();
            while (l < r) {
                int mid = l + r >> 1;
                if (a[mid] >= num)
                    r = mid;
                else
                    l = mid + 1;
            }

            int temp1 = l;
            if (a[temp1] != num) {
                System.out.println("-1 -1");
            } else {

                l = 0;
                r = n - 1;
                while (l < r) {
                    int mid = l + r + 1 >> 1;
                    if (a[mid] <= num)
                        l = mid;
                    else
                        r = mid - 1;
                }

                int temp2 = r;
                System.out.println(temp1 + " " + temp2);
            }
        }
    }
}
```

#### 对于二分法的理解

![image-20230222152426282](https://cdn.jsdelivr.net/gh/yzk656/image/202302221603735.png)

左边代表满足要求，右边代表不满足要求

==寻找红色右端点（<=num）==

if（true）

​	说明mid在左边

​		【mid，r】；l=mid

​	否则在右边

​		【l,mid-1】;r=mid-1

==寻找绿色左端点(>=num)==

if（true）

​		说明在右边

​		【l,mid】;r=mid

​		否则在左边

​		【mid+1，r】；l=mid+1



### 双指针

#### \799. 最长连续不重复子序列

> 给定一个长度为 n� 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
>
> #### 输入格式
>
> 第一行包含整数 n�。
>
> 第二行包含 n� 个整数（均在 0∼1050∼105 范围内），表示整数序列。
>
> #### 输出格式
>
> 共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。
>
> #### 数据范围
>
> 1≤n≤1051≤�≤105
>
> #### 输入样例：
>
> ```
> 5
> 1 2 2 3 5
> ```
>
> #### 输出样例：
>
> ```
> 3
> ```

```java
import java.io.*;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = 100010;

        int n = sc.nextInt();
        int[] a = new int[N];
        int[] b = new int[N];

        for (int i = 0; i < n; i++)
            a[i] = sc.nextInt();

        int ans = 1;
        for (int i = 0, j = 0; i < n; i++) {
            b[a[i]]++;
            while (b[a[i]] > 1) {
                b[a[j]]--;
                j++;
            }
            ans = Math.max(ans, i - j + 1);
        }

        System.out.println(ans);
    }
}
```

1. 如果查询某个区间后，不再使用该区间，则使用普通双指针做法

   ```java
   for(int i=0;i<n;i++){
       if(?){
           int j=i+1;
           while(*){}
       }
   }
   ```

2. 如果查询某个区间后还使用该区间，则朴素做法

   ```java
   for(int i=0;i<n;i++){
       for(int j=i+1;j<n;j++){
           
       }
   }
   ```

   进行转换

   ```java
   for(int i=0,j=0;i<n;i++){
       while(j<i&&?){
           j++;
       }
   }
   ```

#### \800. 数组元素的目标和

>  给定两个升序排序的有序数组 A� 和 B�，以及一个目标值 x�。
>
> 数组下标从 00 开始。
>
> 请你求出满足 A[i]+B[j]=x�[�]+�[�]=� 的数对 (i,j)(�,�)。
>
> 数据保证有唯一解。
>
> #### 输入格式
>
> 第一行包含三个整数 n,m,x�,�,�，分别表示 A� 的长度，B� 的长度以及目标值 x�。
>
> 第二行包含 n� 个整数，表示数组 A�。
>
> 第三行包含 m� 个整数，表示数组 B�。
>
> #### 输出格式
>
> 共一行，包含两个整数 i� 和 j�。
>
> #### 数据范围
>
> 数组长度不超过 105105。
> 同一数组内元素各不相同。
> 1≤数组元素≤1091≤数组元素≤109
>
> #### 输入样例：
>
> ```
> 4 5 6
> 1 2 4 7
> 3 4 6 8 9
> ```
>
> #### 输出样例：
>
> ```
> 1 1
> ```

```java
import java.io.*;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = 100010;
        int[] a = new int[N];
        int[] b = new int[N];

        int n = sc.nextInt(), m = sc.nextInt(), x = sc.nextInt();
        for (int i = 0; i < n; i++)
            a[i] = sc.nextInt();
        for (int i = 0; i < m; i++)
            b[i] = sc.nextInt();

        for (int i = 0, j = m - 1; i < n; i++) {
            while (j >= 0 && a[i] + b[j] > x) {
                j--;
            }
            if (a[i] + b[j] == x) {
                System.out.println(i + " " + j);
                return;
            }
        }
    }
}
```

#### \2816. 判断子序列

> 给定一个长度为 n� 的整数序列 a1,a2,…,an�1,�2,…,�� 以及一个长度为 m� 的整数序列 b1,b2,…,bm�1,�2,…,��。
>
> 请你判断 a� 序列是否为 b� 序列的子序列。
>
> 子序列指序列的一部分项按**原有次序排列**而得的序列，例如序列 {a1,a3,a5}{�1,�3,�5} 是序列 {a1,a2,a3,a4,a5}{�1,�2,�3,�4,�5} 的一个子序列。
>
> #### 输入格式
>
> 第一行包含两个整数 n,m�,�。
>
> 第二行包含 n� 个整数，表示 a1,a2,…,an�1,�2,…,��。
>
> 第三行包含 m� 个整数，表示 b1,b2,…,bm�1,�2,…,��。
>
> #### 输出格式
>
> 如果 a� 序列是 b� 序列的子序列，输出一行 `Yes`。
>
> 否则，输出 `No`。
>
> #### 数据范围
>
> 1≤n≤m≤1051≤�≤�≤105,
> −109≤ai,bi≤109−109≤��,��≤109
>
> #### 输入样例：
>
> ```
> 3 5
> 1 3 5
> 1 2 3 4 5
> ```
>
> #### 输出样例：
>
> ```
> Yes
> ```

```java
import java.io.*;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = 100010;
        int[] a = new int[N], b = new int[N];

        int n = sc.nextInt(), m = sc.nextInt();
        for (int i = 0; i < n; i++)
            a[i] = sc.nextInt();
        for (int i = 0; i < m; i++)
            b[i] = sc.nextInt();

        for (int i = 0, j = 0; j < m;) {
            if (a[i] == b[j]) {
                i++;
                j++;
            } else
                j++;

            if (i == n) {
                System.out.println("Yes");
                return;
            }
        }

        System.out.println("No");
    }
}
```

### 递推

#### \3777. 砖块

> n� 个砖块排成一排，从左到右编号依次为 1∼n1∼�。
>
> 每个砖块要么是黑色的，要么是白色的。
>
> 现在你可以进行以下操作若干次（可以是 00 次）：
>
> 选择两个相邻的砖块，反转它们的颜色。（黑变白，白变黑）
>
> 你的目标是通过不超过 3n3� 次操作，将所有砖块的颜色变得一致。
>
> #### 输入格式
>
> 第一行包含整数 T�，表示共有 T� 组测试数据。
>
> 每组数据第一行包含一个整数 n�。
>
> 第二行包含一个长度为 n� 的字符串 s�。其中的每个字符都是 `W` 或 `B`，如果第 i� 个字符是 `W`，则表示第 i� 号砖块是白色的，如果第 i� 个字符是 `B`，则表示第 i� 个砖块是黑色的。
>
> #### 输出格式
>
> 每组数据，如果无解则输出一行 −1−1。
>
> 否则，首先输出一行 k�，表示需要的操作次数。
>
> 如果 k>0�>0，则还需再输出一行 k� 个整数，p1,p2,…,pk�1,�2,…,��。其中 pi�� 表示第 i� 次操作，选中的砖块为 pi�� 和 pi+1��+1 号砖块。
>
> 如果方案不唯一，则输出任意合理方案即可。
>
> #### 数据范围
>
> 1≤T≤101≤�≤10，
> 2≤n≤2002≤�≤200。
>
> #### 输入样例：
>
> ```
> 4
> 8
> BWWWWWWB
> 4
> BWBB
> 5
> WWWWW
> 3
> BWB
> ```
>
> #### 输出样例：
>
> ```
> 3
> 6 2 4
> -1
> 0
> 2
> 2 1
> ```

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N = 210;
    static char[] a = new char[N];
    static int n;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();
        while (T-- > 0) {
            n = sc.nextInt();
            String s=sc.next();
            if (!check(s,'W') && !check(s,'B'))
                System.out.println(-1);
        }
    }

    public static boolean check(String s,char c) {
        List<Integer> ans = new ArrayList<>();
        a=s.toCharArray();
        for (int i = 0; i + 1 < n; i++) {
            if (a[i] != c) {
                update(i);
                update(i + 1);
                ans.add(i);
            }
        }

        if (a[n - 1] != a[0])
            return false;

        System.out.println(ans.size());
        for (int i : ans)
            System.out.print(i + 1 + " ");
        if (ans.size() != 0)
            System.out.println();

        return true;
    }

    public static void update(int i) {
        if (a[i] == 'W')
            a[i] = 'B';
        else
            a[i] = 'W';
    }
}
```

#### \95. 费解的开关

>  你玩过“拉灯”游戏吗？
>
> 2525 盏灯排成一个 5×55×5 的方形。
>
> 每一个灯都有一个开关，游戏者可以改变它的状态。
>
> 每一步，游戏者可以改变某一个灯的状态。
>
> 游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。
>
> 我们用数字 11 表示一盏开着的灯，用数字 00 表示关着的灯。
>
> 下面这种状态
>
> ```
> 10111
> 01101
> 10111
> 10000
> 11011
> ```
>
> 在改变了最左上角的灯的状态后将变成：
>
> ```
> 01111
> 11101
> 10111
> 10000
> 11011
> ```
>
> 再改变它正中间的灯后状态将变成：
>
> ```
> 01111
> 11001
> 11001
> 10100
> 11011
> ```
>
> 给定一些游戏的初始状态，编写程序判断游戏者是否可能在 66 步以内使所有的灯都变亮。
>
> #### 输入格式
>
> 第一行输入正整数 n�，代表数据中共有 n� 个待解决的游戏初始状态。
>
> 以下若干行数据分为 n� 组，每组数据有 55 行，每行 55 个字符。
>
> 每组数据描述了一个游戏的初始状态。
>
> 各组数据间用一个空行分隔。
>
> #### 输出格式
>
> 一共输出 n� 行数据，每行有一个小于等于 66 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。
>
> 对于某一个游戏初始状态，若 66 步以内无法使所有灯变亮，则输出 −1−1。
>
> #### 数据范围
>
> 0<n≤5000<�≤500
>
> #### 输入样例：
>
> ```
> 3
> 00111
> 01011
> 10001
> 11010
> 11100
> 
> 11101
> 11101
> 11110
> 11111
> 11111
> 
> 01111
> 11111
> 11111
> 11111
> 11111
> ```
>
> 输出样例：
>
> ```
> 3
> 2
> -1
> ```

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N = 6;
    static char[][] g = new char[N][N];
    static char[][] copy = new char[N][N];
    static int[] dx = {-1, 0, 1, 0, 0};
    static int[] dy = {0, 1, 0, -1, 0};

    public static void trun(int x, int y) {
        for (int i = 0; i < 5; i++) {
            int a = x + dx[i], b = y + dy[i];
            if (a < 0 || a >= 5 || b < 0 || b >= 5)
                continue;
            g[a][b] ^= 1;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        while (n-- > 0) {
            for (int i = 0; i < 5; i++)
                g[i] = sc.next().toCharArray();

            int ans = 10;
            for (int op = 0; op < 32; op++) {
                for (int j = 0; j < 5; j++)
                    copy[j] = Arrays.copyOf(g[j], 5);

                int step = 0;

                for (int i = 0; i < 5; i++) {
                    if ((op >> i & 1) == 1) {
                        step++;
                        trun(0, i);
                    }
                }

                for (int i = 0; i < 4; i++) {
                    for (int j = 0; j < 5; j++) {
                        if (g[i][j] == '0') {
                            step++;
                            trun(i + 1, j);
                        }
                    }
                }

                boolean dark = false;

                for (int j = 0; j < 5; j++) {
                    if (g[4][j] == '0') {
                        dark = true;
                        break;
                    }
                }

                if (!dark) {
                    ans = Math.min(ans, step);
                }

                for (int j = 0; j < 5; j++) {
                    g[j] = Arrays.copyOf(copy[j], 5);
                }
            }

            if (ans > 6)
                ans = -1;
            System.out.println(ans);
        }
    }
}
```

###  递归

#### \1497. 树的遍历

> 一个二叉树，树中每个节点的权值互不相同。
>
> 现在给出它的后序遍历和中序遍历，请你输出它的层序遍历。
>
> #### 输入格式
>
> 第一行包含整数 N�，表示二叉树的节点数。
>
> 第二行包含 N� 个整数，表示二叉树的后序遍历。
>
> 第三行包含 N� 个整数，表示二叉树的中序遍历。
>
> #### 输出格式
>
> 输出一行 N� 个整数，表示二叉树的层序遍历。
>
> #### 数据范围
>
> 1≤N≤301≤�≤30,
> 官方并未给出各节点权值的取值范围，为方便起见，在本网站范围取为 1∼N1∼�。
>
> #### 输入样例：
>
> ```
> 7
> 2 3 1 5 7 6 4
> 1 2 3 4 5 6 7
> ```
>
> #### 输出样例：
>
> ```
> 4 1 6 3 5 7 2
> ```

```java
import java.util.*;

public class Main {
    static int N = 35;
    static int[] a = new int[N];
    static int[] b = new int[N];
    static int[] index = new int[N];

    static int[] l = new int[N];
    static int[] r = new int[N];

    static int n;

    public static int build(int al, int ar, int bl, int br, int d) {
        if (al > ar)
            return 0;
        int val = a[ar];
        int k = index[val];

        l[val] = build(al, al + k - bl - 1, bl, k - 1, d + 1);
        r[val] = build(al + k - bl, ar - 1, k + 1, br, d + 1);

        return val;
    }

    public static void bfs() {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(a[n - 1]);
        while (queue.size() != 0) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int t = queue.poll();
                if (l[t] != 0)
                    queue.offer(l[t]);
                if (r[t] != 0)
                    queue.offer(r[t]);
                System.out.print(t+" ");
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();
        for (int i = 0; i < n; i++)
            a[i] = sc.nextInt();
        for (int i = 0; i < n; i++)
            b[i] = sc.nextInt();

        for (int i = 0; i < n; i++)
            index[b[i]] = i;

        build(0, n - 1, 0, n - 1, 0);

        bfs();
    }
}
```

1. Queue有三种实现方式

   ​	LinkedList

   ​	ArrayList

   ​	PriorityQueue（有序的）

2. bfs遍历二叉树，就是将节点存在左右数组里面

==约数之和公式==

![image-20230224161935723](https://cdn.jsdelivr.net/gh/yzk656/image/202302241619960.png)

试除法求约数

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        while (n-- > 0) {
            int num = sc.nextInt();
            List<Integer> ans = fun(num);
            Collections.sort(ans);
            for (int i : ans)
                System.out.print(i + " ");
            System.out.println();
        }
    }

    public static List<Integer> fun(int num) {
        List<Integer> ans = new ArrayList<>();
        for (int i = 1; i <= num / i; i++) {
            if (num % i == 0) {
                ans.add(i);
                if (num / i != i)
                    ans.add(num / i);
            }
        }

        return ans;
    }
}
```

==约数个数求法==

![image-20230224191940365](https://cdn.jsdelivr.net/gh/yzk656/image/202302241919489.png)

![image-20230224202916416](https://cdn.jsdelivr.net/gh/yzk656/image/202302242029459.png)

![image-20230224191958285](https://cdn.jsdelivr.net/gh/yzk656/image/202302241919360.png)

![image-20230224192005804](https://cdn.jsdelivr.net/gh/yzk656/image/202302241920855.png)

==约数之和==

![image-20230224201741889](https://cdn.jsdelivr.net/gh/yzk656/image/202302242017949.png)

<img src="https://cdn.jsdelivr.net/gh/yzk656/image/202302242042505.png" alt="image-20230224204225323" style="zoom:50%;" />

#### \870. 约数个数

>  给定 n� 个正整数 ai��，请你输出这些数的乘积的约数个数，答案对 109+7109+7 取模。
>
> #### 输入格式
>
> 第一行包含整数 n�。
>
> 接下来 n� 行，每行包含一个整数 ai��。
>
> #### 输出格式
>
> 输出一个整数，表示所给正整数的乘积的约数个数，答案需对 109+7109+7 取模。
>
> #### 数据范围
>
> 1≤n≤1001≤�≤100,
> 1≤ai≤2×1091≤��≤2×109
>
> #### 输入样例：
>
> ```
> 3
> 2
> 6
> 8
> ```
>
> #### 输出样例：
>
> ```
> 12
> ```

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        int mod = (int) 1e9 + 7;
        long ans = 1;

        for (int i = 0; i < n; i++) {
            int num = sc.nextInt();

            for (int j = 2; j <= num / j; j++) {
                while (num % j == 0) {
                    num /= j;
                    hashMap.put(j, hashMap.getOrDefault(j, 0) + 1);
                }
            }
            if(num>1)
             hashMap.put(num,hashMap.getOrDefault(num,0)+1);
        }

        for (Integer key : hashMap.keySet()) {
            ans = ans * (hashMap.get(key)+1) % mod;
        }

        System.out.println(ans);
    }
}
```

#### \97. 约数之和

> 假设现在有两个自然数 A� 和 B�，S� 是 AB�� 的所有约数之和。
>
> 请你求出 Smod9901�mod9901 的值是多少。
>
> #### 输入格式
>
> 在一行中输入用空格隔开的两个整数 A� 和 B�。
>
> #### 输出格式
>
> 输出一个整数，代表 Smod9901�mod9901 的值。
>
> #### 数据范围
>
> 0≤A,B≤5×1070≤�,�≤5×107
>
> #### 输入样例：
>
> ```
> 2 3
> ```
>
> #### 输出样例：
>
> ```
> 15
> ```
>
> **注意**: A� 和 B� 不会同时为 00。

```java
import java.util.*;

public class Main {
    static int mod = 9901;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int a = sc.nextInt();
        int b = sc.nextInt();

        int ans = 1;
        /*对a进行分解质因数*/
        for (int i = 2; i * i <= a; i++) {
            if (a % i == 0) {
                int s = 0;
                while (a % i == 0) {
                    a /= i;
                    s++;
                }
                ans = ans * sum(i, b * s + 1) % mod;
            }
        }
        System.out.println(a);
        if (a > 1) {
            ans = ans * sum(a, b + 1) % mod;
        }

        if (a == 0)
            ans = 0;
        System.out.println(ans);
    }

    public static int sum(int a, int b) {
        a %= mod;
        if (b == 1) return 1;
        if (b % 2 == 0)
            return (1 + qmi(a, b / 2)) * sum(a, b / 2) % mod;
        return (1 + a * sum(a, b - 1) % mod) % mod;
        // return (sum(a, b - 1) + qmi(a, b - 1)) % mod;
    }

    public static int qmi(int a, int k) {
        long ans = 1;
        a %= mod;
        while (k > 0) {
            if ((k & 1) == 1)
                ans = ans * a % mod;
            a = a * a % mod;
            k >>= 1;
        }

        return (int) ans % mod;
    }
}
```

### 并查集

#### \1249. 亲戚

> 或许你并不知道，你的某个朋友是你的亲戚。
>
> 他可能是你的曾祖父的外公的女婿的外甥女的表姐的孙子。
>
> 如果能得到完整的家谱，判断两个人是否是亲戚应该是可行的，但如果两个人的最近公共祖先与他们相隔好几代，使得家谱十分庞大，那么检验亲戚关系实非人力所能及。
>
> 在这种情况下，最好的帮手就是计算机。
>
> 为了将问题简化，你将得到一些亲戚关系的信息，如Marry和Tom是亲戚，Tom和Ben是亲戚，等等。
>
> 从这些信息中，你可以推出Marry和Ben是亲戚。
>
> 请写一个程序，对于我们的关于亲戚关系的提问，以最快的速度给出答案。
>
> #### 输入格式
>
> 输入由两部分组成。
>
> 第一部分以 N,M�,� 开始。N� 为问题涉及的人的个数。这些人的编号为 1,2,3,…,N1,2,3,…,�。下面有 M� 行，每行有两个数 ai,bi��,��，表示已知 ai�� 和 bi�� 是亲戚。
>
> 第二部分以 Q� 开始。以下 Q� 行有 Q� 个询问，每行为 ci,di��,��，表示询问 ci�� 和 di�� 是否为亲戚。
>
> #### 输出格式
>
> 对于每个询问 ci,di��,��，输出一行：若 ci�� 和 di�� 为亲戚，则输出“Yes”，否则输出“No”。
>
> #### 数据范围
>
> 1≤N≤200001≤�≤20000,
> 1≤M≤1061≤�≤106,
> 1≤Q≤1061≤�≤106
>
> #### 输入样例：
>
> ```
> 10 7
> 2 4
> 5 7
> 1 3
> 8 9
> 1 2
> 5 6
> 2 3
> 3
> 3 4
> 7 10
> 8 9
> ```
>
> #### 输出样例：
>
> ```
> Yes
> No
> Yes
> ```

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N = 20010;
    static int[] p = new int[N];

    static BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

    static String s[];

    public static int find(int x) {
        if (p[x] != x)
            p[x] = find(p[x]);
        return p[x];
    }


    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);

        s=bufferedReader.readLine().trim().split(" ");
        int n = Integer.valueOf(s[0]);
        int m = Integer.valueOf(s[1]);

        for (int i = 1; i <= n; ++i)
            p[i] = i;

        for (int i = 0; i < m; ++i) {
            s=bufferedReader.readLine().trim().split(" ");
            int a = Integer.valueOf(s[0]);
            int b = Integer.valueOf(s[1]);

            p[find(a)] = find(b);
        }

        s=bufferedReader.readLine().trim().split(" ");
        int q = Integer.valueOf(s[0]);
        for (int i = 0; i < q; ++i) {
            s=bufferedReader.readLine().trim().split(" ");
            int a = Integer.valueOf(s[0]);
            int b = Integer.valueOf(s[1]);

            if (find(a) == find(b)) {
                out.println("Yes");
            } else {
                out.println("No");
            }
        }

        out.flush();
    }
}
```

#### \836. 合并集合

> 一共有 n� 个数，编号是 1∼n1∼�，最开始每个数各自在一个集合中。
>
> 现在要进行 m� 个操作，操作共有两种：
>
> 1. `M a b`，将编号为 a� 和 b� 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
> 2. `Q a b`，询问编号为 a� 和 b� 的两个数是否在同一个集合中；
>
> #### 输入格式
>
> 第一行输入整数 n� 和 m�。
>
> 接下来 m� 行，每行包含一个操作指令，指令为 `M a b` 或 `Q a b` 中的一种。
>
> #### 输出格式
>
> 对于每个询问指令 `Q a b`，都要输出一个结果，如果 a� 和 b� 在同一集合内，则输出 `Yes`，否则输出 `No`。
>
> 每个结果占一行。
>
> #### 数据范围
>
> 1≤n,m≤1051≤�,�≤105
>
> #### 输入样例：
>
> ```
> 4 5
> M 1 2
> M 3 4
> Q 1 2
> Q 1 3
> Q 3 4
> ```
>
> #### 输出样例：
>
> ```
> Yes
> No
> Yes
> ```

```java
import java.util.*;

public class Main{
    static int N=100010;
    static int[] p=new int[N];
    
    public static int find(int x){
        if(p[x]!=x)
            p[x]=find(p[x]);
        return p[x];
    }
    
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        
        int n=sc.nextInt();
        
        for(int i=1;i<=n;i++)
            p[i]=i;
            
        int m=sc.nextInt();
        while(m-->0){
            char a=sc.next().charAt(0);
            int b=sc.nextInt();
            int c=sc.nextInt();
            if(a=='M'){
                p[find(b)]=find(c);
            }else{
                if(find(b)==find(c)){
                    System.out.println("Yes");
                }else
                    System.out.println("No");
            }
        }
    }
}
```

#### \837. 连通块中点的数量

> 给定一个包含 n� 个点（编号为 1∼n1∼�）的无向图，初始时图中没有边。
>
> 现在要进行 m� 个操作，操作共有三种：
>
> 1. `C a b`，在点 a� 和点 b� 之间连一条边，a� 和 b� 可能相等；
> 2. `Q1 a b`，询问点 a� 和点 b� 是否在同一个连通块中，a� 和 b� 可能相等；
> 3. `Q2 a`，询问点 a� 所在连通块中点的数量；
>
> #### 输入格式
>
> 第一行输入整数 n� 和 m�。
>
> 接下来 m� 行，每行包含一个操作指令，指令为 `C a b`，`Q1 a b` 或 `Q2 a` 中的一种。
>
> #### 输出格式
>
> 对于每个询问指令 `Q1 a b`，如果 a� 和 b� 在同一个连通块中，则输出 `Yes`，否则输出 `No`。
>
> 对于每个询问指令 `Q2 a`，输出一个整数表示点 a� 所在连通块中点的数量
>
> 每个结果占一行。
>
> #### 数据范围
>
> 1≤n,m≤1051≤�,�≤105
>
> #### 输入样例：
>
> ```
> 5 5
> C 1 2
> Q1 1 2
> Q2 1
> C 2 5
> Q2 5
> ```
>
> #### 输出样例：
>
> ```
> Yes
> 2
> 3
> ```

```java
import java.util.*;

public class Main {
    static int N = 100010;
    static int[] p = new int[N];
    static int[] size = new int[N];

    /*路径压缩*/
    public static int find(int x) {
        /*如果当前节点的值不等于其下标i，说明当前节点不是 祖先节点*/
        if (p[x] != x)
            /*寻找祖先节点，将最终的祖先节点的值付给路过的每一个节点*/
            p[x] = find(p[x]);
        return p[x];
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();

        for (int i = 1; i <= n; i++) {
            p[i] = i;
            size[i] = 1;
        }

        int m = sc.nextInt();
        while (m-- > 0) {
            String a = sc.next();
            if (a.equals("C")) {
                int b = sc.nextInt();
                int c = sc.nextInt();
                /*如果两个数不在同一个集合中*/
                if (find(b) != find(c)) {
                    /*如果是将b作为子节点，因此需要将b节点下的连通块点的数量 加到 c节点上*/
                    size[find(c)] += size[find(b)];
                    /*find函数是寻找祖先节点，p指的是当前节点的数值*/
                    p[find(b)] = find(c);
                }
            } else if (a.equals("Q1")) {
                int b = sc.nextInt();
                int c = sc.nextInt();
                /*如果祖先节点相同*/
                if (find(b) == find(c)) {
                    System.out.println("Yes");
                } else
                    System.out.println("No");
            } else if (a.equals("Q2")) {
                int b = sc.nextInt();
                /*总共的连通块中点的数量是存储在 祖先节点之中的*/
                System.out.println(size[find(b)]);
            }
        }
    }
}
```

## 6月份

### [2611. 老鼠和奶酪](https://leetcode.cn/problems/mice-and-cheese/)

> 有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。
>
> 下标为 i 处的奶酪被吃掉的得分为：
>
> 如果第一只老鼠吃掉，则得分为 reward1[i] 。
> 如果第二只老鼠吃掉，则得分为 reward2[i] 。
> 给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。
>
> 请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大 得分为多少。
>
>  
>
> 示例 1：
>
> 输入：reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2
> 输出：15
> 解释：这个例子中，第一只老鼠吃掉第 2 和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。
> 总得分为 4 + 4 + 3 + 4 = 15 。
> 15 是最高得分。
> 示例 2：
>
> 输入：reward1 = [1,1], reward2 = [1,1], k = 2
> 输出：2
> 解释：这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。
> 总得分为 1 + 1 = 2 。
> 2 是最高得分。
>
>
> 提示：
>
> 1 <= n == reward1.length == reward2.length <= 105
> 1 <= reward1[i], reward2[i] <= 1000
> 0 <= k <= n
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/mice-and-cheese
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int miceAndCheese(int[] reward1, int[] reward2, int k) {
        //sum(reward2)+max(dif(reward1-reward2))

        int n = reward1.length;

        //找到差值最大的
        int[] temp = new int[n];
        int sum=0;
        for (int i = 0; i < n; i++) {
            sum+=reward2[i];
            temp[i] = reward1[i] - reward2[i];
        }

        Arrays.sort(temp);
        for(int i=0;i<k;i++){
            sum+=temp[n-i-1];
        }

        return sum;
    }
}
```

1. 使用贪心算法
2. 先求出`reward2`数组总和，然后求出两数组之间差值数组，进行排序，找出`K`个最大值即可
3. 计算`sum(reward2)+max(dif(reward1-reward2))`

### [1156. 单字符重复子串的最大长度](https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/)

> 如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。
>
> 给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。
>
>  
>
> 示例 1：
>
> 输入：text = "ababa"
> 输出：3
> 示例 2：
>
> 输入：text = "aaabaaa"
> 输出：6
> 示例 3：
>
> 输入：text = "aaabbaaa"
> 输出：4
> 示例 4：
>
> 输入：text = "aaaaa"
> 输出：5
> 示例 5：
>
> 输入：text = "abcdef"
> 输出：1
>
>
> 提示：
>
> 1 <= text.length <= 20000
> text 仅由小写英文字母组成。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/swap-for-longest-repeated-character-substring
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class Solution {
    public int maxRepOpt1(String text) {
        int n = text.length();
        int ans=0;

        //计算当前字符的个数
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < n; i++)
            map.merge(text.charAt(i), 1, Integer::sum);

        for (int i = 0; i < n; ) {
            int j = i;
            //计算当前字符的连续子串长度
            while (j < n && text.charAt(i) == text.charAt(j)) {
                j++;
            }
            //此时j为第一个不予i相等的字符
            int cur_len = j - i;

            //如果对于当前字符前面有空位或者后面有空位则可以+1，不过要保证还有当前字符在其他位置
            if (cur_len < map.getOrDefault(text.charAt(i), 0) && (j < n || i > 0)){
                ans=Math.max(ans,cur_len+1);
            }

            //判断后面是否存在与当前字符连续的子串
            int k=j+1;
            while (k<n&&text.charAt(k)==text.charAt(i)){
                k++;
            }

            //注意: 难点
            //如果k-i比总个数还多1，说明替换一个字符可以是当前所有字符连续，则返回总个数即可
            //如果k-i比总个数少，说明有其他分散的字符可以下标为 j 的字符进行替换，因此k-j即是答案
            //则获取k-i和map.count最少的那个即可
            ans=Math.max(ans,Math.min(k-i,map.getOrDefault(text.charAt(i),0)));
            //将位置重新放到第一个不相同的字符上
            i=j;
        }

        return ans;
    }
}
```

1. 解决办法：滑动窗口

2.     //注意: 难点
       //如果k-i比总个数还多1，说明替换一个字符可以是当前所有字符连续，则返回总个数即可
       //如果k-i比总个数少，说明有其他分散的字符可以下标为 j 的字符进行替换，因此k-j即是答案
       //则获取k-i和map.count最少的那个即可



### [1171. 从链表中删去总和值为零的连续节点](https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/)

> 给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。
>
> 删除完毕后，请你返回最终结果链表的头节点。
>
>  
>
> 你可以返回任何满足题目要求的答案。
>
> （注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）
>
> 示例 1：
>
> 输入：head = [1,2,-3,3,1]
> 输出：[3,1]
> 提示：答案 [1,2,1] 也是正确的。
> 示例 2：
>
> 输入：head = [1,2,3,-3,4]
> 输出：[1,2,4]
> 示例 3：
>
> 输入：head = [1,2,3,-3,-2]
> 输出：[1]
>
>
> 提示：
>
> 给你的链表中可能有 1 到 1000 个节点。
> 对于链表中的每个节点，节点的值：-1000 <= node.val <= 1000.
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
        //在最前面添加一个节点，表示前缀和为0
        ListNode temp=new ListNode(0);
        temp.next=head;

        //将前缀和作为key，因为相同的key会被替换，因此key的值相同的两个节点，中间区间会被删除掉
        HashMap<Integer,ListNode> hashMap=new HashMap<>();
        int sum=0;
        ListNode temp1=temp;
        //进行切割，对于相同前缀和，会更改节点位置
        while (temp1!=null){
            sum+=temp1.val;
            hashMap.put(sum,temp1);
            temp1=temp1.next;
        }

        sum=0;
        temp1=temp;
        //对temp链表进行修改
        while (temp1!=null){
            sum+=temp1.val;
            temp1.next=hashMap.get(sum).next;
            temp1=temp1.next;
        }

        //将修改后的链表进行返回
        return temp.next;
    }

}
```

1. 利用`hashmap`对于相同的key会进行替换这一属性，来删除连续子序列和为`1`的序列









































































## 搜索与图论

### DFS

#### \843. n-皇后问题

> n−�−皇后问题是指将 n� 个皇后放在 n×n�×� 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
>
> ![1_597ec77c49-8-queens.png](https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png)
>
> 现在给定整数 n�，请你输出所有的满足条件的棋子摆法。
>
> #### 输入格式
>
> 共一行，包含整数 n�。
>
> #### 输出格式
>
> 每个解决方案占 n� 行，每行输出一个长度为 n� 的字符串，用来表示完整的棋盘状态。
>
> 其中 `.` 表示某一个位置的方格状态为空，`Q` 表示某一个位置的方格上摆着皇后。
>
> 每个方案输出完成后，输出一个空行。
>
> **注意：行末不能有多余空格。**
>
> 输出方案的顺序任意，只要不重复且没有遗漏即可。
>
> #### 数据范围
>
> 1≤n≤91≤�≤9
>
> #### 输入样例：
>
> ```
> 4
> ```
>
> #### 输出样例：
>
> ```
> .Q..
> ...Q
> Q...
> ..Q.
> 
> ..Q.
> Q...
> ...Q
> .Q..
> ```

```java
/**
 * @ClassName: Main
 * @Description: TODO
 * @Author: 杨振坤
 * @date: 2023/4/16 22:22
 */

import java.util.Scanner;

public class Main {
    static int n, N = 20;
    static char[][] group = new char[N][N];
    static boolean[] col = new boolean[N];
    static boolean[] zg = new boolean[N];
    static boolean[] nzg = new boolean[N];


    public static void dfs(int u) {
        if (n == u) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++)
                    System.out.print(group[i][j]);
                System.out.println();
            }
            System.out.println();
        }

        for (int i = 0; i < n; i++) {
            if (!col[i] && !zg[u + i] && !nzg[n - u + i]) {
                group[u][i] = 'Q';
                col[i] = zg[u + i] = nzg[n - u + i] = true;
                dfs(u + 1);
                col[i] = zg[u + i] = nzg[n - u + i] = false;
                group[u][i]='.';
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                group[i][j] = '.';
            }
        }

        dfs(0);
    }
}
```

1. 对于正对角线、斜对角线的表示【由于 i-u 可能是负数，因此可以添加一个 n 防止为负数】 

   > 看一下看一下
   > 我们可以对nn正方形进行一个枚举
   > (0,0) (0,1) (0,2) (0,3) (0,4)
   > (1,0) (1,1) (1,2) (1,3) (1,4)
   > (2,0) (2,1) (2,2) (2,3) (2,4)
   > (3,0) (3,1) (3,2) (3,3) (3,4)
   > (4,0) (4,1) (4,2) (4,3) (4,4)
   > 这是，坐标，可以理解为一个是x，一个是y，也可以理解为题目中的u和i
   > 仔细观察，每条从右上到左下的对角线，他们横纵坐标相加的值都是相等的,对比下面图看一下
   > (0) (1) (2) (3) (4)
   > (1) (2) (3) (4) (5)
   > (2) (3) (4) (5) (6)
   > (3) (4) (5) (6) (7)
   > (4) (5) (6) (7) (8)
   > *这就是u + i 为 副对角线，因为这条对角线上的点都可以通过u + i，也就是横纵坐标来找到这个dg[u + i];
   > 同样的，u - i + n 的值我也列出来
   > (5) (4) (3) (2) (1)
   > (6) (5) (4) (3) (2)
   > (7) (6) (5) (4) (3)
   > (8) (7) (6) (5) (4)
   > (9) (8) (7) (6) (5)
   > 看看，从左上角到右下角的这些主对角线，是不是横纵坐标相加都等于一个值
   > 那么到此，这边对角线问题就解决了，是不是很好理解呢-v-
   >
   > 作者：讲究
   > 链接：https://www.acwing.com/problem/content/discussion/content/6702/
   > 来源：AcWing
   > 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 栈与队列

![image-20230321224330035](https://cdn.jsdelivr.net/gh/yzk656/image/202303212243133.png)

![image-20230321225818509](https://cdn.jsdelivr.net/gh/yzk656/image/202303212258545.png)

![image-20230321231826319](https://cdn.jsdelivr.net/gh/yzk656/image/202303212318364.png)

#### [剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

> 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
>
> 
>
> 示例 1：
>
> 输入：
> ["CQueue","appendTail","deleteHead","deleteHead","deleteHead"]
> [[],[3],[],[],[]]
> 输出：[null,null,3,-1,-1]
> 示例 2：
>
> 输入：
> ["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
> [[],[],[5],[2],[],[]]
> 输出：[null,-1,null,null,5,2]
> 提示：
>
> 1 <= values <= 10000
> 最多会对 appendTail、deleteHead 进行 10000 次调用
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class CQueue {
    Deque<Integer> inDeque;
    Deque<Integer> outDeque;
    public CQueue() {
        inDeque=new ArrayDeque();
        outDeque=new ArrayDeque();
    }
    
    public void appendTail(int value) {
        inDeque.offerLast(value);
        while(!inDeque.isEmpty()) {
            outDeque.offerLast(inDeque.pollFirst());
        }
    }
    
    public int deleteHead() {
        if(outDeque.isEmpty()){
            return -1;
        }else{
            return outDeque.pollFirst();
        }
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

掌握知识：

1. 学会使用Deque，是通过ArrayDeque实现
2. 对于Deque，删除头：pollFirst；添加尾：offerLast

#### [剑指 Offer 30. 包含min函数的栈](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)

> 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
>
> 
>
> 示例:
>
> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.min();   --> 返回 -3.
> minStack.pop();
> minStack.top();      --> 返回 0.
> minStack.min();   --> 返回 -2.
>
>
> 提示：
>
> 各函数的调用总次数不超过 20000 次
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
class MinStack {
    Deque<Integer> d1;
    Deque<Integer> temp;
    int min;
    /** initialize your data structure here. */
    public MinStack() {
        d1=new ArrayDeque<>();
        temp=new ArrayDeque<>();
        temp.push(Integer.MAX_VALUE);
    }
    
    public void push(int x) {
        d1.push(x);
        temp.push(Math.min(x,temp.peek()));
    }
    
    public void pop() {
        temp.pop();
        d1.pop();
    }
    
    public int top() {
        return d1.peek();
    }
    
    public int min() {
        return temp.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
```

掌握知识：

1. Deque既可以使用队列的方法：offerLast、pollFirst；也可以使用栈的方法：push、poll、peek
2. 通过辅助栈，实现对于每一层，都有对应的最小值存储在辅助栈中
3. 出现了一次：由于有可能删除最小值，因此不能与遇到的最小值比较（`min=Math.min(x,min);`）,要与当前层的最小值进行比较`temp.push(Math.min(x,temp.peek()));`

### 链表

#### [剑指 Offer 24. 反转链表](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
>
> 
>
> 示例:
>
> 输入: 1->2->3->4->5->NULL
> 输出: 5->4->3->2->1->NULL
>
>
> 限制：
>
> 0 <= 节点个数 <= 5000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev=null;
        ListNode cur=head;
        while(cur!=null){
            ListNode next=cur.next;
            cur.next=prev;
            prev=cur;
            cur=next;
        }
        return prev;
    }
}
```

掌握知识：

1. 翻转只需要后一个指向前一个，一次只需要设置一个前置节点；不需要删除A-》B，只需要建立A《=B

2. 进行移动

       ListNode next=cur.next;
           cur.next=prev;
           prev=cur;
           cur=next;

#### [剑指 Offer 35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

> 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
>
> 
>
> 示例 1：
>
> 
>
> 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
> 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
> 示例 2：
>
> 
>
> 输入：head = [[1,1],[2,1]]
> 输出：[[1,1],[2,1]]
> 示例 3：
>
> 
>
> 输入：head = [[3,null],[3,0],[3,null]]
> 输出：[[3,null],[3,0],[3,null]]
> 示例 4：
>
> 输入：head = []
> 输出：[]
> 解释：给定的链表为空（空指针），因此返回 null。
>
>
> 提示：
>
> -10000 <= Node.val <= 10000
> Node.random 为空（null）或指向链表中的节点。
> 节点数目不超过 1000 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    HashMap<Node,Node> hashmap=new HashMap<>();
    public Node copyRandomList(Node head) {
        if(head==null)
            return null;
        if(!hashmap.containsKey(head)){
            Node temp=new Node(head.val);
            hashmap.put(head,temp);
            temp.next=copyRandomList(head.next);
            temp.random=copyRandomList(head.random);
        }
        return hashmap.get(head);
    }
}
```

掌握知识：

1. 递归，使用哈希表记录每个节点的新的节点的指针

### BFS

#### \844. 走迷宫

> 给定一个 n×m�×� 的二维整数数组，用来表示一个迷宫，数组中只包含 00 或 11，其中 00 表示可以走的路，11 表示不可通过的墙壁。
>
> 最初，有一个人位于左上角 (1,1)(1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。
>
> 请问，该人从左上角移动至右下角 (n,m)(�,�) 处，至少需要移动多少次。
>
> 数据保证 (1,1)(1,1) 处和 (n,m)(�,�) 处的数字为 00，且一定至少存在一条通路。
>
> #### 输入格式
>
> 第一行包含两个整数 n� 和 m�。
>
> 接下来 n� 行，每行包含 m� 个整数（00 或 11），表示完整的二维数组迷宫。
>
> #### 输出格式
>
> 输出一个整数，表示从左上角移动至右下角的最少移动次数。
>
> #### 数据范围
>
> 1≤n,m≤1001≤�,�≤100
>
> #### 输入样例：
>
> ```
> 5 5
> 0 1 0 0 0
> 0 1 0 1 0
> 0 0 0 0 0
> 0 1 1 1 0
> 0 0 0 1 0
> ```
>
> #### 输出样例：
>
> ```
> 8
> ```

```java
import java.io.BufferedInputStream;
import java.util.Deque;
import java.util.LinkedList;
import java.util.Scanner;

public class Main {
    static int N = 110;
    static int[][] g = new int[N][N];
    static int[][] d = new int[N][N];

    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedInputStream(System.in));

        int n = sc.nextInt();
        int m = sc.nextInt();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                g[i][j] = sc.nextInt();
            }
        }

        System.out.println(bfs(n, m));
        sc.close();
    }

    public static int bfs(int n, int m) {
        Deque<int[]> deque = new LinkedList<>();
        d[0][0] = 0;
        int[] dx = new int[]{0, 1, 0, -1};
        int[] dy = new int[]{1, 0, -1, 0};
        deque.addFirst(new int[]{0,0});

        while (!deque.isEmpty()) {
            int[] a = deque.removeFirst();

            for (int i = 0; i < 4; i++) {
                int x = a[0] + dx[i];
                int y = a[1] + dy[i];

                if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == 0){
                    d[x][y]=d[a[0]][a[1]]+1;
                    deque.addLast(new int[]{x,y});
                }
            }
        }

        return d[n-1][m-1];
    }
}
```

1. 使用双端队列
